; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\flash\obj\bsp_spi_bus.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_spi_bus.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\User -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\User\FatFS\src -I..\..\Libraries\STM32_USB_Device_Library\Class\msc\inc -I..\..\Libraries\STM32_USB_Device_Library\Core\inc -I..\..\Libraries\STM32_USB_OTG_Driver\inc -I..\..\User\usbd_mass_storage -I..\..\User\ft_support -I..\..\User\test -I..\..\User\emenu -I..\..\User\chip_ft -I..\..\User\lwrb -I..\..\User\easylogger\inc -I..\..\User\easylogger\plugins\file -I..\..\User\LOG -I..\..\User\MultiButton-1.1.0 -I..\..\User\cm_backtrace -I..\..\User\MultiTimer -I.\RTE\_Flash -IC:\Users\qizha\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\qizha\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.17.1\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F407xx -D_RTE_ -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY --signed_chars --omf_browse=.\flash\obj\bsp_spi_bus.crf ..\..\User\bsp_stm32f4xx\src\bsp_spi_bus.c]
                          THUMB

                          AREA ||i.bsp_InitSPIBus||, CODE, READONLY, ALIGN=2

                  bsp_InitSPIBus PROC
;;;79     */
;;;80     void bsp_InitSPIBus(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;81     {
;;;82     #ifdef SOFT_SPI		/* 软件SPI */
;;;83     	GPIO_InitTypeDef  GPIO_InitStructure;
;;;84     
;;;85     	/* 打开GPIO时钟 */
;;;86     	RCC_AHB1PeriphClockCmd(RCC_SCK | RCC_MOSI | RCC_MISO, ENABLE);	
;;;87         
;;;88     	/* 配置SPI引脚SCK、MISO 和 MOSI为复用推挽模式 */
;;;89     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;90     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;	/* 推挽输出模式 */
;;;91         GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
;;;92     	GPIO_InitStructure.GPIO_Pin = PIN_SCK;
;;;93     	GPIO_Init(PORT_SCK, &GPIO_InitStructure);
;;;94     
;;;95     	GPIO_InitStructure.GPIO_Pin = PIN_MOSI;
;;;96     	GPIO_Init(PORT_MOSI, &GPIO_InitStructure);	
;;;97     
;;;98     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;		/* MISO 设置为输入上拉 */
;;;99     	GPIO_InitStructure.GPIO_Pin = PIN_MISO;
;;;100    	GPIO_Init(PORT_MISO, &GPIO_InitStructure);
;;;101    #endif
;;;102    
;;;103    #ifdef HARD_SPI		/* 硬件SPI */
;;;104    	GPIO_InitTypeDef GPIO_InitStructure;
;;;105    
;;;106    	/* 开启 SPI 时钟 */
;;;107    	//RCC_APB2PeriphClockCmd(RCC_SPI, ENABLE);
;;;108    	
;;;109    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE);
000002  2101              MOVS     r1,#1
000004  0388              LSLS     r0,r1,#14
000006  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;110    	
;;;111    	/* 使能 GPIO 时钟 */
;;;112    	RCC_AHB1PeriphClockCmd(RCC_SCK | RCC_MOSI | RCC_MISO, ENABLE);	
00000a  2101              MOVS     r1,#1
00000c  2002              MOVS     r0,#2
00000e  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;113    
;;;114    	GPIO_PinAFConfig(GPIOB, GPIO_PinSource13, GPIO_AF_SPI2);
000012  2205              MOVS     r2,#5
000014  210d              MOVS     r1,#0xd
000016  4822              LDR      r0,|L1.160|
000018  f7fffffe          BL       GPIO_PinAFConfig
;;;115    	GPIO_PinAFConfig(GPIOB, GPIO_PinSource14, GPIO_AF_SPI2);
00001c  2205              MOVS     r2,#5
00001e  210e              MOVS     r1,#0xe
000020  481f              LDR      r0,|L1.160|
000022  f7fffffe          BL       GPIO_PinAFConfig
;;;116    	GPIO_PinAFConfig(GPIOB, GPIO_PinSource15, GPIO_AF_SPI2);
000026  2205              MOVS     r2,#5
000028  210f              MOVS     r1,#0xf
00002a  481d              LDR      r0,|L1.160|
00002c  f7fffffe          BL       GPIO_PinAFConfig
;;;117        
;;;118    	/* 配置 SPI引脚SCK、MISO 和 MOSI为复用推挽模式 */
;;;119    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
000030  2002              MOVS     r0,#2
000032  f88d0004          STRB     r0,[sp,#4]
;;;120    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
000036  2003              MOVS     r0,#3
000038  f88d0005          STRB     r0,[sp,#5]
;;;121        GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
00003c  2000              MOVS     r0,#0
00003e  f88d0006          STRB     r0,[sp,#6]
;;;122    	GPIO_InitStructure.GPIO_Pin = PIN_SCK;	
000042  f44f5000          MOV      r0,#0x2000
000046  9000              STR      r0,[sp,#0]
;;;123    	GPIO_Init(PORT_SCK, &GPIO_InitStructure);
000048  4669              MOV      r1,sp
00004a  4815              LDR      r0,|L1.160|
00004c  f7fffffe          BL       GPIO_Init
;;;124    	
;;;125    	GPIO_InitStructure.GPIO_Pin = PIN_MISO;	
000050  f44f4080          MOV      r0,#0x4000
000054  9000              STR      r0,[sp,#0]
;;;126    	GPIO_Init(PORT_MISO, &GPIO_InitStructure);
000056  4669              MOV      r1,sp
000058  4811              LDR      r0,|L1.160|
00005a  f7fffffe          BL       GPIO_Init
;;;127    
;;;128    	GPIO_InitStructure.GPIO_Pin = PIN_MOSI;	
00005e  f44f4000          MOV      r0,#0x8000
000062  9000              STR      r0,[sp,#0]
;;;129    	GPIO_Init(PORT_MOSI, &GPIO_InitStructure);
000064  4669              MOV      r1,sp
000066  480e              LDR      r0,|L1.160|
000068  f7fffffe          BL       GPIO_Init
;;;130    		
;;;131    	bsp_SPI_Init(SPI_Direction_2Lines_FullDuplex | SPI_Mode_Master | SPI_DataSize_8b
00006c  f44f7041          MOV      r0,#0x304
000070  f7fffffe          BL       bsp_SPI_Init
;;;132    		| SPI_CPOL_Low | SPI_CPHA_1Edge | SPI_NSS_Soft | SPI_BaudRatePrescaler_2 | SPI_FirstBit_MSB);	
;;;133    	
;;;134    	/* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
;;;135    	SPI_HARD->I2SCFGR &= SPI_Mode_Select;		/* 选择SPI模式，不是I2S模式 */
000074  480b              LDR      r0,|L1.164|
000076  8800              LDRH     r0,[r0,#0]
000078  f24f71ff          MOV      r1,#0xf7ff
00007c  4008              ANDS     r0,r0,r1
00007e  4909              LDR      r1,|L1.164|
000080  8008              STRH     r0,[r1,#0]
;;;136    
;;;137    	/*---------------------------- SPIx CRCPOLY Configuration --------------------*/
;;;138    	/* Write to SPIx CRCPOLY */
;;;139    	SPI_HARD->CRCPR = 7;		/* 一般不用 */
000082  2007              MOVS     r0,#7
000084  4907              LDR      r1,|L1.164|
000086  390c              SUBS     r1,r1,#0xc
000088  8008              STRH     r0,[r1,#0]
;;;140    
;;;141    
;;;142    	SPI_Cmd(SPI_HARD, DISABLE);			/* 先禁止SPI  */
00008a  2100              MOVS     r1,#0
00008c  4805              LDR      r0,|L1.164|
00008e  381c              SUBS     r0,r0,#0x1c
000090  f7fffffe          BL       SPI_Cmd
;;;143    
;;;144    	SPI_Cmd(SPI_HARD, ENABLE);			/* 使能SPI  */
000094  2101              MOVS     r1,#1
000096  4803              LDR      r0,|L1.164|
000098  381c              SUBS     r0,r0,#0x1c
00009a  f7fffffe          BL       SPI_Cmd
;;;145    #endif
;;;146    }
00009e  bd1c              POP      {r2-r4,pc}
;;;147    
                          ENDP

                  |L1.160|
                          DCD      0x40020400
                  |L1.164|
                          DCD      0x4000381c

                          AREA ||i.bsp_SPI_Init||, CODE, READONLY, ALIGN=2

                  bsp_SPI_Init PROC
;;;156    #ifdef HARD_SPI		/* 硬件SPI */
;;;157    void bsp_SPI_Init(uint16_t _cr1)
000000  4909              LDR      r1,|L2.40|
;;;158    {
;;;159    	SPI_HARD->CR1 = ((SPI_HARD->CR1 & CR1_CLEAR_Mask) | _cr1);
000002  8809              LDRH     r1,[r1,#0]
000004  f4015141          AND      r1,r1,#0x3040
000008  4301              ORRS     r1,r1,r0
00000a  4a07              LDR      r2,|L2.40|
00000c  8011              STRH     r1,[r2,#0]
;;;160    	  
;;;161    	//SPI_Cmd(SPI_HARD, DISABLE);			/* 先禁止SPI  */	    
;;;162        SPI_HARD->CR1 &= CR1_SPE_Reset;	/* Disable the selected SPI peripheral */
00000e  4611              MOV      r1,r2
000010  8809              LDRH     r1,[r1,#0]
000012  f64f72bf          MOV      r2,#0xffbf
000016  4011              ANDS     r1,r1,r2
000018  4a03              LDR      r2,|L2.40|
00001a  8011              STRH     r1,[r2,#0]
;;;163    
;;;164    	//SPI_Cmd(SPI_HARD, ENABLE);			/* 使能SPI  */		    
;;;165        SPI_HARD->CR1 |= CR1_SPE_Set;	  /* Enable the selected SPI peripheral */
00001c  4611              MOV      r1,r2
00001e  8809              LDRH     r1,[r1,#0]
000020  f0410140          ORR      r1,r1,#0x40
000024  8011              STRH     r1,[r2,#0]
;;;166    }
000026  4770              BX       lr
;;;167    #endif
                          ENDP

                  |L2.40|
                          DCD      0x40003800

                          AREA ||i.bsp_SpiBusBusy||, CODE, READONLY, ALIGN=2

                  bsp_SpiBusBusy PROC
;;;412    */
;;;413    uint8_t bsp_SpiBusBusy(void)
000000  4801              LDR      r0,|L3.8|
;;;414    {
;;;415    	return g_spi_busy;
000002  7800              LDRB     r0,[r0,#0]  ; g_spi_busy
;;;416    }
000004  4770              BX       lr
;;;417    
                          ENDP

000006  0000              DCW      0x0000
                  |L3.8|
                          DCD      g_spi_busy

                          AREA ||i.bsp_SpiBusEnter||, CODE, READONLY, ALIGN=2

                  bsp_SpiBusEnter PROC
;;;386    */
;;;387    void bsp_SpiBusEnter(void)
000000  2001              MOVS     r0,#1
;;;388    {
;;;389    	g_spi_busy = 1;
000002  4901              LDR      r1,|L4.8|
000004  7008              STRB     r0,[r1,#0]
;;;390    }
000006  4770              BX       lr
;;;391    
                          ENDP

                  |L4.8|
                          DCD      g_spi_busy

                          AREA ||i.bsp_SpiBusExit||, CODE, READONLY, ALIGN=2

                  bsp_SpiBusExit PROC
;;;399    */
;;;400    void bsp_SpiBusExit(void)
000000  2000              MOVS     r0,#0
;;;401    {
;;;402    	g_spi_busy = 0;
000002  4901              LDR      r1,|L5.8|
000004  7008              STRB     r0,[r1,#0]
;;;403    }
000006  4770              BX       lr
;;;404    
                          ENDP

                  |L5.8|
                          DCD      g_spi_busy

                          AREA ||i.bsp_spiRead0||, CODE, READONLY, ALIGN=2

                  bsp_spiRead0 PROC
;;;241    */
;;;242    uint8_t bsp_spiRead0(void)
000000  b510              PUSH     {r4,lr}
;;;243    {
;;;244    #ifdef SOFT_SPI		/* 软件SPI */
;;;245    	uint8_t i;
;;;246    	uint8_t read = 0;
;;;247    
;;;248    	for (i = 0; i < 8; i++)
;;;249    	{
;;;250    		read = read<<1;
;;;251    
;;;252    		if (MISO_IS_HIGH())
;;;253    		{
;;;254    			read++;
;;;255    		}
;;;256    		SCK_1();
;;;257    		bsp_spiDelay();
;;;258    		SCK_0();
;;;259    		bsp_spiDelay();
;;;260    	}
;;;261    	return read;
;;;262    #endif
;;;263    
;;;264    #ifdef HARD_SPI		/* 硬件SPI */
;;;265    	uint8_t read;
;;;266    
;;;267    	/* 等待发送缓冲区空 */
;;;268    	while(SPI_I2S_GetFlagStatus(SPI_HARD, SPI_I2S_FLAG_TXE) == RESET);
000002  bf00              NOP      
                  |L6.4|
000004  2102              MOVS     r1,#2
000006  480b              LDR      r0,|L6.52|
000008  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000c  2800              CMP      r0,#0
00000e  d0f9              BEQ      |L6.4|
;;;269    
;;;270    	/* 发送一个字节 */
;;;271    	SPI_I2S_SendData(SPI_HARD, 0);
000010  2100              MOVS     r1,#0
000012  4808              LDR      r0,|L6.52|
000014  f7fffffe          BL       SPI_I2S_SendData
;;;272    
;;;273    	/* 等待数据接收完毕 */
;;;274    	while(SPI_I2S_GetFlagStatus(SPI_HARD, SPI_I2S_FLAG_RXNE) == RESET);
000018  bf00              NOP      
                  |L6.26|
00001a  2101              MOVS     r1,#1
00001c  4805              LDR      r0,|L6.52|
00001e  f7fffffe          BL       SPI_I2S_GetFlagStatus
000022  2800              CMP      r0,#0
000024  d0f9              BEQ      |L6.26|
;;;275    
;;;276    	/* 读取接收到的数据 */
;;;277    	read = SPI_I2S_ReceiveData(SPI_HARD);
000026  4803              LDR      r0,|L6.52|
000028  f7fffffe          BL       SPI_I2S_ReceiveData
00002c  b2c4              UXTB     r4,r0
;;;278    
;;;279    	/* 返回读到的数据 */
;;;280    	return read;
00002e  4620              MOV      r0,r4
;;;281    #endif
;;;282    }
000030  bd10              POP      {r4,pc}
;;;283    
                          ENDP

000032  0000              DCW      0x0000
                  |L6.52|
                          DCD      0x40003800

                          AREA ||i.bsp_spiRead1||, CODE, READONLY, ALIGN=2

                  bsp_spiRead1 PROC
;;;337    */
;;;338    uint8_t bsp_spiRead1(void)
000000  b510              PUSH     {r4,lr}
;;;339    {
;;;340    #ifdef SOFT_SPI		/* 软件SPI */
;;;341    	uint8_t i;
;;;342    	uint8_t read = 0;
;;;343    
;;;344    	for (i = 0; i < 8; i++)
;;;345    	{
;;;346    		SCK_0();
;;;347    		bsp_spiDelay();
;;;348    		read = read << 1;
;;;349    		if (MISO_IS_HIGH())
;;;350    		{
;;;351    			read++;
;;;352    		}
;;;353    		SCK_1();
;;;354    		bsp_spiDelay();
;;;355    	}
;;;356    	return read;
;;;357    #endif
;;;358    
;;;359    #ifdef HARD_SPI		/* 硬件SPI */
;;;360    	uint8_t read;
;;;361    
;;;362    	/* 等待发送缓冲区空 */
;;;363    	while(SPI_I2S_GetFlagStatus(SPI_HARD, SPI_I2S_FLAG_TXE) == RESET);
000002  bf00              NOP      
                  |L7.4|
000004  2102              MOVS     r1,#2
000006  480b              LDR      r0,|L7.52|
000008  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000c  2800              CMP      r0,#0
00000e  d0f9              BEQ      |L7.4|
;;;364    
;;;365    	/* 发送一个字节 */
;;;366    	SPI_I2S_SendData(SPI_HARD, 0);
000010  2100              MOVS     r1,#0
000012  4808              LDR      r0,|L7.52|
000014  f7fffffe          BL       SPI_I2S_SendData
;;;367    
;;;368    	/* 等待数据接收完毕 */
;;;369    	while(SPI_I2S_GetFlagStatus(SPI_HARD, SPI_I2S_FLAG_RXNE) == RESET);
000018  bf00              NOP      
                  |L7.26|
00001a  2101              MOVS     r1,#1
00001c  4805              LDR      r0,|L7.52|
00001e  f7fffffe          BL       SPI_I2S_GetFlagStatus
000022  2800              CMP      r0,#0
000024  d0f9              BEQ      |L7.26|
;;;370    
;;;371    	/* 读取接收到的数据 */
;;;372    	read = SPI_I2S_ReceiveData(SPI_HARD);
000026  4803              LDR      r0,|L7.52|
000028  f7fffffe          BL       SPI_I2S_ReceiveData
00002c  b2c4              UXTB     r4,r0
;;;373    
;;;374    	/* 返回读到的数据 */
;;;375    	return read;
00002e  4620              MOV      r0,r4
;;;376    #endif
;;;377    }
000030  bd10              POP      {r4,pc}
;;;378    
                          ENDP

000032  0000              DCW      0x0000
                  |L7.52|
                          DCD      0x40003800

                          AREA ||i.bsp_spiWrite0||, CODE, READONLY, ALIGN=2

                  bsp_spiWrite0 PROC
;;;194    */
;;;195    void bsp_spiWrite0(uint8_t _ucByte)
000000  b510              PUSH     {r4,lr}
;;;196    {
000002  4604              MOV      r4,r0
;;;197    #ifdef SOFT_SPI		/* 软件SPI */
;;;198    	uint8_t i;
;;;199    
;;;200    	for(i = 0; i < 8; i++)
;;;201    	{
;;;202    		if (_ucByte & 0x80)
;;;203    		{
;;;204    			MOSI_1();
;;;205    		}
;;;206    		else
;;;207    		{
;;;208    			MOSI_0();
;;;209    		}
;;;210    		bsp_spiDelay();
;;;211    		SCK_1();
;;;212    		_ucByte <<= 1;
;;;213    		bsp_spiDelay();
;;;214    		SCK_0();
;;;215    	}
;;;216    	bsp_spiDelay();
;;;217    #endif
;;;218    
;;;219    #ifdef HARD_SPI		/* 硬件SPI */
;;;220    	/* 等待发送缓冲区空 */
;;;221    	while(SPI_I2S_GetFlagStatus(SPI_HARD, SPI_I2S_FLAG_TXE) == RESET);
000004  bf00              NOP      
                  |L8.6|
000006  2102              MOVS     r1,#2
000008  4809              LDR      r0,|L8.48|
00000a  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L8.6|
;;;222    
;;;223    	/* 发送一个字节 */
;;;224    	SPI_I2S_SendData(SPI_HARD, _ucByte);
000012  4621              MOV      r1,r4
000014  4806              LDR      r0,|L8.48|
000016  f7fffffe          BL       SPI_I2S_SendData
;;;225    
;;;226    	/* 等待数据接收完毕 */
;;;227    	while(SPI_I2S_GetFlagStatus(SPI_HARD, SPI_I2S_FLAG_RXNE) == RESET);
00001a  bf00              NOP      
                  |L8.28|
00001c  2101              MOVS     r1,#1
00001e  4804              LDR      r0,|L8.48|
000020  f7fffffe          BL       SPI_I2S_GetFlagStatus
000024  2800              CMP      r0,#0
000026  d0f9              BEQ      |L8.28|
;;;228    
;;;229    	/* 读取接收到的数据 */
;;;230    	SPI_I2S_ReceiveData(SPI_HARD);
000028  4801              LDR      r0,|L8.48|
00002a  f7fffffe          BL       SPI_I2S_ReceiveData
;;;231    #endif
;;;232    }
00002e  bd10              POP      {r4,pc}
;;;233    
                          ENDP

                  |L8.48|
                          DCD      0x40003800

                          AREA ||i.bsp_spiWrite1||, CODE, READONLY, ALIGN=2

                  bsp_spiWrite1 PROC
;;;291    */
;;;292    void bsp_spiWrite1(uint8_t _ucByte)
000000  b510              PUSH     {r4,lr}
;;;293    {
000002  4604              MOV      r4,r0
;;;294    #ifdef SOFT_SPI		/* 软件SPI */
;;;295    	uint8_t i;
;;;296    
;;;297    	for(i = 0; i < 8; i++)
;;;298    	{
;;;299    		if (_ucByte & 0x80)
;;;300    		{
;;;301    			MOSI_1();
;;;302    		}
;;;303    		else
;;;304    		{
;;;305    			MOSI_0();
;;;306    		}
;;;307    		SCK_0();
;;;308    		_ucByte <<= 1;
;;;309    		bsp_spiDelay();
;;;310    		SCK_1();				/* SCK上升沿采集数据, SCK空闲时为高电平 */
;;;311    		bsp_spiDelay();
;;;312    	}
;;;313    #endif
;;;314    
;;;315    #ifdef HARD_SPI		/* 硬件SPI */
;;;316    	/* 等待发送缓冲区空 */
;;;317    	while(SPI_I2S_GetFlagStatus(SPI_HARD, SPI_I2S_FLAG_TXE) == RESET);
000004  bf00              NOP      
                  |L9.6|
000006  2102              MOVS     r1,#2
000008  4809              LDR      r0,|L9.48|
00000a  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L9.6|
;;;318    
;;;319    	/* 发送一个字节 */
;;;320    	SPI_I2S_SendData(SPI_HARD, _ucByte);
000012  4621              MOV      r1,r4
000014  4806              LDR      r0,|L9.48|
000016  f7fffffe          BL       SPI_I2S_SendData
;;;321    
;;;322    	/* 等待数据接收完毕 */
;;;323    	while(SPI_I2S_GetFlagStatus(SPI_HARD, SPI_I2S_FLAG_RXNE) == RESET);
00001a  bf00              NOP      
                  |L9.28|
00001c  2101              MOVS     r1,#1
00001e  4804              LDR      r0,|L9.48|
000020  f7fffffe          BL       SPI_I2S_GetFlagStatus
000024  2800              CMP      r0,#0
000026  d0f9              BEQ      |L9.28|
;;;324    
;;;325    	/* 读取接收到的数据 */
;;;326    	SPI_I2S_ReceiveData(SPI_HARD);
000028  4801              LDR      r0,|L9.48|
00002a  f7fffffe          BL       SPI_I2S_ReceiveData
;;;327    #endif
;;;328    }
00002e  bd10              POP      {r4,pc}
;;;329    
                          ENDP

                  |L9.48|
                          DCD      0x40003800

                          AREA ||.data||, DATA, ALIGN=0

                  g_spi_busy
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\src\\bsp_spi_bus.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_spi_bus_c_c88bcf96____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_bsp_spi_bus_c_c88bcf96____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_spi_bus_c_c88bcf96____REVSH|
#line 144
|__asm___13_bsp_spi_bus_c_c88bcf96____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
