; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\flash\obj\chip_bus.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\chip_bus.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\User -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\User\FatFS\src -I..\..\Libraries\STM32_USB_Device_Library\Class\msc\inc -I..\..\Libraries\STM32_USB_Device_Library\Core\inc -I..\..\Libraries\STM32_USB_OTG_Driver\inc -I..\..\User\usbd_mass_storage -I..\..\User\ft_support -I..\..\User\test -I..\..\User\emenu -I..\..\User\chip_ft -I..\..\User\lwrb -I..\..\User\easylogger\inc -I..\..\User\easylogger\plugins\file -I..\..\User\LOG -I..\..\User\MultiButton-1.1.0 -I..\..\User\cm_backtrace -I..\..\User\MultiTimer -I.\RTE\_Flash -IC:\Users\qizha\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\qizha\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.17.1\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F407xx -D_RTE_ -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY --signed_chars --omf_browse=.\flash\obj\chip_bus.crf ..\..\User\chip_ft\chip_bus.c]
                          THUMB

                          AREA ||i.apple_CheckOk||, CODE, READONLY, ALIGN=1

                  apple_CheckOk PROC
;;;2       
;;;3      uint8_t apple_CheckOk(void)
000000  b510              PUSH     {r4,lr}
;;;4      {
;;;5      	if (asu_CheckDevice(APPLE_DEV_ADDR) == 0)
000002  2060              MOVS     r0,#0x60
000004  f7fffffe          BL       asu_CheckDevice
000008  b908              CBNZ     r0,|L1.14|
;;;6      	{
;;;7      		return 1;
00000a  2001              MOVS     r0,#1
                  |L1.12|
;;;8      	}
;;;9      	else
;;;10     	{
;;;11     		/* 失败后，切记发送I2C总线停止信号 */
;;;12     		asu_Stop();
;;;13     		return 0;
;;;14     	}
;;;15     }
00000c  bd10              POP      {r4,pc}
                  |L1.14|
00000e  f7fffffe          BL       asu_Stop
000012  2000              MOVS     r0,#0                 ;13
000014  e7fa              B        |L1.12|
;;;16     
                          ENDP


                          AREA ||i.apple_read_addr16||, CODE, READONLY, ALIGN=1

                  apple_read_addr16 PROC
;;;16     
;;;17     fsm_rt_t apple_read_addr16(uint8_t DevAddr,uint8_t *ReadData,uint16_t RegAddr,uint16_t length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;18     {
000004  4605              MOV      r5,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;19     	uint16_t num = 0x00;
00000c  2400              MOVS     r4,#0
;;;20     	
;;;21     	asu_Start();
00000e  f7fffffe          BL       asu_Start
;;;22     	asu_SendByte((DevAddr<<1)+ ASU_WR);	//设备地址 + 写
000012  2100              MOVS     r1,#0
000014  eb010145          ADD      r1,r1,r5,LSL #1
000018  b2c8              UXTB     r0,r1
00001a  f7fffffe          BL       asu_SendByte
;;;23     	if(asu_WaitAck())
00001e  f7fffffe          BL       asu_WaitAck
000022  b118              CBZ      r0,|L2.44|
;;;24     	{
;;;25     		return fsm_rt_err_asu_NoAck;
000024  f06f0054          MVN      r0,#0x54
                  |L2.40|
;;;26     	}
;;;27     	asu_SendByte((uint8_t)(RegAddr));	//寄存器地址低字节
;;;28     	asu_WaitAck();					
;;;29     	asu_SendByte((uint8_t)(RegAddr>>8));	//寄存器地址高字节
;;;30     	asu_WaitAck();					
;;;31     	asu_Stop();		
;;;32     	
;;;33     	asu_Start();
;;;34     	asu_SendByte((DevAddr<<1)+ASU_RD);	//设备地址+读
;;;35     	asu_WaitAck();	
;;;36     	for(num = 0;num<length;num++)
;;;37     	{
;;;38     		ReadData[num] = asu_ReadByte();
;;;39     		if (num < (length -1)){asu_Ack();}			
;;;40     		else{asu_NAck();}	//最后一个读数据，主机不反回ACK						
;;;41     	}
;;;42     	asu_Stop();	
;;;43     	
;;;44     	return fsm_rt_cpl;
;;;45     }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L2.44|
00002c  b2f0              UXTB     r0,r6                 ;27
00002e  f7fffffe          BL       asu_SendByte
000032  f7fffffe          BL       asu_WaitAck
000036  1230              ASRS     r0,r6,#8              ;29
000038  f7fffffe          BL       asu_SendByte
00003c  f7fffffe          BL       asu_WaitAck
000040  f7fffffe          BL       asu_Stop
000044  f7fffffe          BL       asu_Start
000048  2101              MOVS     r1,#1                 ;34
00004a  eb010145          ADD      r1,r1,r5,LSL #1       ;34
00004e  b2c8              UXTB     r0,r1                 ;34
000050  f7fffffe          BL       asu_SendByte
000054  f7fffffe          BL       asu_WaitAck
000058  2400              MOVS     r4,#0                 ;36
00005a  e00d              B        |L2.120|
                  |L2.92|
00005c  f7fffffe          BL       asu_ReadByte
000060  f8080004          STRB     r0,[r8,r4]            ;38
000064  1e78              SUBS     r0,r7,#1              ;39
000066  42a0              CMP      r0,r4                 ;39
000068  dd02              BLE      |L2.112|
00006a  f7fffffe          BL       asu_Ack
00006e  e001              B        |L2.116|
                  |L2.112|
000070  f7fffffe          BL       asu_NAck
                  |L2.116|
000074  1c60              ADDS     r0,r4,#1              ;36
000076  b284              UXTH     r4,r0                 ;36
                  |L2.120|
000078  42bc              CMP      r4,r7                 ;36
00007a  dbef              BLT      |L2.92|
00007c  f7fffffe          BL       asu_Stop
000080  2000              MOVS     r0,#0                 ;44
000082  e7d1              B        |L2.40|
;;;46     
                          ENDP


                          AREA ||i.apple_read_addr8||, CODE, READONLY, ALIGN=1

                  apple_read_addr8 PROC
;;;46     
;;;47     fsm_rt_t apple_read_addr8(uint8_t DevAddr,uint8_t *ReadData,uint8_t RegAddr,uint16_t length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;48     {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  461e              MOV      r6,r3
;;;49     	uint16_t num = 0x00;
00000c  2400              MOVS     r4,#0
;;;50     	
;;;51     	asu_Start();
00000e  f7fffffe          BL       asu_Start
;;;52     	asu_SendByte((DevAddr<<1)+ ASU_WR);	//设备地址 + 写
000012  2100              MOVS     r1,#0
000014  eb010145          ADD      r1,r1,r5,LSL #1
000018  b2c8              UXTB     r0,r1
00001a  f7fffffe          BL       asu_SendByte
;;;53     	if(asu_WaitAck())
00001e  f7fffffe          BL       asu_WaitAck
000022  b118              CBZ      r0,|L3.44|
;;;54     	{
;;;55     		return fsm_rt_err_asu_NoAck;
000024  f06f0054          MVN      r0,#0x54
                  |L3.40|
;;;56     	}
;;;57     	asu_SendByte(RegAddr);	//寄存器地址低字节
;;;58     	asu_WaitAck();					
;;;59     	 		
;;;60     	asu_Stop();		
;;;61     	
;;;62     	asu_Start();
;;;63     	asu_SendByte((DevAddr<<1)+ASU_RD);	//设备地址+读
;;;64     	asu_WaitAck();	
;;;65     	for(num = 0;num<length;num++)
;;;66     	{
;;;67     		ReadData[num] = asu_ReadByte();
;;;68     		if (num < (length -1)){asu_Ack();}			
;;;69     		else{asu_NAck();}	//最后一个读数据，主机不反回ACK						
;;;70     	}
;;;71     	asu_Stop();	
;;;72     	
;;;73     	return fsm_rt_cpl;
;;;74     }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L3.44|
00002c  4640              MOV      r0,r8                 ;57
00002e  f7fffffe          BL       asu_SendByte
000032  f7fffffe          BL       asu_WaitAck
000036  f7fffffe          BL       asu_Stop
00003a  f7fffffe          BL       asu_Start
00003e  2101              MOVS     r1,#1                 ;63
000040  eb010145          ADD      r1,r1,r5,LSL #1       ;63
000044  b2c8              UXTB     r0,r1                 ;63
000046  f7fffffe          BL       asu_SendByte
00004a  f7fffffe          BL       asu_WaitAck
00004e  2400              MOVS     r4,#0                 ;65
000050  e00c              B        |L3.108|
                  |L3.82|
000052  f7fffffe          BL       asu_ReadByte
000056  5538              STRB     r0,[r7,r4]            ;67
000058  1e70              SUBS     r0,r6,#1              ;68
00005a  42a0              CMP      r0,r4                 ;68
00005c  dd02              BLE      |L3.100|
00005e  f7fffffe          BL       asu_Ack
000062  e001              B        |L3.104|
                  |L3.100|
000064  f7fffffe          BL       asu_NAck
                  |L3.104|
000068  1c60              ADDS     r0,r4,#1              ;65
00006a  b284              UXTH     r4,r0                 ;65
                  |L3.108|
00006c  42b4              CMP      r4,r6                 ;65
00006e  dbf0              BLT      |L3.82|
000070  f7fffffe          BL       asu_Stop
000074  2000              MOVS     r0,#0                 ;73
000076  e7d7              B        |L3.40|
;;;75     
                          ENDP


                          AREA ||i.apple_write_addr16||, CODE, READONLY, ALIGN=1

                  apple_write_addr16 PROC
;;;100    
;;;101    fsm_rt_t apple_write_addr16(uint8_t DevAddr,uint8_t *WriteData,uint16_t RegAddr,uint16_t length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;102    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  4698              MOV      r8,r3
;;;103    	uint16_t num = 0x00;
00000c  2500              MOVS     r5,#0
;;;104    	
;;;105    	asu_Start();
00000e  f7fffffe          BL       asu_Start
;;;106    	asu_SendByte((DevAddr<<1)+ ASU_WR);	//设备地址 + 写
000012  2100              MOVS     r1,#0
000014  eb010146          ADD      r1,r1,r6,LSL #1
000018  b2c8              UXTB     r0,r1
00001a  f7fffffe          BL       asu_SendByte
;;;107    	if(asu_WaitAck())
00001e  f7fffffe          BL       asu_WaitAck
000022  b118              CBZ      r0,|L4.44|
;;;108    	{
;;;109    		return fsm_rt_err_asu_NoAck;
000024  f06f0054          MVN      r0,#0x54
                  |L4.40|
;;;110    	}
;;;111    	asu_SendByte(RegAddr);	//寄存器地址低字节
;;;112        asu_WaitAck();
;;;113        asu_SendByte((RegAddr>>8));	//寄存器地址低字节
;;;114    	asu_WaitAck();					
;;;115    	 		
;;;116    	
;;;117    	for(num = 0;num<length;num++)
;;;118    	{
;;;119    		asu_SendByte(WriteData[num]);
;;;120    		asu_WaitAck();					
;;;121    	}
;;;122    	asu_Stop();	
;;;123    	
;;;124    	return fsm_rt_cpl;
;;;125    }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L4.44|
00002c  b2e0              UXTB     r0,r4                 ;111
00002e  f7fffffe          BL       asu_SendByte
000032  f7fffffe          BL       asu_WaitAck
000036  1220              ASRS     r0,r4,#8              ;113
000038  f7fffffe          BL       asu_SendByte
00003c  f7fffffe          BL       asu_WaitAck
000040  2500              MOVS     r5,#0                 ;117
000042  e006              B        |L4.82|
                  |L4.68|
000044  5d78              LDRB     r0,[r7,r5]            ;119
000046  f7fffffe          BL       asu_SendByte
00004a  f7fffffe          BL       asu_WaitAck
00004e  1c68              ADDS     r0,r5,#1              ;117
000050  b285              UXTH     r5,r0                 ;117
                  |L4.82|
000052  4545              CMP      r5,r8                 ;117
000054  dbf6              BLT      |L4.68|
000056  f7fffffe          BL       asu_Stop
00005a  2000              MOVS     r0,#0                 ;124
00005c  e7e4              B        |L4.40|
                          ENDP


                          AREA ||i.apple_write_addr8||, CODE, READONLY, ALIGN=1

                  apple_write_addr8 PROC
;;;75     
;;;76     fsm_rt_t apple_write_addr8(uint8_t DevAddr,uint8_t *WriteData,uint8_t RegAddr,uint16_t length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;77     {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;78     	uint16_t num = 0x00;
00000c  2400              MOVS     r4,#0
;;;79     	
;;;80     	asu_Start();
00000e  f7fffffe          BL       asu_Start
;;;81     	asu_SendByte((DevAddr<<1)+ ASU_WR);	//设备地址 + 写
000012  2100              MOVS     r1,#0
000014  eb010145          ADD      r1,r1,r5,LSL #1
000018  b2c8              UXTB     r0,r1
00001a  f7fffffe          BL       asu_SendByte
;;;82     	if(asu_WaitAck())
00001e  f7fffffe          BL       asu_WaitAck
000022  b118              CBZ      r0,|L5.44|
;;;83     	{
;;;84     		return fsm_rt_err_asu_NoAck;
000024  f06f0054          MVN      r0,#0x54
                  |L5.40|
;;;85     	}
;;;86     	asu_SendByte(RegAddr);	//寄存器地址低字节
;;;87     	asu_WaitAck();					
;;;88     	 		
;;;89     	 
;;;90     	for(num = 0;num<length;num++)
;;;91     	{
;;;92     		asu_SendByte(WriteData[num]);
;;;93     		asu_WaitAck();					
;;;94     	}
;;;95     	asu_Stop();	
;;;96     	
;;;97     	return fsm_rt_cpl;
;;;98     }
000028  e8bd81f0          POP      {r4-r8,pc}
                  |L5.44|
00002c  4638              MOV      r0,r7                 ;86
00002e  f7fffffe          BL       asu_SendByte
000032  f7fffffe          BL       asu_WaitAck
000036  2400              MOVS     r4,#0                 ;90
000038  e006              B        |L5.72|
                  |L5.58|
00003a  5d30              LDRB     r0,[r6,r4]            ;92
00003c  f7fffffe          BL       asu_SendByte
000040  f7fffffe          BL       asu_WaitAck
000044  1c60              ADDS     r0,r4,#1              ;90
000046  b284              UXTH     r4,r0                 ;90
                  |L5.72|
000048  4544              CMP      r4,r8                 ;90
00004a  dbf6              BLT      |L5.58|
00004c  f7fffffe          BL       asu_Stop
000050  2000              MOVS     r0,#0                 ;97
000052  e7e9              B        |L5.40|
;;;99     
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\User\\chip_ft\\chip_bus.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_chip_bus_c_5756daf9____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_chip_bus_c_5756daf9____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_chip_bus_c_5756daf9____REVSH|
#line 144
|__asm___10_chip_bus_c_5756daf9____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
