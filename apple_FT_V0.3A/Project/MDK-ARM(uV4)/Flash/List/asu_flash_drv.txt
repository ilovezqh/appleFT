; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\flash\obj\asu_flash_drv.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\asu_flash_drv.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\User -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\User\FatFS\src -I..\..\Libraries\STM32_USB_Device_Library\Class\msc\inc -I..\..\Libraries\STM32_USB_Device_Library\Core\inc -I..\..\Libraries\STM32_USB_OTG_Driver\inc -I..\..\User\usbd_mass_storage -I..\..\User\BERRY_TWI -I..\..\User\berry_ft -I..\..\User\ft_support -I..\..\User\berry_test -I..\..\User\factory_test -I..\..\User\emenu -I..\..\User\kiwi_ft -I..\..\User\kiwi_ft\spv40 -I..\..\User\kiwi_ft\spv40\peripheral -I..\..\User\lwrb -I..\..\User\easylogger\inc -I..\..\User\easylogger\plugins\file -I..\..\User\LOG -I..\..\User\kiwi_ft -I.\RTE\_Flash -IC:\Users\qizha\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\qizha\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.16.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F407xx -D_RTE_ -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY --signed_chars --omf_browse=.\flash\obj\asu_flash_drv.crf ..\..\User\kiwi_ft\asu_flash_drv.c]
                          THUMB

                          AREA ||i.asu_flashAutoWritePage||, CODE, READONLY, ALIGN=2

                  asu_flashAutoWritePage PROC
;;;326    */
;;;327    static uint8_t asu_flashAutoWritePage(uint8_t *_ucpSrc, uint32_t _uiWrAddr, uint16_t _usWrLen)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;328    {
000004  b081              SUB      sp,sp,#4
000006  f5ad5d80          SUB      sp,sp,#0x1000
00000a  4607              MOV      r7,r0
00000c  460d              MOV      r5,r1
00000e  4616              MOV      r6,r2
;;;329    	uint16_t i;
;;;330    	uint16_t j;					/* 用于延时 */
;;;331    	uint32_t uiFirstAddr;		/* 扇区首址 */
;;;332    	uint8_t ucNeedErase;		/* 1表示需要擦除 */
;;;333    	uint8_t cRet;
;;;334    	uint8_t s_spiBuf[4*1024];	/* 用于写函数，先读出整个page，修改缓冲区后，再整个page回写 */	
;;;335    
;;;336    	/* 长度为0时不继续操作,直接认为成功 */
;;;337    	if (_usWrLen == 0)
000010  b92e              CBNZ     r6,|L1.30|
;;;338    	{
;;;339    		return 1;
000012  2001              MOVS     r0,#1
                  |L1.20|
;;;340    	}
;;;341    
;;;342    	/* 如果偏移地址超过芯片容量则退出 */
;;;343    	if (_uiWrAddr >= g_tOrange_Flash.TotalSize)
;;;344    	{
;;;345    		return 0;
;;;346    	}
;;;347    
;;;348    	/* 如果数据长度大于扇区容量，则退出 */
;;;349    	if (_usWrLen > g_tOrange_Flash.SectorSize)
;;;350    	{
;;;351    		return 0;
;;;352    	}
;;;353    
;;;354    	/* 如果FLASH中的数据没有变化,则不写FLASH */
;;;355    	asu_flashReadBuffer(s_spiBuf, _uiWrAddr, _usWrLen);
;;;356    	if (memcmp(s_spiBuf, _ucpSrc, _usWrLen) == 0)
;;;357    	{
;;;358    		return 1;
;;;359    	}
;;;360    
;;;361    	/* 判断是否需要先擦除扇区 */
;;;362    	/* 如果旧数据修改为新数据，所有位均是 1->1, 1->0 或者 0->0, 则无需擦除,提高Flash寿命 ；0->1则需要擦除*/
;;;363    	ucNeedErase = 0;
;;;364    	if (asu_flashNeedErase(s_spiBuf, _ucpSrc, _usWrLen))
;;;365    	{
;;;366    		ucNeedErase = 1;
;;;367    	}
;;;368    
;;;369    	uiFirstAddr = _uiWrAddr & (~(g_tOrange_Flash.SectorSize - 1)); //uiFirstAddr，为_uiWrAdd地址所在的sector
;;;370        
;;;371    	if (_usWrLen == g_tOrange_Flash.SectorSize)		/* 整个扇区都改写 */
;;;372    	{
;;;373    		for	(i = 0; i < g_tOrange_Flash.SectorSize; i++)
;;;374    		{
;;;375    			s_spiBuf[i] = _ucpSrc[i];
;;;376    		}
;;;377    	}
;;;378    	else						/* 改写部分数据 */
;;;379    	{
;;;380    		/* 先将整个扇区的数据读出 */
;;;381    		asu_flashReadBuffer(s_spiBuf, uiFirstAddr, g_tOrange_Flash.SectorSize);
;;;382    
;;;383    		/* 再用新数据覆盖 */
;;;384    		i = _uiWrAddr & (g_tOrange_Flash.SectorSize - 1);
;;;385    		memcpy(&s_spiBuf[i], _ucpSrc, _usWrLen);
;;;386    	}
;;;387    
;;;388    	/* 写完之后进行校验，如果不正确则重写，最多3次 */
;;;389    	cRet = 0;
;;;390    	for (i = 0; i < 3; i++)
;;;391    	{
;;;392    
;;;393    		/* 如果旧数据修改为新数据，所有位均是 1->0 或者 0->0, 则无需擦除,提高Flash寿命 */
;;;394    		if (ucNeedErase == 1)
;;;395    		{
;;;396    			asu_flashEraseSector(uiFirstAddr);		/* 擦除1个扇区 */
;;;397    		}
;;;398    
;;;399    		/* 编程一个PAGE */
;;;400    		asu_flashPageWrite(s_spiBuf, uiFirstAddr, g_tOrange_Flash.SectorSize);
;;;401    
;;;402    		if (asu_flashCmpData(_uiWrAddr, _ucpSrc, _usWrLen) == 0)
;;;403    		{
;;;404    			cRet = 1;
;;;405    			break;
;;;406    		}
;;;407    		else
;;;408    		{
;;;409    			if (asu_flashCmpData(_uiWrAddr, _ucpSrc, _usWrLen) == 0)
;;;410    			{
;;;411    				cRet = 1;
;;;412    				break;
;;;413    			}
;;;414    
;;;415    			/* 失败后延迟一段时间再重试 */
;;;416    			for (j = 0; j < 10000; j++);
;;;417    		}
;;;418    	}
;;;419    
;;;420    	return cRet;
;;;421    }
000014  b001              ADD      sp,sp,#4
000016  f50d5d80          ADD      sp,sp,#0x1000
00001a  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.30|
00001e  483e              LDR      r0,|L1.280|
000020  6940              LDR      r0,[r0,#0x14]         ;343  ; g_tOrange_Flash
000022  42a8              CMP      r0,r5                 ;343
000024  d801              BHI      |L1.42|
000026  2000              MOVS     r0,#0                 ;345
000028  e7f4              B        |L1.20|
                  |L1.42|
00002a  483b              LDR      r0,|L1.280|
00002c  8b00              LDRH     r0,[r0,#0x18]         ;349  ; g_tOrange_Flash
00002e  42b0              CMP      r0,r6                 ;349
000030  da01              BGE      |L1.54|
000032  2000              MOVS     r0,#0                 ;351
000034  e7ee              B        |L1.20|
                  |L1.54|
000036  4632              MOV      r2,r6                 ;355
000038  4629              MOV      r1,r5                 ;355
00003a  a801              ADD      r0,sp,#4              ;355
00003c  f7fffffe          BL       asu_flashReadBuffer
000040  4632              MOV      r2,r6                 ;356
000042  4639              MOV      r1,r7                 ;356
000044  a801              ADD      r0,sp,#4              ;356
000046  f7fffffe          BL       memcmp
00004a  b908              CBNZ     r0,|L1.80|
00004c  2001              MOVS     r0,#1                 ;358
00004e  e7e1              B        |L1.20|
                  |L1.80|
000050  f04f0a00          MOV      r10,#0                ;363
000054  4632              MOV      r2,r6                 ;364
000056  4639              MOV      r1,r7                 ;364
000058  a801              ADD      r0,sp,#4              ;364
00005a  f7fffffe          BL       asu_flashNeedErase
00005e  b108              CBZ      r0,|L1.100|
000060  f04f0a01          MOV      r10,#1                ;366
                  |L1.100|
000064  482c              LDR      r0,|L1.280|
000066  8b00              LDRH     r0,[r0,#0x18]         ;369  ; g_tOrange_Flash
000068  1e40              SUBS     r0,r0,#1              ;369
00006a  ea250800          BIC      r8,r5,r0              ;369
00006e  482a              LDR      r0,|L1.280|
000070  8b00              LDRH     r0,[r0,#0x18]         ;371  ; g_tOrange_Flash
000072  42b0              CMP      r0,r6                 ;371
000074  d10b              BNE      |L1.142|
000076  2400              MOVS     r4,#0                 ;373
000078  e004              B        |L1.132|
                  |L1.122|
00007a  5d38              LDRB     r0,[r7,r4]            ;375
00007c  a901              ADD      r1,sp,#4              ;375
00007e  5508              STRB     r0,[r1,r4]            ;375
000080  1c60              ADDS     r0,r4,#1              ;373
000082  b284              UXTH     r4,r0                 ;373
                  |L1.132|
000084  4824              LDR      r0,|L1.280|
000086  8b00              LDRH     r0,[r0,#0x18]         ;373  ; g_tOrange_Flash
000088  42a0              CMP      r0,r4                 ;373
00008a  dcf6              BGT      |L1.122|
00008c  e010              B        |L1.176|
                  |L1.142|
00008e  4822              LDR      r0,|L1.280|
000090  8b02              LDRH     r2,[r0,#0x18]         ;381  ; g_tOrange_Flash
000092  4641              MOV      r1,r8                 ;381
000094  a801              ADD      r0,sp,#4              ;381
000096  f7fffffe          BL       asu_flashReadBuffer
00009a  481f              LDR      r0,|L1.280|
00009c  8b00              LDRH     r0,[r0,#0x18]         ;384  ; g_tOrange_Flash
00009e  1e40              SUBS     r0,r0,#1              ;384
0000a0  4028              ANDS     r0,r0,r5              ;384
0000a2  b284              UXTH     r4,r0                 ;384
0000a4  a901              ADD      r1,sp,#4              ;385
0000a6  1908              ADDS     r0,r1,r4              ;385
0000a8  4632              MOV      r2,r6                 ;385
0000aa  4639              MOV      r1,r7                 ;385
0000ac  f7fffffe          BL       __aeabi_memcpy
                  |L1.176|
0000b0  f04f0b00          MOV      r11,#0                ;389
0000b4  2400              MOVS     r4,#0                 ;390
0000b6  e02a              B        |L1.270|
                  |L1.184|
0000b8  f1ba0f01          CMP      r10,#1                ;394
0000bc  d102              BNE      |L1.196|
0000be  4640              MOV      r0,r8                 ;396
0000c0  f7fffffe          BL       asu_flashEraseSector
                  |L1.196|
0000c4  4814              LDR      r0,|L1.280|
0000c6  8b02              LDRH     r2,[r0,#0x18]         ;400  ; g_tOrange_Flash
0000c8  4641              MOV      r1,r8                 ;400
0000ca  a801              ADD      r0,sp,#4              ;400
0000cc  f7fffffe          BL       asu_flashPageWrite
0000d0  4632              MOV      r2,r6                 ;402
0000d2  4639              MOV      r1,r7                 ;402
0000d4  4628              MOV      r0,r5                 ;402
0000d6  f7fffffe          BL       asu_flashCmpData
0000da  b910              CBNZ     r0,|L1.226|
0000dc  f04f0b01          MOV      r11,#1                ;404
0000e0  e017              B        |L1.274|
                  |L1.226|
0000e2  4632              MOV      r2,r6                 ;409
0000e4  4639              MOV      r1,r7                 ;409
0000e6  4628              MOV      r0,r5                 ;409
0000e8  f7fffffe          BL       asu_flashCmpData
0000ec  b910              CBNZ     r0,|L1.244|
0000ee  f04f0b01          MOV      r11,#1                ;411
0000f2  e00e              B        |L1.274|
                  |L1.244|
0000f4  f04f0900          MOV      r9,#0                 ;416
0000f8  e003              B        |L1.258|
                  |L1.250|
0000fa  f1090001          ADD      r0,r9,#1              ;416
0000fe  fa1ff980          UXTH     r9,r0                 ;416
                  |L1.258|
000102  f2427010          MOV      r0,#0x2710            ;416
000106  4581              CMP      r9,r0                 ;416
000108  dbf7              BLT      |L1.250|
00010a  1c60              ADDS     r0,r4,#1              ;390
00010c  b284              UXTH     r4,r0                 ;390
                  |L1.270|
00010e  2c03              CMP      r4,#3                 ;390
000110  dbd2              BLT      |L1.184|
                  |L1.274|
000112  bf00              NOP                            ;405
000114  4658              MOV      r0,r11                ;420
000116  e77d              B        |L1.20|
;;;422    
                          ENDP

                  |L1.280|
                          DCD      g_tOrange_Flash

                          AREA ||i.asu_flashCmpData||, CODE, READONLY, ALIGN=2

                  asu_flashCmpData PROC
;;;238    */
;;;239    static uint8_t asu_flashCmpData(uint32_t _uiSrcAddr, uint8_t *_ucpTar, uint32_t _uiSize)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;240    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;241    	uint8_t ucValue;
;;;242    
;;;243    	/* 如果读取的数据长度为0或者超出串行Flash地址空间，则直接返回 */
;;;244    	if ((_uiSrcAddr + _uiSize) > g_tOrange_Flash.TotalSize)
00000a  1960              ADDS     r0,r4,r5
00000c  4918              LDR      r1,|L2.112|
00000e  6949              LDR      r1,[r1,#0x14]  ; g_tOrange_Flash
000010  4288              CMP      r0,r1
000012  d902              BLS      |L2.26|
;;;245    	{
;;;246    		return 1;
000014  2001              MOVS     r0,#1
                  |L2.22|
;;;247    	}
;;;248    
;;;249    	if (_uiSize == 0)
;;;250    	{
;;;251    		return 0;
;;;252    	}
;;;253    
;;;254    	asu_flashSetCS(0);									/* 使能片选 */
;;;255    	asu_spi_write(CMD_READ_DATA);							/* 发送读命令 */
;;;256    	asu_spi_write((_uiSrcAddr & 0xFF0000) >> 16);		/* 发送扇区地址的高8bit */
;;;257    	asu_spi_write((_uiSrcAddr & 0xFF00) >> 8);		/* 发送扇区地址中间8bit */
;;;258    	asu_spi_write(_uiSrcAddr & 0xFF);					/* 发送扇区地址低8bit */
;;;259    	while (_uiSize--)
;;;260    	{
;;;261    		/* 读一个字节 */
;;;262    		ucValue = asu_spi_read();
;;;263    		if (*_ucpTar++ != ucValue)
;;;264    		{
;;;265    			asu_flashSetCS(1);
;;;266    			return 1;
;;;267    		}
;;;268    	}
;;;269    	asu_flashSetCS(1);
;;;270    	return 0;
;;;271    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L2.26|
00001a  b90d              CBNZ     r5,|L2.32|
00001c  2000              MOVS     r0,#0                 ;251
00001e  e7fa              B        |L2.22|
                  |L2.32|
000020  2000              MOVS     r0,#0                 ;254
000022  f7fffffe          BL       asu_flashSetCS
000026  2003              MOVS     r0,#3                 ;255
000028  f7fffffe          BL       bsp_spiWrite0_ASU
00002c  f3c44007          UBFX     r0,r4,#16,#8          ;256
000030  f7fffffe          BL       bsp_spiWrite0_ASU
000034  f3c42007          UBFX     r0,r4,#8,#8           ;257
000038  f7fffffe          BL       bsp_spiWrite0_ASU
00003c  b2e0              UXTB     r0,r4                 ;258
00003e  f7fffffe          BL       bsp_spiWrite0_ASU
000042  e00b              B        |L2.92|
                  |L2.68|
000044  f7fffffe          BL       bsp_spiRead0_ASU
000048  4607              MOV      r7,r0                 ;262
00004a  f8161b01          LDRB     r1,[r6],#1            ;263
00004e  42b9              CMP      r1,r7                 ;263
000050  d004              BEQ      |L2.92|
000052  2001              MOVS     r0,#1                 ;265
000054  f7fffffe          BL       asu_flashSetCS
000058  2001              MOVS     r0,#1                 ;266
00005a  e7dc              B        |L2.22|
                  |L2.92|
00005c  1e28              SUBS     r0,r5,#0              ;259
00005e  f1a50501          SUB      r5,r5,#1              ;259
000062  d1ef              BNE      |L2.68|
000064  2001              MOVS     r0,#1                 ;269
000066  f7fffffe          BL       asu_flashSetCS
00006a  2000              MOVS     r0,#0                 ;270
00006c  e7d3              B        |L2.22|
;;;272    
                          ENDP

00006e  0000              DCW      0x0000
                  |L2.112|
                          DCD      g_tOrange_Flash

                          AREA ||i.asu_flashEraseChip||, CODE, READONLY, ALIGN=1

                  asu_flashEraseChip PROC
;;;140    */
;;;141    void asu_flashEraseChip(void)
000000  b510              PUSH     {r4,lr}
;;;142    {
;;;143    	asu_flashWriteEnable();								/* 发送写使能命令 */
000002  f7fffffe          BL       asu_flashWriteEnable
;;;144    
;;;145    	/* 擦除扇区操作 */
;;;146    	asu_flashSetCS(0);									/* 使能片选 */
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       asu_flashSetCS
;;;147    	asu_spi_write(CMD_BLOCK_ERASE);						/* 发送整片擦除命令 */
00000c  20c7              MOVS     r0,#0xc7
00000e  f7fffffe          BL       bsp_spiWrite0_ASU
;;;148    	asu_flashSetCS(1);									/* 禁能片选 */
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       asu_flashSetCS
;;;149    
;;;150    	asu_flashWaitForWriteEnd();							/* 等待串行Flash内部写操作完成 */
000018  f7fffffe          BL       asu_flashWaitForWriteEnd
;;;151    }
00001c  bd10              POP      {r4,pc}
;;;152    
                          ENDP


                          AREA ||i.asu_flashEraseSector||, CODE, READONLY, ALIGN=1

                  asu_flashEraseSector PROC
;;;117    */
;;;118    void asu_flashEraseSector(uint32_t _uiSectorAddr)
000000  b510              PUSH     {r4,lr}
;;;119    {
000002  4604              MOV      r4,r0
;;;120    	asu_flashWriteEnable();								/* 发送写使能命令 */
000004  f7fffffe          BL       asu_flashWriteEnable
;;;121    
;;;122    	/* 擦除扇区操作 */
;;;123    	asu_flashSetCS(0);									/* 使能片选 */
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       asu_flashSetCS
;;;124    	asu_spi_write(CMD_SECTOR_ERASE);								/* 发送擦除命令 */
00000e  2020              MOVS     r0,#0x20
000010  f7fffffe          BL       bsp_spiWrite0_ASU
;;;125    	asu_spi_write((_uiSectorAddr & 0xFF0000) >> 16);	/* 发送扇区地址的高8bit */
000014  f3c44007          UBFX     r0,r4,#16,#8
000018  f7fffffe          BL       bsp_spiWrite0_ASU
;;;126    	asu_spi_write((_uiSectorAddr & 0xFF00) >> 8);		/* 发送扇区地址中间8bit */
00001c  f3c42007          UBFX     r0,r4,#8,#8
000020  f7fffffe          BL       bsp_spiWrite0_ASU
;;;127    	asu_spi_write(_uiSectorAddr & 0xFF);				/* 发送扇区地址低8bit */
000024  b2e0              UXTB     r0,r4
000026  f7fffffe          BL       bsp_spiWrite0_ASU
;;;128    	asu_flashSetCS(1);									/* 禁能片选 */
00002a  2001              MOVS     r0,#1
00002c  f7fffffe          BL       asu_flashSetCS
;;;129    
;;;130    	asu_flashWaitForWriteEnd();							/* 等待串行Flash内部写操作完成 */
000030  f7fffffe          BL       asu_flashWaitForWriteEnd
;;;131    }
000034  bd10              POP      {r4,pc}
;;;132    
                          ENDP


                          AREA ||i.asu_flashNeedErase||, CODE, READONLY, ALIGN=1

                  asu_flashNeedErase PROC
;;;282    */
;;;283    static uint8_t asu_flashNeedErase(uint8_t * _ucpOldBuf, uint8_t *_ucpNewBuf, uint16_t _usLen)
000000  b570              PUSH     {r4-r6,lr}
;;;284    {
000002  4603              MOV      r3,r0
;;;285    	uint16_t i;
;;;286    	uint8_t ucOld;
;;;287    
;;;288    	/*
;;;289    	算法第1步：old 求反, new 不变
;;;290    	      old    new
;;;291    		  1101   0101
;;;292    	~     1111
;;;293    		= 0010   0101
;;;294    
;;;295    	算法第2步: old 求反的结果与 new 位与
;;;296    		  0010   old
;;;297    	&	  0101   new
;;;298    		 =0000
;;;299    
;;;300    	算法第3步: 结果为0,则表示无需擦除. 否则表示需要擦除
;;;301    	*/
;;;302    
;;;303    	for (i = 0; i < _usLen; i++)
000004  2400              MOVS     r4,#0
000006  e00b              B        |L5.32|
                  |L5.8|
;;;304    	{
;;;305    		ucOld = *_ucpOldBuf++;
000008  f8135b01          LDRB     r5,[r3],#1
;;;306    		ucOld = ~ucOld;
00000c  43e8              MVNS     r0,r5
00000e  b2c5              UXTB     r5,r0
;;;307    
;;;308    		/* 注意错误的写法: if (ucOld & (*_ucpNewBuf++) != 0) */
;;;309    		if ((ucOld & (*_ucpNewBuf++)) != 0)  //bit 从0 改写为1 则需要擦除操作
000010  f8110b01          LDRB     r0,[r1],#1
000014  4028              ANDS     r0,r0,r5
000016  b108              CBZ      r0,|L5.28|
;;;310    		{
;;;311    			return 1;
000018  2001              MOVS     r0,#1
                  |L5.26|
;;;312    		}
;;;313    	}
;;;314    	return 0;
;;;315    }
00001a  bd70              POP      {r4-r6,pc}
                  |L5.28|
00001c  1c60              ADDS     r0,r4,#1              ;303
00001e  b284              UXTH     r4,r0                 ;303
                  |L5.32|
000020  4294              CMP      r4,r2                 ;303
000022  dbf1              BLT      |L5.8|
000024  2000              MOVS     r0,#0                 ;314
000026  e7f8              B        |L5.26|
;;;316    
                          ENDP


                          AREA ||i.asu_flashPageWrite||, CODE, READONLY, ALIGN=1

                  asu_flashPageWrite PROC
;;;162    */
;;;163    void asu_flashPageWrite(uint8_t * _pBuf, uint32_t _uiWriteAddr, uint16_t _usSize)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;164    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;165    	uint32_t i, j;
;;;166    
;;;167        for (j = 0; j < _usSize / 256; j++)
00000a  f04f0800          MOV      r8,#0
00000e  e024              B        |L6.90|
                  |L6.16|
;;;168        {
;;;169            asu_flashWriteEnable();								/* 发送写使能命令 */
000010  f7fffffe          BL       asu_flashWriteEnable
;;;170    
;;;171            asu_flashSetCS(0);									/* 使能片选 */
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       asu_flashSetCS
;;;172            asu_spi_write(0x02);								/* 发送AAI命令(地址自动增加编程) */
00001a  2002              MOVS     r0,#2
00001c  f7fffffe          BL       bsp_spiWrite0_ASU
;;;173            asu_spi_write((_uiWriteAddr & 0xFF0000) >> 16);	/* 发送扇区地址的高8bit */
000020  f3c44007          UBFX     r0,r4,#16,#8
000024  f7fffffe          BL       bsp_spiWrite0_ASU
;;;174            asu_spi_write((_uiWriteAddr & 0xFF00) >> 8);		/* 发送扇区地址中间8bit */
000028  f3c42007          UBFX     r0,r4,#8,#8
00002c  f7fffffe          BL       bsp_spiWrite0_ASU
;;;175            asu_spi_write(_uiWriteAddr & 0xFF);				/* 发送扇区地址低8bit */
000030  b2e0              UXTB     r0,r4
000032  f7fffffe          BL       bsp_spiWrite0_ASU
;;;176    
;;;177            for (i = 0; i < 256; i++)
000036  2700              MOVS     r7,#0
000038  e004              B        |L6.68|
                  |L6.58|
;;;178            {
;;;179                asu_spi_write(*_pBuf++);					/* 发送数据 */
00003a  f8160b01          LDRB     r0,[r6],#1
00003e  f7fffffe          BL       bsp_spiWrite0_ASU
000042  1c7f              ADDS     r7,r7,#1              ;177
                  |L6.68|
000044  2fff              CMP      r7,#0xff              ;177
000046  d9f8              BLS      |L6.58|
;;;180            }
;;;181    
;;;182            asu_flashSetCS(1);								/* 禁止片选 */
000048  2001              MOVS     r0,#1
00004a  f7fffffe          BL       asu_flashSetCS
;;;183    
;;;184            asu_flashWaitForWriteEnd();						/* 等待串行Flash内部写操作完成 */
00004e  f7fffffe          BL       asu_flashWaitForWriteEnd
;;;185    
;;;186            _uiWriteAddr += 256;
000052  f5047480          ADD      r4,r4,#0x100
000056  f1080801          ADD      r8,r8,#1              ;167
                  |L6.90|
00005a  17e9              ASRS     r1,r5,#31             ;167
00005c  eb056111          ADD      r1,r5,r1,LSR #24      ;167
000060  ebb82f21          CMP      r8,r1,ASR #8          ;167
000064  d3d4              BCC      |L6.16|
;;;187        }
;;;188    
;;;189        /* 进入写保护状态 */
;;;190        asu_flashSetCS(0);
000066  2000              MOVS     r0,#0
000068  f7fffffe          BL       asu_flashSetCS
;;;191        asu_spi_write(CMD_WRITE_DISABLE);
00006c  2004              MOVS     r0,#4
00006e  f7fffffe          BL       bsp_spiWrite0_ASU
;;;192        asu_flashSetCS(1);
000072  2001              MOVS     r0,#1
000074  f7fffffe          BL       asu_flashSetCS
;;;193    
;;;194        asu_flashWaitForWriteEnd();							/* 等待串行Flash内部写操作完成 */
000078  f7fffffe          BL       asu_flashWaitForWriteEnd
;;;195    	
;;;196    }
00007c  e8bd81f0          POP      {r4-r8,pc}
;;;197    
                          ENDP


                          AREA ||i.asu_flashReadBuffer||, CODE, READONLY, ALIGN=2

                  asu_flashReadBuffer PROC
;;;207    */
;;;208    void asu_flashReadBuffer(uint8_t * _pBuf, uint32_t _uiReadAddr, uint32_t _uiSize)
000000  b570              PUSH     {r4-r6,lr}
;;;209    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;210    	/* 如果读取的数据长度为0或者超出串行Flash地址空间，则直接返回 */
;;;211    	if ((_uiSize == 0) ||(_uiReadAddr + _uiSize) > g_tOrange_Flash.TotalSize)
000008  b125              CBZ      r5,|L7.20|
00000a  1960              ADDS     r0,r4,r5
00000c  4911              LDR      r1,|L7.84|
00000e  6949              LDR      r1,[r1,#0x14]  ; g_tOrange_Flash
000010  4288              CMP      r0,r1
000012  d900              BLS      |L7.22|
                  |L7.20|
;;;212    	{
;;;213    		return;
;;;214    	}
;;;215    
;;;216    	/* 擦除扇区操作 */
;;;217    	asu_flashSetCS(0);									/* 使能片选 */
;;;218    	asu_spi_write(CMD_READ_DATA);							/* 发送读命令 */
;;;219    	asu_spi_write((_uiReadAddr & 0xFF0000) >> 16);	/* 发送扇区地址的高8bit */
;;;220    	asu_spi_write((_uiReadAddr & 0xFF00) >> 8);		/* 发送扇区地址中间8bit */
;;;221    	asu_spi_write(_uiReadAddr & 0xFF);				/* 发送扇区地址低8bit */
;;;222    	while (_uiSize--)
;;;223    	{
;;;224    		*_pBuf++ = asu_spi_read();			/* 读一个字节并存储到pBuf，读完后指针自加1 */
;;;225    	}
;;;226    	asu_flashSetCS(1);									/* 禁能片选 */
;;;227    }
000014  bd70              POP      {r4-r6,pc}
                  |L7.22|
000016  2000              MOVS     r0,#0                 ;217
000018  f7fffffe          BL       asu_flashSetCS
00001c  2003              MOVS     r0,#3                 ;218
00001e  f7fffffe          BL       bsp_spiWrite0_ASU
000022  f3c44007          UBFX     r0,r4,#16,#8          ;219
000026  f7fffffe          BL       bsp_spiWrite0_ASU
00002a  f3c42007          UBFX     r0,r4,#8,#8           ;220
00002e  f7fffffe          BL       bsp_spiWrite0_ASU
000032  b2e0              UXTB     r0,r4                 ;221
000034  f7fffffe          BL       bsp_spiWrite0_ASU
000038  e003              B        |L7.66|
                  |L7.58|
00003a  f7fffffe          BL       bsp_spiRead0_ASU
00003e  f8060b01          STRB     r0,[r6],#1            ;224
                  |L7.66|
000042  1e28              SUBS     r0,r5,#0              ;222
000044  f1a50501          SUB      r5,r5,#1              ;222
000048  d1f7              BNE      |L7.58|
00004a  2001              MOVS     r0,#1                 ;226
00004c  f7fffffe          BL       asu_flashSetCS
000050  bf00              NOP      
000052  e7df              B        |L7.20|
;;;228    
                          ENDP

                  |L7.84|
                          DCD      g_tOrange_Flash

                          AREA ||i.asu_flashReadID||, CODE, READONLY, ALIGN=1

                  asu_flashReadID PROC
;;;540    */
;;;541    uint32_t asu_flashReadID(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;542    {
;;;543    	uint32_t uiID;
;;;544    	uint8_t id1, id2, id3;
;;;545    
;;;546    	asu_flashSetCS(0);									/* 使能片选 */
000004  2000              MOVS     r0,#0
000006  f7fffffe          BL       asu_flashSetCS
;;;547    	asu_spi_write(CMD_JEDEC_DEVICE_ID);								/* 发送读ID命令 */
00000a  209f              MOVS     r0,#0x9f
00000c  f7fffffe          BL       bsp_spiWrite0_ASU
;;;548    	id1 = asu_spi_read();					/* 读ID的第1个字节 */
000010  f7fffffe          BL       bsp_spiRead0_ASU
000014  4605              MOV      r5,r0
;;;549    	id2 = asu_spi_read();					/* 读ID的第2个字节 */
000016  f7fffffe          BL       bsp_spiRead0_ASU
00001a  4606              MOV      r6,r0
;;;550    	id3 = asu_spi_read();					/* 读ID的第3个字节 */
00001c  f7fffffe          BL       bsp_spiRead0_ASU
000020  4607              MOV      r7,r0
;;;551    	asu_flashSetCS(1);									/* 禁能片选 */
000022  2001              MOVS     r0,#1
000024  f7fffffe          BL       asu_flashSetCS
;;;552    
;;;553    	uiID = ((uint32_t)id1 << 16) | ((uint32_t)id2 << 8) | id3;
000028  0428              LSLS     r0,r5,#16
00002a  ea402006          ORR      r0,r0,r6,LSL #8
00002e  ea400407          ORR      r4,r0,r7
;;;554    
;;;555    	return uiID;
000032  4620              MOV      r0,r4
;;;556    }
000034  e8bd81f0          POP      {r4-r8,pc}
;;;557    
                          ENDP


                          AREA ||i.asu_flashReadInfo||, CODE, READONLY, ALIGN=2

                  asu_flashReadInfo PROC
;;;565    */
;;;566    static void asu_flashReadInfo(void)
000000  b510              PUSH     {r4,lr}
;;;567    {
;;;568    	/* 自动识别串行Flash型号 */
;;;569    	{
;;;570    		g_tOrange_Flash.ChipID = asu_flashReadID();	/* 芯片ID */
000002  f7fffffe          BL       asu_flashReadID
000006  4910              LDR      r1,|L9.72|
000008  6008              STR      r0,[r1,#0]  ; g_tOrange_Flash
;;;571    
;;;572    		switch (g_tOrange_Flash.ChipID)
00000a  4608              MOV      r0,r1
00000c  6800              LDR      r0,[r0,#0]  ; g_tOrange_Flash
00000e  490f              LDR      r1,|L9.76|
000010  4408              ADD      r0,r0,r1
000012  b958              CBNZ     r0,|L9.44|
;;;573    		{
;;;574            case UC25HD20_ID:
;;;575                strcpy(g_tOrange_Flash.ChipName, "UC25HD20");
000014  a10e              ADR      r1,|L9.80|
000016  480c              LDR      r0,|L9.72|
000018  1d00              ADDS     r0,r0,#4
00001a  f7fffffe          BL       strcpy
;;;576                g_tOrange_Flash.TotalSize = 2 * 1024 * 1024;	/* 总容量 = 2M */
00001e  f44f1000          MOV      r0,#0x200000
000022  4909              LDR      r1,|L9.72|
000024  6148              STR      r0,[r1,#0x14]  ; g_tOrange_Flash
;;;577                g_tOrange_Flash.SectorSize = 4 * 1024;			/* 页面大小 = 4K */
000026  1240              ASRS     r0,r0,#9
000028  8308              STRH     r0,[r1,#0x18]
;;;578                break;
00002a  e00b              B        |L9.68|
                  |L9.44|
;;;579            
;;;580            default:
;;;581                strcpy(g_tOrange_Flash.ChipName, "Unknow Flash");
00002c  a10b              ADR      r1,|L9.92|
00002e  4806              LDR      r0,|L9.72|
000030  1d00              ADDS     r0,r0,#4
000032  f7fffffe          BL       strcpy
;;;582                g_tOrange_Flash.TotalSize = 2 * 1024 * 1024;
000036  f44f1000          MOV      r0,#0x200000
00003a  4903              LDR      r1,|L9.72|
00003c  6148              STR      r0,[r1,#0x14]  ; g_tOrange_Flash
;;;583                g_tOrange_Flash.SectorSize = 4 * 1024;
00003e  1240              ASRS     r0,r0,#9
000040  8308              STRH     r0,[r1,#0x18]
;;;584                break;
000042  bf00              NOP      
                  |L9.68|
000044  bf00              NOP                            ;578
;;;585    		}
;;;586    	}
;;;587    }
000046  bd10              POP      {r4,pc}
;;;588    
                          ENDP

                  |L9.72|
                          DCD      g_tOrange_Flash
                  |L9.76|
                          DCD      0xff4c9fee
                  |L9.80|
000050  55433235          DCB      "UC25HD20",0
000054  48443230
000058  00      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0
                  |L9.92|
00005c  556e6b6e          DCB      "Unknow Flash",0
000060  6f772046
000064  6c617368
000068  00      
000069  00                DCB      0
00006a  00                DCB      0
00006b  00                DCB      0

                          AREA ||i.asu_flashSetCS||, CODE, READONLY, ALIGN=2

                  asu_flashSetCS PROC
;;;69     */
;;;70     static void asu_flashSetCS(uint8_t _level)
000000  b510              PUSH     {r4,lr}
;;;71     {
000002  4604              MOV      r4,r0
;;;72     	if (_level == 0)
000004  b944              CBNZ     r4,|L10.24|
;;;73     	{
;;;74     		bsp_SpiBusEnter();	/* 占用SPI总线， 用于总线共享 */
000006  f7fffffe          BL       bsp_SpiBusEnter
;;;75     
;;;76             bsp_SetSpiSck(1);
00000a  2001              MOVS     r0,#1
00000c  f7fffffe          BL       bsp_SetSpiSck
;;;77             ASU_CS_0();
000010  2080              MOVS     r0,#0x80
000012  4905              LDR      r1,|L10.40|
000014  8008              STRH     r0,[r1,#0]
000016  e005              B        |L10.36|
                  |L10.24|
;;;78     	}
;;;79     	else
;;;80     	{
;;;81     		ASU_CS_1();
000018  2080              MOVS     r0,#0x80
00001a  4903              LDR      r1,|L10.40|
00001c  1e89              SUBS     r1,r1,#2
00001e  8008              STRH     r0,[r1,#0]
;;;82     		bsp_SpiBusExit();	/* 释放SPI总线， 用于总线共享 */
000020  f7fffffe          BL       bsp_SpiBusExit
                  |L10.36|
;;;83     	}
;;;84     }
000024  bd10              POP      {r4,pc}
;;;85     
                          ENDP

000026  0000              DCW      0x0000
                  |L10.40|
                          DCD      0x40020c1a

                          AREA ||i.asu_flashWaitForWriteEnd||, CODE, READONLY, ALIGN=1

                  asu_flashWaitForWriteEnd PROC
;;;627    */
;;;628    static void asu_flashWaitForWriteEnd(void)
000000  b510              PUSH     {r4,lr}
;;;629    {
;;;630    	asu_flashSetCS(0);									/* 使能片选 */
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       asu_flashSetCS
;;;631    	asu_spi_write(CMD_READ_STATUS);							/* 发送命令， 读状态寄存器 */
000008  2005              MOVS     r0,#5
00000a  f7fffffe          BL       bsp_spiWrite0_ASU
;;;632    	while((asu_spi_read() & WIP_FLAG) == SET);	/* 判断状态寄存器的忙标志位 */
00000e  bf00              NOP      
                  |L11.16|
000010  f7fffffe          BL       bsp_spiRead0_ASU
000014  f0000001          AND      r0,r0,#1
000018  2800              CMP      r0,#0
00001a  d1f9              BNE      |L11.16|
;;;633    	asu_flashSetCS(1);									/* 禁能片选 */
00001c  2001              MOVS     r0,#1
00001e  f7fffffe          BL       asu_flashSetCS
;;;634    }
000022  bd10              POP      {r4,pc}
;;;635    
                          ENDP


                          AREA ||i.asu_flashWriteBuffer||, CODE, READONLY, ALIGN=2

                  asu_flashWriteBuffer PROC
;;;432    */
;;;433    uint8_t asu_flashWriteBuffer(uint8_t* _pBuf, uint32_t _uiWriteAddr, uint16_t _usWriteSize)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;434    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;435    	uint16_t NumOfPage = 0, NumOfSingle = 0, Addr = 0, count = 0, temp = 0;
00000a  f04f0800          MOV      r8,#0
00000e  46c1              MOV      r9,r8
000010  46c2              MOV      r10,r8
000012  2400              MOVS     r4,#0
000014  46a3              MOV      r11,r4
;;;436    
;;;437    	Addr = _uiWriteAddr % g_tOrange_Flash.SectorSize;
000016  4856              LDR      r0,|L12.368|
000018  8b00              LDRH     r0,[r0,#0x18]  ; g_tOrange_Flash
00001a  fbb5f1f0          UDIV     r1,r5,r0
00001e  fb005011          MLS      r0,r0,r1,r5
000022  fa1ffa80          UXTH     r10,r0
;;;438    	count = g_tOrange_Flash.SectorSize - Addr;
000026  4852              LDR      r0,|L12.368|
000028  8b00              LDRH     r0,[r0,#0x18]  ; g_tOrange_Flash
00002a  eba0000a          SUB      r0,r0,r10
00002e  b284              UXTH     r4,r0
;;;439    	NumOfPage =  _usWriteSize / g_tOrange_Flash.SectorSize;
000030  484f              LDR      r0,|L12.368|
000032  8b00              LDRH     r0,[r0,#0x18]  ; g_tOrange_Flash
000034  fb96f0f0          SDIV     r0,r6,r0
000038  fa1ff880          UXTH     r8,r0
;;;440    	NumOfSingle = _usWriteSize % g_tOrange_Flash.SectorSize;
00003c  484c              LDR      r0,|L12.368|
00003e  8b00              LDRH     r0,[r0,#0x18]  ; g_tOrange_Flash
000040  fb96f1f0          SDIV     r1,r6,r0
000044  fb006011          MLS      r0,r0,r1,r6
000048  fa1ff980          UXTH     r9,r0
;;;441    
;;;442    	if (Addr == 0) /* 起始地址是页面首地址  */
00004c  f1ba0f00          CMP      r10,#0
000050  d12a              BNE      |L12.168|
;;;443    	{
;;;444    		if (NumOfPage == 0) /* 数据长度小于页面大小 */
000052  f1b80f00          CMP      r8,#0
000056  d108              BNE      |L12.106|
;;;445    		{
;;;446    			if (asu_flashAutoWritePage(_pBuf, _uiWriteAddr, _usWriteSize) == 0)
000058  4632              MOV      r2,r6
00005a  4629              MOV      r1,r5
00005c  4638              MOV      r0,r7
00005e  f7fffffe          BL       asu_flashAutoWritePage
000062  2800              CMP      r0,#0
000064  d17e              BNE      |L12.356|
                  |L12.102|
;;;447    			{
;;;448    				return 0;
;;;449    			}
;;;450    		}
;;;451    		else 	/* 数据长度大于等于页面大小 */
;;;452    		{
;;;453    			while (NumOfPage--)
;;;454    			{
;;;455    				if (asu_flashAutoWritePage(_pBuf, _uiWriteAddr, g_tOrange_Flash.SectorSize) == 0)
;;;456    				{
;;;457    					return 0;
;;;458    				}
;;;459    				_uiWriteAddr +=  g_tOrange_Flash.SectorSize;
;;;460    				_pBuf += g_tOrange_Flash.SectorSize;
;;;461    			}
;;;462    			if (asu_flashAutoWritePage(_pBuf, _uiWriteAddr, NumOfSingle) == 0)
;;;463    			{
;;;464    				return 0;
;;;465    			}
;;;466    		}
;;;467    	}
;;;468    	else  /* 起始地址不是页面首地址  */
;;;469    	{
;;;470    		if (NumOfPage == 0) /* 数据长度小于页面大小 */
;;;471    		{
;;;472    			if (NumOfSingle > count) /* (_usWriteSize + _uiWriteAddr) > SPI_FLASH_PAGESIZE */
;;;473    			{
;;;474    				temp = NumOfSingle - count;
;;;475    
;;;476    				if (asu_flashAutoWritePage(_pBuf, _uiWriteAddr, count) == 0)
;;;477    				{
;;;478    					return 0;
;;;479    				}
;;;480    
;;;481    				_uiWriteAddr +=  count;
;;;482    				_pBuf += count;
;;;483    
;;;484    				if (asu_flashAutoWritePage(_pBuf, _uiWriteAddr, temp) == 0)
;;;485    				{
;;;486    					return 0;
;;;487    				}
;;;488    			}
;;;489    			else
;;;490    			{
;;;491    				if (asu_flashAutoWritePage(_pBuf, _uiWriteAddr, _usWriteSize) == 0)
;;;492    				{
;;;493    					return 0;
;;;494    				}
;;;495    			}
;;;496    		}
;;;497    		else	/* 数据长度大于等于页面大小 */
;;;498    		{
;;;499    			_usWriteSize -= count;
;;;500    			NumOfPage =  _usWriteSize / g_tOrange_Flash.SectorSize;
;;;501    			NumOfSingle = _usWriteSize % g_tOrange_Flash.SectorSize;
;;;502    
;;;503    			if (asu_flashAutoWritePage(_pBuf, _uiWriteAddr, count) == 0)
;;;504    			{
;;;505    				return 0;
;;;506    			}
;;;507    
;;;508    			_uiWriteAddr +=  count;
;;;509    			_pBuf += count;
;;;510    
;;;511    			while (NumOfPage--)
;;;512    			{
;;;513    				if (asu_flashAutoWritePage(_pBuf, _uiWriteAddr, g_tOrange_Flash.SectorSize) == 0)
;;;514    				{
;;;515    					return 0;
;;;516    				}
;;;517    				_uiWriteAddr +=  g_tOrange_Flash.SectorSize;
;;;518    				_pBuf += g_tOrange_Flash.SectorSize;
;;;519    			}
;;;520    
;;;521    			if (NumOfSingle != 0)
;;;522    			{
;;;523    				if (asu_flashAutoWritePage(_pBuf, _uiWriteAddr, NumOfSingle) == 0)
;;;524    				{
;;;525    					return 0;
;;;526    				}
;;;527    			}
;;;528    		}
;;;529    	}
;;;530    	return 1;	/* 成功 */
;;;531    }
000066  e8bd9ff0          POP      {r4-r12,pc}
                  |L12.106|
00006a  e00e              B        |L12.138|
                  |L12.108|
00006c  4840              LDR      r0,|L12.368|
00006e  8b02              LDRH     r2,[r0,#0x18]         ;455  ; g_tOrange_Flash
000070  4629              MOV      r1,r5                 ;455
000072  4638              MOV      r0,r7                 ;455
000074  f7fffffe          BL       asu_flashAutoWritePage
000078  b908              CBNZ     r0,|L12.126|
00007a  2000              MOVS     r0,#0                 ;457
00007c  e7f3              B        |L12.102|
                  |L12.126|
00007e  483c              LDR      r0,|L12.368|
000080  8b00              LDRH     r0,[r0,#0x18]         ;459  ; g_tOrange_Flash
000082  4405              ADD      r5,r5,r0              ;459
000084  483a              LDR      r0,|L12.368|
000086  8b00              LDRH     r0,[r0,#0x18]         ;460  ; g_tOrange_Flash
000088  4407              ADD      r7,r7,r0              ;460
                  |L12.138|
00008a  f1b80000          SUBS     r0,r8,#0              ;453
00008e  f1a80101          SUB      r1,r8,#1              ;453
000092  fa1ff881          UXTH     r8,r1                 ;453
000096  d1e9              BNE      |L12.108|
000098  464a              MOV      r2,r9                 ;462
00009a  4629              MOV      r1,r5                 ;462
00009c  4638              MOV      r0,r7                 ;462
00009e  f7fffffe          BL       asu_flashAutoWritePage
0000a2  2800              CMP      r0,#0                 ;462
0000a4  d161              BNE      |L12.362|
0000a6  e7de              B        |L12.102|
                  |L12.168|
0000a8  f1b80f00          CMP      r8,#0                 ;470
0000ac  d11f              BNE      |L12.238|
0000ae  45a1              CMP      r9,r4                 ;472
0000b0  dd15              BLE      |L12.222|
0000b2  eba90004          SUB      r0,r9,r4              ;474
0000b6  fa1ffb80          UXTH     r11,r0                ;474
0000ba  4622              MOV      r2,r4                 ;476
0000bc  4629              MOV      r1,r5                 ;476
0000be  4638              MOV      r0,r7                 ;476
0000c0  f7fffffe          BL       asu_flashAutoWritePage
0000c4  b908              CBNZ     r0,|L12.202|
0000c6  2000              MOVS     r0,#0                 ;478
0000c8  e7cd              B        |L12.102|
                  |L12.202|
0000ca  4425              ADD      r5,r5,r4              ;481
0000cc  4427              ADD      r7,r7,r4              ;482
0000ce  465a              MOV      r2,r11                ;484
0000d0  4629              MOV      r1,r5                 ;484
0000d2  4638              MOV      r0,r7                 ;484
0000d4  f7fffffe          BL       asu_flashAutoWritePage
0000d8  2800              CMP      r0,#0                 ;484
0000da  d146              BNE      |L12.362|
0000dc  e7c3              B        |L12.102|
                  |L12.222|
0000de  4632              MOV      r2,r6                 ;491
0000e0  4629              MOV      r1,r5                 ;491
0000e2  4638              MOV      r0,r7                 ;491
0000e4  f7fffffe          BL       asu_flashAutoWritePage
0000e8  bbe0              CBNZ     r0,|L12.356|
0000ea  2000              MOVS     r0,#0                 ;493
0000ec  e7bb              B        |L12.102|
                  |L12.238|
0000ee  1b30              SUBS     r0,r6,r4              ;499
0000f0  b286              UXTH     r6,r0                 ;499
0000f2  481f              LDR      r0,|L12.368|
0000f4  8b00              LDRH     r0,[r0,#0x18]         ;500  ; g_tOrange_Flash
0000f6  fb96f0f0          SDIV     r0,r6,r0              ;500
0000fa  fa1ff880          UXTH     r8,r0                 ;500
0000fe  481c              LDR      r0,|L12.368|
000100  8b00              LDRH     r0,[r0,#0x18]         ;501  ; g_tOrange_Flash
000102  fb96f1f0          SDIV     r1,r6,r0              ;501
000106  fb006011          MLS      r0,r0,r1,r6           ;501
00010a  fa1ff980          UXTH     r9,r0                 ;501
00010e  4622              MOV      r2,r4                 ;503
000110  4629              MOV      r1,r5                 ;503
000112  4638              MOV      r0,r7                 ;503
000114  f7fffffe          BL       asu_flashAutoWritePage
000118  b908              CBNZ     r0,|L12.286|
00011a  2000              MOVS     r0,#0                 ;505
00011c  e7a3              B        |L12.102|
                  |L12.286|
00011e  4425              ADD      r5,r5,r4              ;508
000120  4427              ADD      r7,r7,r4              ;509
000122  e00e              B        |L12.322|
                  |L12.292|
000124  4812              LDR      r0,|L12.368|
000126  8b02              LDRH     r2,[r0,#0x18]         ;513  ; g_tOrange_Flash
000128  4629              MOV      r1,r5                 ;513
00012a  4638              MOV      r0,r7                 ;513
00012c  f7fffffe          BL       asu_flashAutoWritePage
000130  b908              CBNZ     r0,|L12.310|
000132  2000              MOVS     r0,#0                 ;515
000134  e797              B        |L12.102|
                  |L12.310|
000136  480e              LDR      r0,|L12.368|
000138  8b00              LDRH     r0,[r0,#0x18]         ;517  ; g_tOrange_Flash
00013a  4405              ADD      r5,r5,r0              ;517
00013c  480c              LDR      r0,|L12.368|
00013e  8b00              LDRH     r0,[r0,#0x18]         ;518  ; g_tOrange_Flash
000140  4407              ADD      r7,r7,r0              ;518
                  |L12.322|
000142  f1b80000          SUBS     r0,r8,#0              ;511
000146  f1a80101          SUB      r1,r8,#1              ;511
00014a  fa1ff881          UXTH     r8,r1                 ;511
00014e  d1e9              BNE      |L12.292|
000150  f1b90f00          CMP      r9,#0                 ;521
000154  d009              BEQ      |L12.362|
000156  464a              MOV      r2,r9                 ;523
000158  4629              MOV      r1,r5                 ;523
00015a  4638              MOV      r0,r7                 ;523
00015c  f7fffffe          BL       asu_flashAutoWritePage
000160  b900              CBNZ     r0,|L12.356|
000162  e000              B        |L12.358|
                  |L12.356|
000164  e001              B        |L12.362|
                  |L12.358|
000166  2000              MOVS     r0,#0                 ;525
000168  e77d              B        |L12.102|
                  |L12.362|
00016a  2001              MOVS     r0,#1                 ;530
00016c  e77b              B        |L12.102|
;;;532    
                          ENDP

00016e  0000              DCW      0x0000
                  |L12.368|
                          DCD      g_tOrange_Flash

                          AREA ||i.asu_flashWriteEnable||, CODE, READONLY, ALIGN=1

                  asu_flashWriteEnable PROC
;;;596    */
;;;597    static void asu_flashWriteEnable(void)
000000  b510              PUSH     {r4,lr}
;;;598    {
;;;599    	asu_flashSetCS(0);									/* 使能片选 */
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       asu_flashSetCS
;;;600    	asu_spi_write(CMD_WRITE_ENABLE);					 /* 发送命令 */
000008  2006              MOVS     r0,#6
00000a  f7fffffe          BL       bsp_spiWrite0_ASU
;;;601    	asu_flashSetCS(1);									/* 禁能片选 */
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       asu_flashSetCS
;;;602    }
000014  bd10              POP      {r4,pc}
;;;603    
                          ENDP


                          AREA ||i.asu_flashWriteStatus||, CODE, READONLY, ALIGN=1

                  asu_flashWriteStatus PROC
;;;611    */
;;;612    static void asu_flashWriteStatus(uint8_t _ucValue)
000000  b510              PUSH     {r4,lr}
;;;613    {
000002  4604              MOV      r4,r0
;;;614        asu_flashSetCS(0);									/* 使能片选 */
000004  2000              MOVS     r0,#0
000006  f7fffffe          BL       asu_flashSetCS
;;;615        asu_spi_write(CMD_WRITE_STATUS);				    /* 发送命令， 写状态寄存器 */
00000a  2001              MOVS     r0,#1
00000c  f7fffffe          BL       bsp_spiWrite0_ASU
;;;616        asu_spi_write(_ucValue);							/* 发送数据：状态寄存器的值 */
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       bsp_spiWrite0_ASU
;;;617        asu_flashSetCS(1);									/* 禁能片选 */
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       asu_flashSetCS
;;;618    }
00001c  bd10              POP      {r4,pc}
;;;619    
                          ENDP


                          AREA ||i.kiwi_flash_init||, CODE, READONLY, ALIGN=1

                  kiwi_flash_init PROC
;;;93     */
;;;94     void kiwi_flash_init(void)
000000  b510              PUSH     {r4,lr}
;;;95     {
;;;96     	//asu_flashConfigGPIO();			/* 配置GPIO */
;;;97     	//asu_flashCfgSpiHard();
;;;98     
;;;99     	asu_flashReadInfo();				                                        /* 自动识别芯片型号 */
000002  f7fffffe          BL       asu_flashReadInfo
;;;100    
;;;101    	asu_flashSetCS(0);				                                            /* 软件方式，使能串行Flash片选 */
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       asu_flashSetCS
;;;102    	asu_spi_write(CMD_WRITE_DISABLE);		                                    /* 发送禁止写入的命令,即使能软件写保护 */
00000c  2004              MOVS     r0,#4
00000e  f7fffffe          BL       bsp_spiWrite0_ASU
;;;103    	asu_flashSetCS(1);				                                            /* 软件方式，禁能串行Flash片选 */
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       asu_flashSetCS
;;;104    
;;;105    	asu_flashWaitForWriteEnd();		                                            /* 等待串行Flash内部操作完成 */
000018  f7fffffe          BL       asu_flashWaitForWriteEnd
;;;106    
;;;107    	asu_flashWriteStatus(0);			                                        /* 解除所有BLOCK的写保护 */
00001c  2000              MOVS     r0,#0
00001e  f7fffffe          BL       asu_flashWriteStatus
;;;108    }
000022  bd10              POP      {r4,pc}
;;;109    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_tOrange_Flash
                          %        28

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\kiwi_ft\\asu_flash_drv.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_asu_flash_drv_c_ee131765____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_asu_flash_drv_c_ee131765____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_asu_flash_drv_c_ee131765____REVSH|
#line 144
|__asm___15_asu_flash_drv_c_ee131765____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
