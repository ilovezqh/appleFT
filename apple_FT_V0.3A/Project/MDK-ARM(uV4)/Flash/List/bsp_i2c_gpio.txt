; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\flash\obj\bsp_i2c_gpio.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_i2c_gpio.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\User -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\User\FatFS\src -I..\..\Libraries\STM32_USB_Device_Library\Class\msc\inc -I..\..\Libraries\STM32_USB_Device_Library\Core\inc -I..\..\Libraries\STM32_USB_OTG_Driver\inc -I..\..\User\usbd_mass_storage -I..\..\User\ft_support -I..\..\User\test -I..\..\User\emenu -I..\..\User\chip_ft -I..\..\User\lwrb -I..\..\User\easylogger\inc -I..\..\User\easylogger\plugins\file -I..\..\User\LOG -I..\..\User\MultiButton-1.1.0 -I..\..\User\cm_backtrace -I..\..\User\MultiTimer -I.\RTE\_Flash -IC:\Users\qizha\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\qizha\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.17.1\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F407xx -D_RTE_ -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY --signed_chars --omf_browse=.\flash\obj\bsp_i2c_gpio.crf ..\..\User\bsp_stm32f4xx\src\bsp_i2c_gpio.c]
                          THUMB

                          AREA ||i.bsp_InitI2C||, CODE, READONLY, ALIGN=2

                  bsp_InitI2C PROC
;;;54     */
;;;55     void bsp_InitI2C(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;56     {
;;;57     	GPIO_InitTypeDef GPIO_InitStructure;
;;;58     
;;;59     	RCC_AHB1PeriphClockCmd(RCC_I2C_PORT, ENABLE);	/* 打开GPIO时钟 */
000002  2101              MOVS     r1,#1
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;60     
;;;61     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;		/* 设为输出口 */
00000a  2001              MOVS     r0,#1
00000c  f88d0004          STRB     r0,[sp,#4]
;;;62     	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;		/* 设为开漏模式 */
000010  f88d0006          STRB     r0,[sp,#6]
;;;63     	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;	/* 上下拉电阻不使能 */
000014  2000              MOVS     r0,#0
000016  f88d0007          STRB     r0,[sp,#7]
;;;64     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;	/* IO口最大速度 */
00001a  2003              MOVS     r0,#3
00001c  f88d0005          STRB     r0,[sp,#5]
;;;65     
;;;66     	GPIO_InitStructure.GPIO_Pin = I2C_SCL_PIN | I2C_SDA_PIN;
000020  0280              LSLS     r0,r0,#10
000022  9000              STR      r0,[sp,#0]
;;;67     	GPIO_Init(GPIO_PORT_I2C, &GPIO_InitStructure);
000024  4669              MOV      r1,sp
000026  4803              LDR      r0,|L1.52|
000028  f7fffffe          BL       GPIO_Init
;;;68     
;;;69     	/* 给一个停止信号, 复位I2C总线上的所有设备到待机模式 */
;;;70     	i2c_Stop();
00002c  f7fffffe          BL       i2c_Stop
;;;71     }
000030  bd1c              POP      {r2-r4,pc}
;;;72     
                          ENDP

000032  0000              DCW      0x0000
                  |L1.52|
                          DCD      0x40020400

                          AREA ||i.i2c_Ack||, CODE, READONLY, ALIGN=2

                  i2c_Ack PROC
;;;241    */
;;;242    void i2c_Ack(void)
000000  b510              PUSH     {r4,lr}
;;;243    {
;;;244    	I2C_SDA_0();	/* CPU驱动SDA = 0 */
000002  f44f6000          MOV      r0,#0x800
000006  490b              LDR      r1,|L2.52|
000008  8008              STRH     r0,[r1,#0]
;;;245    	i2c_Delay();
00000a  f7fffffe          BL       i2c_Delay
;;;246    	I2C_SCL_1();	/* CPU产生1个时钟 */
00000e  f44f6080          MOV      r0,#0x400
000012  4908              LDR      r1,|L2.52|
000014  1e89              SUBS     r1,r1,#2
000016  8008              STRH     r0,[r1,#0]
;;;247    	i2c_Delay();
000018  f7fffffe          BL       i2c_Delay
;;;248    	I2C_SCL_0();
00001c  f44f6080          MOV      r0,#0x400
000020  4904              LDR      r1,|L2.52|
000022  8008              STRH     r0,[r1,#0]
;;;249    	i2c_Delay();
000024  f7fffffe          BL       i2c_Delay
;;;250    	I2C_SDA_1();	/* CPU释放SDA总线 */
000028  f44f6000          MOV      r0,#0x800
00002c  4901              LDR      r1,|L2.52|
00002e  1e89              SUBS     r1,r1,#2
000030  8008              STRH     r0,[r1,#0]
;;;251    }
000032  bd10              POP      {r4,pc}
;;;252    
                          ENDP

                  |L2.52|
                          DCD      0x4002041a

                          AREA ||i.i2c_CheckDevice||, CODE, READONLY, ALIGN=2

                  i2c_CheckDevice PROC
;;;278    */
;;;279    uint8_t i2c_CheckDevice(uint8_t _Address)
000000  b570              PUSH     {r4-r6,lr}
;;;280    {
000002  4604              MOV      r4,r0
;;;281    	uint8_t ucAck;
;;;282    
;;;283    	if (I2C_SDA_READ() && I2C_SCL_READ())
000004  480b              LDR      r0,|L3.52|
000006  6800              LDR      r0,[r0,#0]
000008  f4006000          AND      r0,r0,#0x800
00000c  b180              CBZ      r0,|L3.48|
00000e  4809              LDR      r0,|L3.52|
000010  6800              LDR      r0,[r0,#0]
000012  f4006080          AND      r0,r0,#0x400
000016  b158              CBZ      r0,|L3.48|
;;;284    	{
;;;285    		i2c_Start();		/* 发送启动信号 */
000018  f7fffffe          BL       i2c_Start
;;;286    
;;;287    		/* 发送设备地址+读写控制bit（0 = w， 1 = r) bit7 先传 */
;;;288    		i2c_SendByte(_Address | I2C_WR);
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       i2c_SendByte
;;;289    		ucAck = i2c_WaitAck();	/* 检测设备的ACK应答 */
000022  f7fffffe          BL       i2c_WaitAck
000026  4605              MOV      r5,r0
;;;290    
;;;291    		i2c_Stop();			/* 发送停止信号 */
000028  f7fffffe          BL       i2c_Stop
;;;292    
;;;293    		return ucAck;
00002c  4628              MOV      r0,r5
                  |L3.46|
;;;294    	}
;;;295    	return 1;	/* I2C总线异常 */
;;;296    }
00002e  bd70              POP      {r4-r6,pc}
                  |L3.48|
000030  2001              MOVS     r0,#1                 ;295
000032  e7fc              B        |L3.46|
                          ENDP

                  |L3.52|
                          DCD      0x40020410

                          AREA ||i.i2c_Delay||, CODE, READONLY, ALIGN=1

                  i2c_Delay PROC
;;;80     */
;;;81     static void i2c_Delay(void)
000000  2000              MOVS     r0,#0
;;;82     {
;;;83     	uint8_t i;
;;;84     
;;;85     	/*　
;;;86     		CPU主频168MHz时，在内部Flash运行, MDK工程不优化。用台式示波器观测波形。
;;;87     		循环次数为5时，SCL频率 = 1.78MHz (读耗时: 92ms, 读写正常，但是用示波器探头碰上就读写失败。时序接近临界)
;;;88     		循环次数为10时，SCL频率 = 1.1MHz (读耗时: 138ms, 读速度: 118724B/s)
;;;89     		循环次数为30时，SCL频率 = 440KHz， SCL高电平时间1.0us，SCL低电平时间1.2us
;;;90     
;;;91     		上拉电阻选择2.2K欧时，SCL上升沿时间约0.5us，如果选4.7K欧，则上升沿约1us
;;;92     
;;;93     		实际应用选择400KHz左右的速率即可
;;;94     	*/
;;;95     	for (i = 0; i < 30; i++)
000002  e002              B        |L4.10|
                  |L4.4|
;;;96         {
;;;97             __nop();
000004  bf00              NOP      
000006  1c41              ADDS     r1,r0,#1              ;95
000008  b2c8              UXTB     r0,r1                 ;95
                  |L4.10|
00000a  281e              CMP      r0,#0x1e              ;95
00000c  dbfa              BLT      |L4.4|
;;;98         }
;;;99      
;;;100    }
00000e  4770              BX       lr
;;;101    
                          ENDP


                          AREA ||i.i2c_NAck||, CODE, READONLY, ALIGN=2

                  i2c_NAck PROC
;;;260    */
;;;261    void i2c_NAck(void)
000000  b510              PUSH     {r4,lr}
;;;262    {
;;;263    	I2C_SDA_1();	/* CPU驱动SDA = 1 */
000002  f44f6000          MOV      r0,#0x800
000006  4909              LDR      r1,|L5.44|
000008  8008              STRH     r0,[r1,#0]
;;;264    	i2c_Delay();
00000a  f7fffffe          BL       i2c_Delay
;;;265    	I2C_SCL_1();	/* CPU产生1个时钟 */
00000e  f44f6080          MOV      r0,#0x400
000012  4906              LDR      r1,|L5.44|
000014  8008              STRH     r0,[r1,#0]
;;;266    	i2c_Delay();
000016  f7fffffe          BL       i2c_Delay
;;;267    	I2C_SCL_0();
00001a  f44f6080          MOV      r0,#0x400
00001e  4903              LDR      r1,|L5.44|
000020  1c89              ADDS     r1,r1,#2
000022  8008              STRH     r0,[r1,#0]
;;;268    	i2c_Delay();
000024  f7fffffe          BL       i2c_Delay
;;;269    }
000028  bd10              POP      {r4,pc}
;;;270    
                          ENDP

00002a  0000              DCW      0x0000
                  |L5.44|
                          DCD      0x40020418

                          AREA ||i.i2c_ReadByte||, CODE, READONLY, ALIGN=2

                  i2c_ReadByte PROC
;;;182    */
;;;183    uint8_t i2c_ReadByte(void)
000000  b570              PUSH     {r4-r6,lr}
;;;184    {
;;;185    	uint8_t i;
;;;186    	uint8_t value;
;;;187    
;;;188    	/* 读到第1个bit为数据的bit7 */
;;;189    	value = 0;
000002  2400              MOVS     r4,#0
;;;190    	for (i = 0; i < 8; i++)
000004  2500              MOVS     r5,#0
000006  e018              B        |L6.58|
                  |L6.8|
;;;191    	{
;;;192    		value <<= 1;
000008  0660              LSLS     r0,r4,#25
00000a  0e04              LSRS     r4,r0,#24
;;;193    		I2C_SCL_1();
00000c  f44f6080          MOV      r0,#0x400
000010  490c              LDR      r1,|L6.68|
000012  8008              STRH     r0,[r1,#0]
;;;194    		i2c_Delay();
000014  f7fffffe          BL       i2c_Delay
;;;195    		if (I2C_SDA_READ())
000018  480a              LDR      r0,|L6.68|
00001a  3808              SUBS     r0,r0,#8
00001c  6800              LDR      r0,[r0,#0]
00001e  f4006000          AND      r0,r0,#0x800
000022  b108              CBZ      r0,|L6.40|
;;;196    		{
;;;197    			value++;
000024  1c60              ADDS     r0,r4,#1
000026  b2c4              UXTB     r4,r0
                  |L6.40|
;;;198    		}
;;;199    		I2C_SCL_0();
000028  f44f6080          MOV      r0,#0x400
00002c  4905              LDR      r1,|L6.68|
00002e  1c89              ADDS     r1,r1,#2
000030  8008              STRH     r0,[r1,#0]
;;;200    		i2c_Delay();
000032  f7fffffe          BL       i2c_Delay
000036  1c68              ADDS     r0,r5,#1              ;190
000038  b2c5              UXTB     r5,r0                 ;190
                  |L6.58|
00003a  2d08              CMP      r5,#8                 ;190
00003c  dbe4              BLT      |L6.8|
;;;201    	}
;;;202    	return value;
00003e  4620              MOV      r0,r4
;;;203    }
000040  bd70              POP      {r4-r6,pc}
;;;204    
                          ENDP

000042  0000              DCW      0x0000
                  |L6.68|
                          DCD      0x40020418

                          AREA ||i.i2c_SendByte||, CODE, READONLY, ALIGN=2

                  i2c_SendByte PROC
;;;146    */
;;;147    void i2c_SendByte(uint8_t _ucByte)
000000  b570              PUSH     {r4-r6,lr}
;;;148    {
000002  4604              MOV      r4,r0
;;;149    	uint8_t i;
;;;150    
;;;151    	/* 先发送字节的高位bit7 */
;;;152    	for (i = 0; i < 8; i++)
000004  2500              MOVS     r5,#0
000006  e024              B        |L7.82|
                  |L7.8|
;;;153    	{
;;;154    		if (_ucByte & 0x80)
000008  f0040080          AND      r0,r4,#0x80
00000c  b120              CBZ      r0,|L7.24|
;;;155    		{
;;;156    			I2C_SDA_1();
00000e  f44f6000          MOV      r0,#0x800
000012  4911              LDR      r1,|L7.88|
000014  8008              STRH     r0,[r1,#0]
000016  e004              B        |L7.34|
                  |L7.24|
;;;157    		}
;;;158    		else
;;;159    		{
;;;160    			I2C_SDA_0();
000018  f44f6000          MOV      r0,#0x800
00001c  490e              LDR      r1,|L7.88|
00001e  1c89              ADDS     r1,r1,#2
000020  8008              STRH     r0,[r1,#0]
                  |L7.34|
;;;161    		}
;;;162    		i2c_Delay();
000022  f7fffffe          BL       i2c_Delay
;;;163    		I2C_SCL_1();
000026  f44f6080          MOV      r0,#0x400
00002a  490b              LDR      r1,|L7.88|
00002c  8008              STRH     r0,[r1,#0]
;;;164    		i2c_Delay();
00002e  f7fffffe          BL       i2c_Delay
;;;165    		I2C_SCL_0();
000032  f44f6080          MOV      r0,#0x400
000036  4908              LDR      r1,|L7.88|
000038  1c89              ADDS     r1,r1,#2
00003a  8008              STRH     r0,[r1,#0]
;;;166    		if (i == 7)
00003c  2d07              CMP      r5,#7
00003e  d102              BNE      |L7.70|
;;;167    		{
;;;168    			 I2C_SDA_1(); // 释放总线
000040  0040              LSLS     r0,r0,#1
000042  1e89              SUBS     r1,r1,#2
000044  8008              STRH     r0,[r1,#0]
                  |L7.70|
;;;169    		}
;;;170    		_ucByte <<= 1;	/* 左移一个bit */
000046  0660              LSLS     r0,r4,#25
000048  0e04              LSRS     r4,r0,#24
;;;171    		i2c_Delay();
00004a  f7fffffe          BL       i2c_Delay
00004e  1c68              ADDS     r0,r5,#1              ;152
000050  b2c5              UXTB     r5,r0                 ;152
                  |L7.82|
000052  2d08              CMP      r5,#8                 ;152
000054  dbd8              BLT      |L7.8|
;;;172    	}
;;;173    }
000056  bd70              POP      {r4-r6,pc}
;;;174    
                          ENDP

                  |L7.88|
                          DCD      0x40020418

                          AREA ||i.i2c_Start||, CODE, READONLY, ALIGN=2

                  i2c_Start PROC
;;;109    */
;;;110    void i2c_Start(void)
000000  b510              PUSH     {r4,lr}
;;;111    {
;;;112    	/* 当SCL高电平时，SDA出现一个下跳沿表示I2C总线启动信号 */
;;;113    	I2C_SDA_1();
000002  f44f6000          MOV      r0,#0x800
000006  490a              LDR      r1,|L8.48|
000008  8008              STRH     r0,[r1,#0]
;;;114    	I2C_SCL_1();
00000a  1040              ASRS     r0,r0,#1
00000c  8008              STRH     r0,[r1,#0]
;;;115    	i2c_Delay();
00000e  f7fffffe          BL       i2c_Delay
;;;116    	I2C_SDA_0();
000012  f44f6000          MOV      r0,#0x800
000016  4906              LDR      r1,|L8.48|
000018  1c89              ADDS     r1,r1,#2
00001a  8008              STRH     r0,[r1,#0]
;;;117    	i2c_Delay();
00001c  f7fffffe          BL       i2c_Delay
;;;118    	I2C_SCL_0();
000020  f44f6080          MOV      r0,#0x400
000024  4902              LDR      r1,|L8.48|
000026  1c89              ADDS     r1,r1,#2
000028  8008              STRH     r0,[r1,#0]
;;;119    	i2c_Delay();
00002a  f7fffffe          BL       i2c_Delay
;;;120    }
00002e  bd10              POP      {r4,pc}
;;;121    
                          ENDP

                  |L8.48|
                          DCD      0x40020418

                          AREA ||i.i2c_Stop||, CODE, READONLY, ALIGN=2

                  i2c_Stop PROC
;;;129    */
;;;130    void i2c_Stop(void)
000000  b510              PUSH     {r4,lr}
;;;131    {
;;;132    	/* 当SCL高电平时，SDA出现一个上跳沿表示I2C总线停止信号 */
;;;133    	I2C_SDA_0();
000002  f44f6000          MOV      r0,#0x800
000006  4906              LDR      r1,|L9.32|
000008  8008              STRH     r0,[r1,#0]
;;;134    	I2C_SCL_1();
00000a  1040              ASRS     r0,r0,#1
00000c  1e89              SUBS     r1,r1,#2
00000e  8008              STRH     r0,[r1,#0]
;;;135    	i2c_Delay();
000010  f7fffffe          BL       i2c_Delay
;;;136    	I2C_SDA_1();
000014  f44f6000          MOV      r0,#0x800
000018  4901              LDR      r1,|L9.32|
00001a  1e89              SUBS     r1,r1,#2
00001c  8008              STRH     r0,[r1,#0]
;;;137    }
00001e  bd10              POP      {r4,pc}
;;;138    
                          ENDP

                  |L9.32|
                          DCD      0x4002041a

                          AREA ||i.i2c_WaitAck||, CODE, READONLY, ALIGN=2

                  i2c_WaitAck PROC
;;;212    */
;;;213    uint8_t i2c_WaitAck(void)
000000  b510              PUSH     {r4,lr}
;;;214    {
;;;215    	uint8_t re;
;;;216    
;;;217    	I2C_SDA_1();	/* CPU释放SDA总线 */
000002  f44f6000          MOV      r0,#0x800
000006  490e              LDR      r1,|L10.64|
000008  8008              STRH     r0,[r1,#0]
;;;218    	i2c_Delay();
00000a  f7fffffe          BL       i2c_Delay
;;;219    	I2C_SCL_1();	/* CPU驱动SCL = 1, 此时器件会返回ACK应答 */
00000e  f44f6080          MOV      r0,#0x400
000012  490b              LDR      r1,|L10.64|
000014  8008              STRH     r0,[r1,#0]
;;;220    	i2c_Delay();
000016  f7fffffe          BL       i2c_Delay
;;;221    	if (I2C_SDA_READ())	/* CPU读取SDA口线状态 */
00001a  4809              LDR      r0,|L10.64|
00001c  3808              SUBS     r0,r0,#8
00001e  6800              LDR      r0,[r0,#0]
000020  f4006000          AND      r0,r0,#0x800
000024  b108              CBZ      r0,|L10.42|
;;;222    	{
;;;223    		re = 1;
000026  2401              MOVS     r4,#1
000028  e000              B        |L10.44|
                  |L10.42|
;;;224    	}
;;;225    	else
;;;226    	{
;;;227    		re = 0;
00002a  2400              MOVS     r4,#0
                  |L10.44|
;;;228    	}
;;;229    	I2C_SCL_0();
00002c  f44f6080          MOV      r0,#0x400
000030  4903              LDR      r1,|L10.64|
000032  1c89              ADDS     r1,r1,#2
000034  8008              STRH     r0,[r1,#0]
;;;230    	i2c_Delay();
000036  f7fffffe          BL       i2c_Delay
;;;231    	return re;
00003a  4620              MOV      r0,r4
;;;232    }
00003c  bd10              POP      {r4,pc}
;;;233    
                          ENDP

00003e  0000              DCW      0x0000
                  |L10.64|
                          DCD      0x40020418

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\src\\bsp_i2c_gpio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_bsp_i2c_gpio_c_ec180c52____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___14_bsp_i2c_gpio_c_ec180c52____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_bsp_i2c_gpio_c_ec180c52____REVSH|
#line 144
|__asm___14_bsp_i2c_gpio_c_ec180c52____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
