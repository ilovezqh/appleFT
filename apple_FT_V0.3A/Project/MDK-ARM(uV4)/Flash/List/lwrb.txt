; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\flash\obj\lwrb.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\lwrb.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\User -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\User\FatFS\src -I..\..\Libraries\STM32_USB_Device_Library\Class\msc\inc -I..\..\Libraries\STM32_USB_Device_Library\Core\inc -I..\..\Libraries\STM32_USB_OTG_Driver\inc -I..\..\User\usbd_mass_storage -I..\..\User\ft_support -I..\..\User\test -I..\..\User\emenu -I..\..\User\chip_ft -I..\..\User\lwrb -I..\..\User\easylogger\inc -I..\..\User\easylogger\plugins\file -I..\..\User\LOG -I..\..\User\MultiButton-1.1.0 -I..\..\User\cm_backtrace -I..\..\User\MultiTimer -I.\RTE\_Flash -IC:\Users\qizha\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\qizha\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.17.1\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F407xx -D_RTE_ -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY --signed_chars --omf_browse=.\flash\obj\lwrb.crf ..\..\User\lwrb\lwrb.c]
                          THUMB

                          AREA ||i.lwrb_advance||, CODE, READONLY, ALIGN=2

                  lwrb_advance PROC
;;;476    size_t
;;;477    lwrb_advance(lwrb_t* buff, size_t len) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;478        size_t free;
;;;479        volatile size_t w;
;;;480    
;;;481        if (!BUF_IS_VALID(buff) || len == 0) {
000006  b164              CBZ      r4,|L1.34|
000008  4918              LDR      r1,|L1.108|
00000a  6820              LDR      r0,[r4,#0]
00000c  4288              CMP      r0,r1
00000e  d108              BNE      |L1.34|
000010  43c9              MVNS     r1,r1
000012  69a0              LDR      r0,[r4,#0x18]
000014  4288              CMP      r0,r1
000016  d104              BNE      |L1.34|
000018  6860              LDR      r0,[r4,#4]
00001a  b110              CBZ      r0,|L1.34|
00001c  68a0              LDR      r0,[r4,#8]
00001e  b100              CBZ      r0,|L1.34|
000020  b90d              CBNZ     r5,|L1.38|
                  |L1.34|
;;;482            return 0;
000022  2000              MOVS     r0,#0
                  |L1.36|
;;;483        }
;;;484    
;;;485        /* Use local variables before writing back to main structure */
;;;486        free = lwrb_get_free(buff);
;;;487        len = BUF_MIN(len, free);
;;;488        w = buff->w + len;
;;;489        if (w >= buff->size) {
;;;490            w -= buff->size;
;;;491        }
;;;492        buff->w = w;
;;;493        BUF_SEND_EVT(buff, LWRB_EVT_WRITE, len);
;;;494        return len;
;;;495    }
000024  bdf8              POP      {r3-r7,pc}
                  |L1.38|
000026  4620              MOV      r0,r4                 ;486
000028  f7fffffe          BL       lwrb_get_free
00002c  4606              MOV      r6,r0                 ;486
00002e  42b5              CMP      r5,r6                 ;487
000030  d201              BCS      |L1.54|
000032  4628              MOV      r0,r5                 ;487
000034  e000              B        |L1.56|
                  |L1.54|
000036  4630              MOV      r0,r6                 ;487
                  |L1.56|
000038  4605              MOV      r5,r0                 ;487
00003a  6920              LDR      r0,[r4,#0x10]         ;488
00003c  4428              ADD      r0,r0,r5              ;488
00003e  9000              STR      r0,[sp,#0]            ;488
000040  68a0              LDR      r0,[r4,#8]            ;489
000042  9900              LDR      r1,[sp,#0]            ;489
000044  4288              CMP      r0,r1                 ;489
000046  d803              BHI      |L1.80|
000048  68a0              LDR      r0,[r4,#8]            ;490
00004a  9900              LDR      r1,[sp,#0]            ;490
00004c  1a08              SUBS     r0,r1,r0              ;490
00004e  9000              STR      r0,[sp,#0]            ;490
                  |L1.80|
000050  9800              LDR      r0,[sp,#0]            ;492
000052  6120              STR      r0,[r4,#0x10]         ;492
000054  bf00              NOP                            ;493
000056  6960              LDR      r0,[r4,#0x14]         ;493
000058  b120              CBZ      r0,|L1.100|
00005a  462a              MOV      r2,r5                 ;493
00005c  2101              MOVS     r1,#1                 ;493
00005e  4620              MOV      r0,r4                 ;493
000060  6963              LDR      r3,[r4,#0x14]         ;493
000062  4798              BLX      r3                    ;493
                  |L1.100|
000064  bf00              NOP                            ;493
000066  4628              MOV      r0,r5                 ;494
000068  e7dc              B        |L1.36|
                          ENDP

00006a  0000              DCW      0x0000
                  |L1.108|
                          DCD      0xdeadbeef

                          AREA ||i.lwrb_free||, CODE, READONLY, ALIGN=2

                  lwrb_free PROC
;;;95     void
;;;96     lwrb_free(lwrb_t* buff) {
000000  b168              CBZ      r0,|L2.30|
;;;97         if (BUF_IS_VALID(buff)) {
000002  4a07              LDR      r2,|L2.32|
000004  6801              LDR      r1,[r0,#0]
000006  4291              CMP      r1,r2
000008  d109              BNE      |L2.30|
00000a  43d2              MVNS     r2,r2
00000c  6981              LDR      r1,[r0,#0x18]
00000e  4291              CMP      r1,r2
000010  d105              BNE      |L2.30|
000012  6841              LDR      r1,[r0,#4]
000014  b119              CBZ      r1,|L2.30|
000016  6881              LDR      r1,[r0,#8]
000018  b109              CBZ      r1,|L2.30|
;;;98             buff->buff = NULL;
00001a  2100              MOVS     r1,#0
00001c  6041              STR      r1,[r0,#4]
                  |L2.30|
;;;99         }
;;;100    }
00001e  4770              BX       lr
;;;101    
                          ENDP

                  |L2.32|
                          DCD      0xdeadbeef

                          AREA ||i.lwrb_get_free||, CODE, READONLY, ALIGN=2

                  lwrb_get_free PROC
;;;280    size_t
;;;281    lwrb_get_free(lwrb_t* buff) {
000000  b51c              PUSH     {r2-r4,lr}
000002  4601              MOV      r1,r0
;;;282        size_t size;
;;;283        volatile size_t w, r;
;;;284    
;;;285        if (!BUF_IS_VALID(buff)) {
000004  b159              CBZ      r1,|L3.30|
000006  4b13              LDR      r3,|L3.84|
000008  6808              LDR      r0,[r1,#0]
00000a  4298              CMP      r0,r3
00000c  d107              BNE      |L3.30|
00000e  43db              MVNS     r3,r3
000010  6988              LDR      r0,[r1,#0x18]
000012  4298              CMP      r0,r3
000014  d103              BNE      |L3.30|
000016  6848              LDR      r0,[r1,#4]
000018  b108              CBZ      r0,|L3.30|
00001a  6888              LDR      r0,[r1,#8]
00001c  b908              CBNZ     r0,|L3.34|
                  |L3.30|
;;;286            return 0;
00001e  2000              MOVS     r0,#0
                  |L3.32|
;;;287        }
;;;288    
;;;289        /* Use temporary values in case they are changed during operations */
;;;290        w = buff->w;
;;;291        r = buff->r;
;;;292        if (w == r) {
;;;293            size = buff->size;
;;;294        } else if (r > w) {
;;;295            size = r - w;
;;;296        } else {
;;;297            size = buff->size - (w - r);
;;;298        }
;;;299    
;;;300        /* Buffer free size is always 1 less than actual size */
;;;301        return size - 1;
;;;302    }
000020  bd1c              POP      {r2-r4,pc}
                  |L3.34|
000022  6908              LDR      r0,[r1,#0x10]         ;290
000024  9001              STR      r0,[sp,#4]            ;290
000026  68c8              LDR      r0,[r1,#0xc]          ;291
000028  9000              STR      r0,[sp,#0]            ;291
00002a  e9dd3000          LDRD     r3,r0,[sp,#0]         ;292
00002e  4298              CMP      r0,r3                 ;292
000030  d101              BNE      |L3.54|
000032  688a              LDR      r2,[r1,#8]            ;293
000034  e00c              B        |L3.80|
                  |L3.54|
000036  e9dd0300          LDRD     r0,r3,[sp,#0]         ;294
00003a  4298              CMP      r0,r3                 ;294
00003c  d903              BLS      |L3.70|
00003e  e9dd0300          LDRD     r0,r3,[sp,#0]         ;295
000042  1ac2              SUBS     r2,r0,r3              ;295
000044  e004              B        |L3.80|
                  |L3.70|
000046  6888              LDR      r0,[r1,#8]            ;297
000048  e9dd4300          LDRD     r4,r3,[sp,#0]         ;297
00004c  1b1b              SUBS     r3,r3,r4              ;297
00004e  1ac2              SUBS     r2,r0,r3              ;297
                  |L3.80|
000050  1e50              SUBS     r0,r2,#1              ;301
000052  e7e5              B        |L3.32|
;;;303    
                          ENDP

                  |L3.84|
                          DCD      0xdeadbeef

                          AREA ||i.lwrb_get_full||, CODE, READONLY, ALIGN=2

                  lwrb_get_full PROC
;;;309    size_t
;;;310    lwrb_get_full(lwrb_t* buff) {
000000  b51c              PUSH     {r2-r4,lr}
000002  4601              MOV      r1,r0
;;;311        size_t size;
;;;312        volatile size_t w, r;
;;;313    
;;;314        if (!BUF_IS_VALID(buff)) {
000004  b159              CBZ      r1,|L4.30|
000006  4b13              LDR      r3,|L4.84|
000008  6808              LDR      r0,[r1,#0]
00000a  4298              CMP      r0,r3
00000c  d107              BNE      |L4.30|
00000e  43db              MVNS     r3,r3
000010  6988              LDR      r0,[r1,#0x18]
000012  4298              CMP      r0,r3
000014  d103              BNE      |L4.30|
000016  6848              LDR      r0,[r1,#4]
000018  b108              CBZ      r0,|L4.30|
00001a  6888              LDR      r0,[r1,#8]
00001c  b908              CBNZ     r0,|L4.34|
                  |L4.30|
;;;315            return 0;
00001e  2000              MOVS     r0,#0
                  |L4.32|
;;;316        }
;;;317    
;;;318        /* Use temporary values in case they are changed during operations */
;;;319        w = buff->w;
;;;320        r = buff->r;
;;;321        if (w == r) {
;;;322            size = 0;
;;;323        } else if (w > r) {
;;;324            size = w - r;
;;;325        } else {
;;;326            size = buff->size - (r - w);
;;;327        }
;;;328        return size;
;;;329    }
000020  bd1c              POP      {r2-r4,pc}
                  |L4.34|
000022  6908              LDR      r0,[r1,#0x10]         ;319
000024  9001              STR      r0,[sp,#4]            ;319
000026  68c8              LDR      r0,[r1,#0xc]          ;320
000028  9000              STR      r0,[sp,#0]            ;320
00002a  e9dd3000          LDRD     r3,r0,[sp,#0]         ;321
00002e  4298              CMP      r0,r3                 ;321
000030  d101              BNE      |L4.54|
000032  2200              MOVS     r2,#0                 ;322
000034  e00c              B        |L4.80|
                  |L4.54|
000036  e9dd3000          LDRD     r3,r0,[sp,#0]         ;323
00003a  4298              CMP      r0,r3                 ;323
00003c  d903              BLS      |L4.70|
00003e  e9dd3000          LDRD     r3,r0,[sp,#0]         ;324
000042  1ac2              SUBS     r2,r0,r3              ;324
000044  e004              B        |L4.80|
                  |L4.70|
000046  6888              LDR      r0,[r1,#8]            ;326
000048  e9dd3400          LDRD     r3,r4,[sp,#0]         ;326
00004c  1b1b              SUBS     r3,r3,r4              ;326
00004e  1ac2              SUBS     r2,r0,r3              ;326
                  |L4.80|
000050  4610              MOV      r0,r2                 ;328
000052  e7e5              B        |L4.32|
;;;330    
                          ENDP

                  |L4.84|
                          DCD      0xdeadbeef

                          AREA ||i.lwrb_get_linear_block_read_address||, CODE, READONLY, ALIGN=2

                  lwrb_get_linear_block_read_address PROC
;;;351    void*
;;;352    lwrb_get_linear_block_read_address(lwrb_t* buff) {
000000  4601              MOV      r1,r0
;;;353        if (!BUF_IS_VALID(buff)) {
000002  b159              CBZ      r1,|L5.28|
000004  4a08              LDR      r2,|L5.40|
000006  6808              LDR      r0,[r1,#0]
000008  4290              CMP      r0,r2
00000a  d107              BNE      |L5.28|
00000c  43d2              MVNS     r2,r2
00000e  6988              LDR      r0,[r1,#0x18]
000010  4290              CMP      r0,r2
000012  d103              BNE      |L5.28|
000014  6848              LDR      r0,[r1,#4]
000016  b108              CBZ      r0,|L5.28|
000018  6888              LDR      r0,[r1,#8]
00001a  b908              CBNZ     r0,|L5.32|
                  |L5.28|
;;;354            return NULL;
00001c  2000              MOVS     r0,#0
                  |L5.30|
;;;355        }
;;;356        return &buff->buff[buff->r];
;;;357    }
00001e  4770              BX       lr
                  |L5.32|
000020  68ca              LDR      r2,[r1,#0xc]          ;356
000022  6848              LDR      r0,[r1,#4]            ;356
000024  4410              ADD      r0,r0,r2              ;356
000026  e7fa              B        |L5.30|
;;;358    
                          ENDP

                  |L5.40|
                          DCD      0xdeadbeef

                          AREA ||i.lwrb_get_linear_block_read_length||, CODE, READONLY, ALIGN=2

                  lwrb_get_linear_block_read_length PROC
;;;364    size_t
;;;365    lwrb_get_linear_block_read_length(lwrb_t* buff) {
000000  b50c              PUSH     {r2,r3,lr}
000002  4601              MOV      r1,r0
;;;366        size_t len;
;;;367        volatile size_t w, r;
;;;368    
;;;369        if (!BUF_IS_VALID(buff)) {
000004  b159              CBZ      r1,|L6.30|
000006  4b12              LDR      r3,|L6.80|
000008  6808              LDR      r0,[r1,#0]
00000a  4298              CMP      r0,r3
00000c  d107              BNE      |L6.30|
00000e  43db              MVNS     r3,r3
000010  6988              LDR      r0,[r1,#0x18]
000012  4298              CMP      r0,r3
000014  d103              BNE      |L6.30|
000016  6848              LDR      r0,[r1,#4]
000018  b108              CBZ      r0,|L6.30|
00001a  6888              LDR      r0,[r1,#8]
00001c  b908              CBNZ     r0,|L6.34|
                  |L6.30|
;;;370            return 0;
00001e  2000              MOVS     r0,#0
                  |L6.32|
;;;371        }
;;;372    
;;;373        /* Use temporary values in case they are changed during operations */
;;;374        w = buff->w;
;;;375        r = buff->r;
;;;376        if (w > r) {
;;;377            len = w - r;
;;;378        } else if (r > w) {
;;;379            len = buff->size - r;
;;;380        } else {
;;;381            len = 0;
;;;382        }
;;;383        return len;
;;;384    }
000020  bd0c              POP      {r2,r3,pc}
                  |L6.34|
000022  6908              LDR      r0,[r1,#0x10]         ;374
000024  9001              STR      r0,[sp,#4]            ;374
000026  68c8              LDR      r0,[r1,#0xc]          ;375
000028  9000              STR      r0,[sp,#0]            ;375
00002a  e9dd3000          LDRD     r3,r0,[sp,#0]         ;376
00002e  4298              CMP      r0,r3                 ;376
000030  d903              BLS      |L6.58|
000032  e9dd3000          LDRD     r3,r0,[sp,#0]         ;377
000036  1ac2              SUBS     r2,r0,r3              ;377
000038  e008              B        |L6.76|
                  |L6.58|
00003a  e9dd0300          LDRD     r0,r3,[sp,#0]         ;378
00003e  4298              CMP      r0,r3                 ;378
000040  d903              BLS      |L6.74|
000042  6888              LDR      r0,[r1,#8]            ;379
000044  9b00              LDR      r3,[sp,#0]            ;379
000046  1ac2              SUBS     r2,r0,r3              ;379
000048  e000              B        |L6.76|
                  |L6.74|
00004a  2200              MOVS     r2,#0                 ;381
                  |L6.76|
00004c  4610              MOV      r0,r2                 ;383
00004e  e7e7              B        |L6.32|
;;;385    
                          ENDP

                  |L6.80|
                          DCD      0xdeadbeef

                          AREA ||i.lwrb_get_linear_block_write_address||, CODE, READONLY, ALIGN=2

                  lwrb_get_linear_block_write_address PROC
;;;420    void*
;;;421    lwrb_get_linear_block_write_address(lwrb_t* buff) {
000000  4601              MOV      r1,r0
;;;422        if (!BUF_IS_VALID(buff)) {
000002  b159              CBZ      r1,|L7.28|
000004  4a08              LDR      r2,|L7.40|
000006  6808              LDR      r0,[r1,#0]
000008  4290              CMP      r0,r2
00000a  d107              BNE      |L7.28|
00000c  43d2              MVNS     r2,r2
00000e  6988              LDR      r0,[r1,#0x18]
000010  4290              CMP      r0,r2
000012  d103              BNE      |L7.28|
000014  6848              LDR      r0,[r1,#4]
000016  b108              CBZ      r0,|L7.28|
000018  6888              LDR      r0,[r1,#8]
00001a  b908              CBNZ     r0,|L7.32|
                  |L7.28|
;;;423            return NULL;
00001c  2000              MOVS     r0,#0
                  |L7.30|
;;;424        }
;;;425        return &buff->buff[buff->w];
;;;426    }
00001e  4770              BX       lr
                  |L7.32|
000020  690a              LDR      r2,[r1,#0x10]         ;425
000022  6848              LDR      r0,[r1,#4]            ;425
000024  4410              ADD      r0,r0,r2              ;425
000026  e7fa              B        |L7.30|
;;;427    
                          ENDP

                  |L7.40|
                          DCD      0xdeadbeef

                          AREA ||i.lwrb_get_linear_block_write_length||, CODE, READONLY, ALIGN=2

                  lwrb_get_linear_block_write_length PROC
;;;433    size_t
;;;434    lwrb_get_linear_block_write_length(lwrb_t* buff) {
000000  b50c              PUSH     {r2,r3,lr}
000002  4601              MOV      r1,r0
;;;435        size_t len;
;;;436        volatile size_t w, r;
;;;437    
;;;438        if (!BUF_IS_VALID(buff)) {
000004  b159              CBZ      r1,|L8.30|
000006  4b11              LDR      r3,|L8.76|
000008  6808              LDR      r0,[r1,#0]
00000a  4298              CMP      r0,r3
00000c  d107              BNE      |L8.30|
00000e  43db              MVNS     r3,r3
000010  6988              LDR      r0,[r1,#0x18]
000012  4298              CMP      r0,r3
000014  d103              BNE      |L8.30|
000016  6848              LDR      r0,[r1,#4]
000018  b108              CBZ      r0,|L8.30|
00001a  6888              LDR      r0,[r1,#8]
00001c  b908              CBNZ     r0,|L8.34|
                  |L8.30|
;;;439            return 0;
00001e  2000              MOVS     r0,#0
                  |L8.32|
;;;440        }
;;;441    
;;;442        /* Use temporary values in case they are changed during operations */
;;;443        w = buff->w;
;;;444        r = buff->r;
;;;445        if (w >= r) {
;;;446            len = buff->size - w;
;;;447            /*
;;;448             * When read pointer is 0,
;;;449             * maximal length is one less as if too many bytes
;;;450             * are written, buffer would be considered empty again (r == w)
;;;451             */
;;;452            if (r == 0) {
;;;453                /*
;;;454                 * Cannot overflow:
;;;455                 * - If r is not 0, statement does not get called
;;;456                 * - buff->size cannot be 0 and if r is 0, len is greater 0
;;;457                 */
;;;458                --len;
;;;459            }
;;;460        } else {
;;;461            len = r - w - 1;
;;;462        }
;;;463        return len;
;;;464    }
000020  bd0c              POP      {r2,r3,pc}
                  |L8.34|
000022  6908              LDR      r0,[r1,#0x10]         ;443
000024  9001              STR      r0,[sp,#4]            ;443
000026  68c8              LDR      r0,[r1,#0xc]          ;444
000028  9000              STR      r0,[sp,#0]            ;444
00002a  e9dd3000          LDRD     r3,r0,[sp,#0]         ;445
00002e  4298              CMP      r0,r3                 ;445
000030  d306              BCC      |L8.64|
000032  6888              LDR      r0,[r1,#8]            ;446
000034  9b01              LDR      r3,[sp,#4]            ;446
000036  1ac2              SUBS     r2,r0,r3              ;446
000038  9800              LDR      r0,[sp,#0]            ;452
00003a  b928              CBNZ     r0,|L8.72|
00003c  1e52              SUBS     r2,r2,#1              ;458
00003e  e003              B        |L8.72|
                  |L8.64|
000040  e9dd0300          LDRD     r0,r3,[sp,#0]         ;461
000044  1ac0              SUBS     r0,r0,r3              ;461
000046  1e42              SUBS     r2,r0,#1              ;461
                  |L8.72|
000048  4610              MOV      r0,r2                 ;463
00004a  e7e9              B        |L8.32|
;;;465    
                          ENDP

                  |L8.76|
                          DCD      0xdeadbeef

                          AREA ||i.lwrb_init||, CODE, READONLY, ALIGN=2

                  lwrb_init PROC
;;;60     uint8_t
;;;61     lwrb_init(lwrb_t* buff, void* buffdata, size_t size) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;62         if (buff == NULL || buffdata == NULL || size == 0) {
000008  b10c              CBZ      r4,|L9.14|
00000a  b105              CBZ      r5,|L9.14|
00000c  b90e              CBNZ     r6,|L9.18|
                  |L9.14|
;;;63             return 0;
00000e  2000              MOVS     r0,#0
                  |L9.16|
;;;64         }
;;;65     
;;;66         BUF_MEMSET((void*)buff, 0x00, sizeof(*buff));
;;;67     
;;;68         buff->size = size;
;;;69         buff->buff = buffdata;
;;;70     
;;;71     #if LWRB_USE_MAGIC
;;;72         buff->magic1 = BUF_MAGIC1;
;;;73         buff->magic2 = BUF_MAGIC2;
;;;74     #endif /* LWRB_USE_MAGIC */
;;;75     
;;;76         return 1;
;;;77     }
000010  bd70              POP      {r4-r6,pc}
                  |L9.18|
000012  211c              MOVS     r1,#0x1c              ;66
000014  4620              MOV      r0,r4                 ;66
000016  f7fffffe          BL       __aeabi_memclr4
00001a  60a6              STR      r6,[r4,#8]            ;68
00001c  6065              STR      r5,[r4,#4]            ;69
00001e  4803              LDR      r0,|L9.44|
000020  6020              STR      r0,[r4,#0]            ;72
000022  43c0              MVNS     r0,r0                 ;73
000024  61a0              STR      r0,[r4,#0x18]         ;73
000026  2001              MOVS     r0,#1                 ;76
000028  e7f2              B        |L9.16|
;;;78     
                          ENDP

00002a  0000              DCW      0x0000
                  |L9.44|
                          DCD      0xdeadbeef

                          AREA ||i.lwrb_is_ready||, CODE, READONLY, ALIGN=2

                  lwrb_is_ready PROC
;;;84     uint8_t
;;;85     lwrb_is_ready(lwrb_t* buff) {
000000  4601              MOV      r1,r0
;;;86         return BUF_IS_VALID(buff);
000002  b169              CBZ      r1,|L10.32|
000004  4a07              LDR      r2,|L10.36|
000006  6808              LDR      r0,[r1,#0]
000008  4290              CMP      r0,r2
00000a  d109              BNE      |L10.32|
00000c  43d2              MVNS     r2,r2
00000e  6988              LDR      r0,[r1,#0x18]
000010  4290              CMP      r0,r2
000012  d105              BNE      |L10.32|
000014  6848              LDR      r0,[r1,#4]
000016  b118              CBZ      r0,|L10.32|
000018  6888              LDR      r0,[r1,#8]
00001a  b108              CBZ      r0,|L10.32|
00001c  2001              MOVS     r0,#1
                  |L10.30|
;;;87     }
00001e  4770              BX       lr
                  |L10.32|
000020  2000              MOVS     r0,#0                 ;86
000022  e7fc              B        |L10.30|
;;;88     
                          ENDP

                  |L10.36|
                          DCD      0xdeadbeef

                          AREA ||i.lwrb_peek||, CODE, READONLY, ALIGN=2

                  lwrb_peek PROC
;;;232    size_t
;;;233    lwrb_peek(lwrb_t* buff, size_t skip_count, void* data, size_t btp) {
000000  e92d4ff8          PUSH     {r3-r11,lr}
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4691              MOV      r9,r2
00000a  461d              MOV      r5,r3
;;;234        size_t full, tocopy;
;;;235        volatile size_t r;
;;;236        uint8_t* d = data;
00000c  46ca              MOV      r10,r9
;;;237    
;;;238        if (!BUF_IS_VALID(buff) || data == NULL || btp == 0) {
00000e  b17c              CBZ      r4,|L11.48|
000010  4927              LDR      r1,|L11.176|
000012  6820              LDR      r0,[r4,#0]
000014  4288              CMP      r0,r1
000016  d10b              BNE      |L11.48|
000018  43c9              MVNS     r1,r1
00001a  69a0              LDR      r0,[r4,#0x18]
00001c  4288              CMP      r0,r1
00001e  d107              BNE      |L11.48|
000020  6860              LDR      r0,[r4,#4]
000022  b128              CBZ      r0,|L11.48|
000024  68a0              LDR      r0,[r4,#8]
000026  b118              CBZ      r0,|L11.48|
000028  f1b90f00          CMP      r9,#0
00002c  d000              BEQ      |L11.48|
00002e  b915              CBNZ     r5,|L11.54|
                  |L11.48|
;;;239            return 0;
000030  2000              MOVS     r0,#0
                  |L11.50|
;;;240        }
;;;241    
;;;242        r = buff->r;
;;;243    
;;;244        /* Calculate maximum number of bytes available to read */
;;;245        full = lwrb_get_full(buff);
;;;246    
;;;247        /* Skip beginning of buffer */
;;;248        if (skip_count >= full) {
;;;249            return 0;
;;;250        }
;;;251        r += skip_count;
;;;252        full -= skip_count;
;;;253        if (r >= buff->size) {
;;;254            r -= buff->size;
;;;255        }
;;;256    
;;;257        /* Check maximum number of bytes available to read after skip */
;;;258        btp = BUF_MIN(full, btp);
;;;259        if (btp == 0) {
;;;260            return 0;
;;;261        }
;;;262    
;;;263        /* Step 1: Read data from linear part of buffer */
;;;264        tocopy = BUF_MIN(buff->size - r, btp);
;;;265        BUF_MEMCPY(d, &buff->buff[r], tocopy);
;;;266        btp -= tocopy;
;;;267    
;;;268        /* Step 2: Read data from beginning of buffer (overflow part) */
;;;269        if (btp > 0) {
;;;270            BUF_MEMCPY(&d[tocopy], buff->buff, btp);
;;;271        }
;;;272        return tocopy + btp;
;;;273    }
000032  e8bd8ff8          POP      {r3-r11,pc}
                  |L11.54|
000036  68e0              LDR      r0,[r4,#0xc]          ;242
000038  9000              STR      r0,[sp,#0]            ;242
00003a  4620              MOV      r0,r4                 ;245
00003c  f7fffffe          BL       lwrb_get_full
000040  4606              MOV      r6,r0                 ;245
000042  42b7              CMP      r7,r6                 ;248
000044  d301              BCC      |L11.74|
000046  2000              MOVS     r0,#0                 ;249
000048  e7f3              B        |L11.50|
                  |L11.74|
00004a  9800              LDR      r0,[sp,#0]            ;251
00004c  4438              ADD      r0,r0,r7              ;251
00004e  9000              STR      r0,[sp,#0]            ;251
000050  1bf6              SUBS     r6,r6,r7              ;252
000052  68a0              LDR      r0,[r4,#8]            ;253
000054  9900              LDR      r1,[sp,#0]            ;253
000056  4288              CMP      r0,r1                 ;253
000058  d803              BHI      |L11.98|
00005a  68a0              LDR      r0,[r4,#8]            ;254
00005c  9900              LDR      r1,[sp,#0]            ;254
00005e  1a08              SUBS     r0,r1,r0              ;254
000060  9000              STR      r0,[sp,#0]            ;254
                  |L11.98|
000062  42ae              CMP      r6,r5                 ;258
000064  d201              BCS      |L11.106|
000066  4630              MOV      r0,r6                 ;258
000068  e000              B        |L11.108|
                  |L11.106|
00006a  4628              MOV      r0,r5                 ;258
                  |L11.108|
00006c  4605              MOV      r5,r0                 ;258
00006e  b90d              CBNZ     r5,|L11.116|
000070  2000              MOVS     r0,#0                 ;260
000072  e7de              B        |L11.50|
                  |L11.116|
000074  68a0              LDR      r0,[r4,#8]            ;264
000076  9900              LDR      r1,[sp,#0]            ;264
000078  1a40              SUBS     r0,r0,r1              ;264
00007a  42a8              CMP      r0,r5                 ;264
00007c  d203              BCS      |L11.134|
00007e  68a0              LDR      r0,[r4,#8]            ;264
000080  9900              LDR      r1,[sp,#0]            ;264
000082  1a40              SUBS     r0,r0,r1              ;264
000084  e000              B        |L11.136|
                  |L11.134|
000086  4628              MOV      r0,r5                 ;264
                  |L11.136|
000088  4680              MOV      r8,r0                 ;264
00008a  6860              LDR      r0,[r4,#4]            ;265
00008c  9a00              LDR      r2,[sp,#0]            ;265
00008e  1881              ADDS     r1,r0,r2              ;265
000090  4642              MOV      r2,r8                 ;265
000092  4650              MOV      r0,r10                ;265
000094  f7fffffe          BL       __aeabi_memcpy
000098  eba50508          SUB      r5,r5,r8              ;266
00009c  b12d              CBZ      r5,|L11.170|
00009e  eb0a0008          ADD      r0,r10,r8             ;270
0000a2  462a              MOV      r2,r5                 ;270
0000a4  6861              LDR      r1,[r4,#4]            ;270
0000a6  f7fffffe          BL       __aeabi_memcpy
                  |L11.170|
0000aa  eb080005          ADD      r0,r8,r5              ;272
0000ae  e7c0              B        |L11.50|
;;;274    
                          ENDP

                  |L11.176|
                          DCD      0xdeadbeef

                          AREA ||i.lwrb_read||, CODE, READONLY, ALIGN=2

                  lwrb_read PROC
;;;179    size_t
;;;180    lwrb_read(lwrb_t* buff, void* data, size_t btr) {
000000  e92d43f8          PUSH     {r3-r9,lr}
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;181        size_t tocopy, full;
;;;182        volatile size_t buff_r_ptr;
;;;183        uint8_t* d = data;
00000a  46b9              MOV      r9,r7
;;;184    
;;;185        if (!BUF_IS_VALID(buff) || data == NULL || btr == 0) {
00000c  b16c              CBZ      r4,|L12.42|
00000e  4928              LDR      r1,|L12.176|
000010  6820              LDR      r0,[r4,#0]
000012  4288              CMP      r0,r1
000014  d109              BNE      |L12.42|
000016  43c9              MVNS     r1,r1
000018  69a0              LDR      r0,[r4,#0x18]
00001a  4288              CMP      r0,r1
00001c  d105              BNE      |L12.42|
00001e  6860              LDR      r0,[r4,#4]
000020  b118              CBZ      r0,|L12.42|
000022  68a0              LDR      r0,[r4,#8]
000024  b108              CBZ      r0,|L12.42|
000026  b107              CBZ      r7,|L12.42|
000028  b915              CBNZ     r5,|L12.48|
                  |L12.42|
;;;186            return 0;
00002a  2000              MOVS     r0,#0
                  |L12.44|
;;;187        }
;;;188    
;;;189        /* Calculate maximum number of bytes available to read */
;;;190        full = lwrb_get_full(buff);
;;;191        btr = BUF_MIN(full, btr);
;;;192        if (btr == 0) {
;;;193            return 0;
;;;194        }
;;;195    
;;;196        /* Step 1: Read data from linear part of buffer */
;;;197        buff_r_ptr = buff->r;
;;;198        tocopy = BUF_MIN(buff->size - buff_r_ptr, btr);
;;;199        BUF_MEMCPY(d, &buff->buff[buff_r_ptr], tocopy);
;;;200        buff_r_ptr += tocopy;
;;;201        btr -= tocopy;
;;;202    
;;;203        /* Step 2: Read data from beginning of buffer (overflow part) */
;;;204        if (btr > 0) {
;;;205            BUF_MEMCPY(&d[tocopy], buff->buff, btr);
;;;206            buff_r_ptr = btr;
;;;207        }
;;;208    
;;;209        /* Step 3: Check end of buffer */
;;;210        if (buff_r_ptr >= buff->size) {
;;;211            buff_r_ptr = 0;
;;;212        }
;;;213    
;;;214        /*
;;;215         * Write final value to the actual running variable.
;;;216         * This is to ensure no write operation can access intermediate data
;;;217         */
;;;218        buff->r = buff_r_ptr;
;;;219    
;;;220        BUF_SEND_EVT(buff, LWRB_EVT_READ, tocopy + btr);
;;;221        return tocopy + btr;
;;;222    }
00002c  e8bd83f8          POP      {r3-r9,pc}
                  |L12.48|
000030  4620              MOV      r0,r4                 ;190
000032  f7fffffe          BL       lwrb_get_full
000036  4680              MOV      r8,r0                 ;190
000038  45a8              CMP      r8,r5                 ;191
00003a  d201              BCS      |L12.64|
00003c  4640              MOV      r0,r8                 ;191
00003e  e000              B        |L12.66|
                  |L12.64|
000040  4628              MOV      r0,r5                 ;191
                  |L12.66|
000042  4605              MOV      r5,r0                 ;191
000044  b90d              CBNZ     r5,|L12.74|
000046  2000              MOVS     r0,#0                 ;193
000048  e7f0              B        |L12.44|
                  |L12.74|
00004a  68e0              LDR      r0,[r4,#0xc]          ;197
00004c  9000              STR      r0,[sp,#0]            ;197
00004e  68a0              LDR      r0,[r4,#8]            ;198
000050  9900              LDR      r1,[sp,#0]            ;198
000052  1a40              SUBS     r0,r0,r1              ;198
000054  42a8              CMP      r0,r5                 ;198
000056  d203              BCS      |L12.96|
000058  68a0              LDR      r0,[r4,#8]            ;198
00005a  9900              LDR      r1,[sp,#0]            ;198
00005c  1a40              SUBS     r0,r0,r1              ;198
00005e  e000              B        |L12.98|
                  |L12.96|
000060  4628              MOV      r0,r5                 ;198
                  |L12.98|
000062  4606              MOV      r6,r0                 ;198
000064  6860              LDR      r0,[r4,#4]            ;199
000066  9a00              LDR      r2,[sp,#0]            ;199
000068  1881              ADDS     r1,r0,r2              ;199
00006a  4632              MOV      r2,r6                 ;199
00006c  4648              MOV      r0,r9                 ;199
00006e  f7fffffe          BL       __aeabi_memcpy
000072  9800              LDR      r0,[sp,#0]            ;200
000074  4430              ADD      r0,r0,r6              ;200
000076  9000              STR      r0,[sp,#0]            ;200
000078  1bad              SUBS     r5,r5,r6              ;201
00007a  b135              CBZ      r5,|L12.138|
00007c  eb090006          ADD      r0,r9,r6              ;205
000080  462a              MOV      r2,r5                 ;205
000082  6861              LDR      r1,[r4,#4]            ;205
000084  f7fffffe          BL       __aeabi_memcpy
000088  9500              STR      r5,[sp,#0]            ;206
                  |L12.138|
00008a  68a0              LDR      r0,[r4,#8]            ;210
00008c  9900              LDR      r1,[sp,#0]            ;210
00008e  4288              CMP      r0,r1                 ;210
000090  d801              BHI      |L12.150|
000092  2000              MOVS     r0,#0                 ;211
000094  9000              STR      r0,[sp,#0]            ;211
                  |L12.150|
000096  9800              LDR      r0,[sp,#0]            ;218
000098  60e0              STR      r0,[r4,#0xc]          ;218
00009a  bf00              NOP                            ;220
00009c  6960              LDR      r0,[r4,#0x14]         ;220
00009e  b120              CBZ      r0,|L12.170|
0000a0  1972              ADDS     r2,r6,r5              ;220
0000a2  2100              MOVS     r1,#0                 ;220
0000a4  4620              MOV      r0,r4                 ;220
0000a6  6963              LDR      r3,[r4,#0x14]         ;220
0000a8  4798              BLX      r3                    ;220
                  |L12.170|
0000aa  bf00              NOP                            ;220
0000ac  1970              ADDS     r0,r6,r5              ;221
0000ae  e7bd              B        |L12.44|
;;;223    
                          ENDP

                  |L12.176|
                          DCD      0xdeadbeef

                          AREA ||i.lwrb_reset||, CODE, READONLY, ALIGN=2

                  lwrb_reset PROC
;;;337    void
;;;338    lwrb_reset(lwrb_t* buff) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;339        if (BUF_IS_VALID(buff)) {
000004  b1bc              CBZ      r4,|L13.54|
000006  490c              LDR      r1,|L13.56|
000008  6820              LDR      r0,[r4,#0]
00000a  4288              CMP      r0,r1
00000c  d113              BNE      |L13.54|
00000e  43c9              MVNS     r1,r1
000010  69a0              LDR      r0,[r4,#0x18]
000012  4288              CMP      r0,r1
000014  d10f              BNE      |L13.54|
000016  6860              LDR      r0,[r4,#4]
000018  b168              CBZ      r0,|L13.54|
00001a  68a0              LDR      r0,[r4,#8]
00001c  b158              CBZ      r0,|L13.54|
;;;340            buff->w = 0;
00001e  2000              MOVS     r0,#0
000020  6120              STR      r0,[r4,#0x10]
;;;341            buff->r = 0;
000022  60e0              STR      r0,[r4,#0xc]
;;;342            BUF_SEND_EVT(buff, LWRB_EVT_RESET, 0);
000024  bf00              NOP      
000026  6960              LDR      r0,[r4,#0x14]
000028  b120              CBZ      r0,|L13.52|
00002a  2200              MOVS     r2,#0
00002c  2102              MOVS     r1,#2
00002e  4620              MOV      r0,r4
000030  6963              LDR      r3,[r4,#0x14]
000032  4798              BLX      r3
                  |L13.52|
000034  bf00              NOP      
                  |L13.54|
;;;343        }
;;;344    }
000036  bd10              POP      {r4,pc}
;;;345    
                          ENDP

                  |L13.56|
                          DCD      0xdeadbeef

                          AREA ||i.lwrb_set_evt_fn||, CODE, READONLY, ALIGN=2

                  lwrb_set_evt_fn PROC
;;;107    void
;;;108    lwrb_set_evt_fn(lwrb_t* buff, lwrb_evt_fn evt_fn) {
000000  b160              CBZ      r0,|L14.28|
;;;109        if (BUF_IS_VALID(buff)) {
000002  4b07              LDR      r3,|L14.32|
000004  6802              LDR      r2,[r0,#0]
000006  429a              CMP      r2,r3
000008  d108              BNE      |L14.28|
00000a  43db              MVNS     r3,r3
00000c  6982              LDR      r2,[r0,#0x18]
00000e  429a              CMP      r2,r3
000010  d104              BNE      |L14.28|
000012  6842              LDR      r2,[r0,#4]
000014  b112              CBZ      r2,|L14.28|
000016  6882              LDR      r2,[r0,#8]
000018  b102              CBZ      r2,|L14.28|
;;;110            buff->evt_fn = evt_fn;
00001a  6141              STR      r1,[r0,#0x14]
                  |L14.28|
;;;111        }
;;;112    }
00001c  4770              BX       lr
;;;113    
                          ENDP

00001e  0000              DCW      0x0000
                  |L14.32|
                          DCD      0xdeadbeef

                          AREA ||i.lwrb_skip||, CODE, READONLY, ALIGN=2

                  lwrb_skip PROC
;;;395    size_t
;;;396    lwrb_skip(lwrb_t* buff, size_t len) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;397        size_t full;
;;;398        volatile size_t r;
;;;399    
;;;400        if (!BUF_IS_VALID(buff) || len == 0) {
000006  b164              CBZ      r4,|L15.34|
000008  4918              LDR      r1,|L15.108|
00000a  6820              LDR      r0,[r4,#0]
00000c  4288              CMP      r0,r1
00000e  d108              BNE      |L15.34|
000010  43c9              MVNS     r1,r1
000012  69a0              LDR      r0,[r4,#0x18]
000014  4288              CMP      r0,r1
000016  d104              BNE      |L15.34|
000018  6860              LDR      r0,[r4,#4]
00001a  b110              CBZ      r0,|L15.34|
00001c  68a0              LDR      r0,[r4,#8]
00001e  b100              CBZ      r0,|L15.34|
000020  b90d              CBNZ     r5,|L15.38|
                  |L15.34|
;;;401            return 0;
000022  2000              MOVS     r0,#0
                  |L15.36|
;;;402        }
;;;403    
;;;404        full = lwrb_get_full(buff);
;;;405        len = BUF_MIN(len, full);
;;;406        r = buff->r + len;
;;;407        if (r >= buff->size) {
;;;408            r -= buff->size;
;;;409        }
;;;410        buff->r = r;
;;;411        BUF_SEND_EVT(buff, LWRB_EVT_READ, len);
;;;412        return len;
;;;413    }
000024  bdf8              POP      {r3-r7,pc}
                  |L15.38|
000026  4620              MOV      r0,r4                 ;404
000028  f7fffffe          BL       lwrb_get_full
00002c  4606              MOV      r6,r0                 ;404
00002e  42b5              CMP      r5,r6                 ;405
000030  d201              BCS      |L15.54|
000032  4628              MOV      r0,r5                 ;405
000034  e000              B        |L15.56|
                  |L15.54|
000036  4630              MOV      r0,r6                 ;405
                  |L15.56|
000038  4605              MOV      r5,r0                 ;405
00003a  68e0              LDR      r0,[r4,#0xc]          ;406
00003c  4428              ADD      r0,r0,r5              ;406
00003e  9000              STR      r0,[sp,#0]            ;406
000040  68a0              LDR      r0,[r4,#8]            ;407
000042  9900              LDR      r1,[sp,#0]            ;407
000044  4288              CMP      r0,r1                 ;407
000046  d803              BHI      |L15.80|
000048  68a0              LDR      r0,[r4,#8]            ;408
00004a  9900              LDR      r1,[sp,#0]            ;408
00004c  1a08              SUBS     r0,r1,r0              ;408
00004e  9000              STR      r0,[sp,#0]            ;408
                  |L15.80|
000050  9800              LDR      r0,[sp,#0]            ;410
000052  60e0              STR      r0,[r4,#0xc]          ;410
000054  bf00              NOP                            ;411
000056  6960              LDR      r0,[r4,#0x14]         ;411
000058  b120              CBZ      r0,|L15.100|
00005a  462a              MOV      r2,r5                 ;411
00005c  2100              MOVS     r1,#0                 ;411
00005e  4620              MOV      r0,r4                 ;411
000060  6963              LDR      r3,[r4,#0x14]         ;411
000062  4798              BLX      r3                    ;411
                  |L15.100|
000064  bf00              NOP                            ;411
000066  4628              MOV      r0,r5                 ;412
000068  e7dc              B        |L15.36|
;;;414    
                          ENDP

00006a  0000              DCW      0x0000
                  |L15.108|
                          DCD      0xdeadbeef

                          AREA ||i.lwrb_write||, CODE, READONLY, ALIGN=2

                  lwrb_write PROC
;;;125    size_t
;;;126    lwrb_write(lwrb_t* buff, const void* data, size_t btw) {
000000  e92d43f8          PUSH     {r3-r9,lr}
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;127        size_t tocopy, free;
;;;128        volatile size_t buff_w_ptr;
;;;129        const uint8_t* d = data;
00000a  46b9              MOV      r9,r7
;;;130    
;;;131        if (!BUF_IS_VALID(buff) || data == NULL || btw == 0) {
00000c  b16c              CBZ      r4,|L16.42|
00000e  4928              LDR      r1,|L16.176|
000010  6820              LDR      r0,[r4,#0]
000012  4288              CMP      r0,r1
000014  d109              BNE      |L16.42|
000016  43c9              MVNS     r1,r1
000018  69a0              LDR      r0,[r4,#0x18]
00001a  4288              CMP      r0,r1
00001c  d105              BNE      |L16.42|
00001e  6860              LDR      r0,[r4,#4]
000020  b118              CBZ      r0,|L16.42|
000022  68a0              LDR      r0,[r4,#8]
000024  b108              CBZ      r0,|L16.42|
000026  b107              CBZ      r7,|L16.42|
000028  b915              CBNZ     r5,|L16.48|
                  |L16.42|
;;;132            return 0;
00002a  2000              MOVS     r0,#0
                  |L16.44|
;;;133        }
;;;134    
;;;135        /* Calculate maximum number of bytes available to write */
;;;136        free = lwrb_get_free(buff);
;;;137        btw = BUF_MIN(free, btw);
;;;138        if (btw == 0) {
;;;139            return 0;
;;;140        }
;;;141    
;;;142        /* Step 1: Write data to linear part of buffer */
;;;143        buff_w_ptr = buff->w;
;;;144        tocopy = BUF_MIN(buff->size - buff_w_ptr, btw);
;;;145        BUF_MEMCPY(&buff->buff[buff_w_ptr], d, tocopy);
;;;146        buff_w_ptr += tocopy;
;;;147        btw -= tocopy;
;;;148    
;;;149        /* Step 2: Write data to beginning of buffer (overflow part) */
;;;150        if (btw > 0) {
;;;151            BUF_MEMCPY(buff->buff, &d[tocopy], btw);
;;;152            buff_w_ptr = btw;
;;;153        }
;;;154    
;;;155        /* Step 3: Check end of buffer */
;;;156        if (buff_w_ptr >= buff->size) {
;;;157            buff_w_ptr = 0;
;;;158        }
;;;159    
;;;160        /*
;;;161         * Write final value to the actual running variable.
;;;162         * This is to ensure no read operation can access intermediate data
;;;163         */
;;;164        buff->w = buff_w_ptr;
;;;165        
;;;166        BUF_SEND_EVT(buff, LWRB_EVT_WRITE, tocopy + btw);
;;;167        return tocopy + btw;
;;;168    }
00002c  e8bd83f8          POP      {r3-r9,pc}
                  |L16.48|
000030  4620              MOV      r0,r4                 ;136
000032  f7fffffe          BL       lwrb_get_free
000036  4680              MOV      r8,r0                 ;136
000038  45a8              CMP      r8,r5                 ;137
00003a  d201              BCS      |L16.64|
00003c  4640              MOV      r0,r8                 ;137
00003e  e000              B        |L16.66|
                  |L16.64|
000040  4628              MOV      r0,r5                 ;137
                  |L16.66|
000042  4605              MOV      r5,r0                 ;137
000044  b90d              CBNZ     r5,|L16.74|
000046  2000              MOVS     r0,#0                 ;139
000048  e7f0              B        |L16.44|
                  |L16.74|
00004a  6920              LDR      r0,[r4,#0x10]         ;143
00004c  9000              STR      r0,[sp,#0]            ;143
00004e  68a0              LDR      r0,[r4,#8]            ;144
000050  9900              LDR      r1,[sp,#0]            ;144
000052  1a40              SUBS     r0,r0,r1              ;144
000054  42a8              CMP      r0,r5                 ;144
000056  d203              BCS      |L16.96|
000058  68a0              LDR      r0,[r4,#8]            ;144
00005a  9900              LDR      r1,[sp,#0]            ;144
00005c  1a40              SUBS     r0,r0,r1              ;144
00005e  e000              B        |L16.98|
                  |L16.96|
000060  4628              MOV      r0,r5                 ;144
                  |L16.98|
000062  4606              MOV      r6,r0                 ;144
000064  6861              LDR      r1,[r4,#4]            ;145
000066  9a00              LDR      r2,[sp,#0]            ;145
000068  1888              ADDS     r0,r1,r2              ;145
00006a  4632              MOV      r2,r6                 ;145
00006c  4649              MOV      r1,r9                 ;145
00006e  f7fffffe          BL       __aeabi_memcpy
000072  9800              LDR      r0,[sp,#0]            ;146
000074  4430              ADD      r0,r0,r6              ;146
000076  9000              STR      r0,[sp,#0]            ;146
000078  1bad              SUBS     r5,r5,r6              ;147
00007a  b135              CBZ      r5,|L16.138|
00007c  eb090106          ADD      r1,r9,r6              ;151
000080  462a              MOV      r2,r5                 ;151
000082  6860              LDR      r0,[r4,#4]            ;151
000084  f7fffffe          BL       __aeabi_memcpy
000088  9500              STR      r5,[sp,#0]            ;152
                  |L16.138|
00008a  68a0              LDR      r0,[r4,#8]            ;156
00008c  9900              LDR      r1,[sp,#0]            ;156
00008e  4288              CMP      r0,r1                 ;156
000090  d801              BHI      |L16.150|
000092  2000              MOVS     r0,#0                 ;157
000094  9000              STR      r0,[sp,#0]            ;157
                  |L16.150|
000096  9800              LDR      r0,[sp,#0]            ;164
000098  6120              STR      r0,[r4,#0x10]         ;164
00009a  bf00              NOP                            ;166
00009c  6960              LDR      r0,[r4,#0x14]         ;166
00009e  b120              CBZ      r0,|L16.170|
0000a0  1972              ADDS     r2,r6,r5              ;166
0000a2  2101              MOVS     r1,#1                 ;166
0000a4  4620              MOV      r0,r4                 ;166
0000a6  6963              LDR      r3,[r4,#0x14]         ;166
0000a8  4798              BLX      r3                    ;166
                  |L16.170|
0000aa  bf00              NOP                            ;166
0000ac  1970              ADDS     r0,r6,r5              ;167
0000ae  e7bd              B        |L16.44|
;;;169    
                          ENDP

                  |L16.176|
                          DCD      0xdeadbeef
