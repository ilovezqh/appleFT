; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\flash\obj\test_pmu.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\test_pmu.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\User -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\User\FatFS\src -I..\..\Libraries\STM32_USB_Device_Library\Class\msc\inc -I..\..\Libraries\STM32_USB_Device_Library\Core\inc -I..\..\Libraries\STM32_USB_OTG_Driver\inc -I..\..\User\usbd_mass_storage -I..\..\User\ft_support -I..\..\User\test -I..\..\User\emenu -I..\..\User\chip_ft -I..\..\User\lwrb -I..\..\User\easylogger\inc -I..\..\User\easylogger\plugins\file -I..\..\User\LOG -I..\..\User\MultiButton-1.1.0 -I..\..\User\cm_backtrace -I..\..\User\MultiTimer -I.\RTE\_Flash -IC:\Users\qizha\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\qizha\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.17.1\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F407xx -D_RTE_ -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY --signed_chars --omf_browse=.\flash\obj\test_pmu.crf ..\..\User\chip_ft\test_pmu.c]
                          THUMB

                          AREA ||i.iref_get||, CODE, READONLY, ALIGN=2

                  iref_get PROC
;;;346    
;;;347    static uint32_t iref_get(void)
000000  b570              PUSH     {r4-r6,lr}
;;;348    {
;;;349        uint32_t adc_sum=0;
000002  2400              MOVS     r4,#0
;;;350        for(uint8_t i=0; i<128; i++)
000004  2600              MOVS     r6,#0
000006  e007              B        |L1.24|
                  |L1.8|
;;;351        {
;;;352            delay_ms(1);
000008  2001              MOVS     r0,#1
00000a  f7fffffe          BL       bsp_DelayMS
;;;353            adc_sum += g_adc_value[ ADC_RANK_IREF];
00000e  4809              LDR      r0,|L1.52|
000010  8840              LDRH     r0,[r0,#2]  ; g_adc_value
000012  4404              ADD      r4,r4,r0
000014  1c70              ADDS     r0,r6,#1              ;350
000016  b2c6              UXTB     r6,r0                 ;350
                  |L1.24|
000018  2e80              CMP      r6,#0x80              ;350
00001a  dbf5              BLT      |L1.8|
;;;354        }
;;;355    
;;;356        uint32_t iref_200k_volt = adc_sum/128 * 3300 / 4095;
00001c  09e0              LSRS     r0,r4,#7
00001e  f64041e4          MOV      r1,#0xce4
000022  4348              MULS     r0,r1,r0
000024  f64071ff          MOV      r1,#0xfff
000028  fbb0f5f1          UDIV     r5,r0,r1
;;;357       
;;;358        #if 0
;;;359        return iref_200k_volt/20;  //200K 取样电压跟随
;;;360        #else
;;;361        return iref_200k_volt/36; //I-V 双电源供电
00002c  2024              MOVS     r0,#0x24
00002e  fbb5f0f0          UDIV     r0,r5,r0
;;;362        #endif
;;;363        
;;;364    }
000032  bd70              POP      {r4-r6,pc}
                          ENDP

                  |L1.52|
                          DCD      g_adc_value

                          AREA ||i.iref_trim||, CODE, READONLY, ALIGN=2

                  iref_trim PROC
;;;119    
;;;120    static fsm_rt_t iref_trim(void)
000000  b530              PUSH     {r4,r5,lr}
;;;121    {
000002  b085              SUB      sp,sp,#0x14
;;;122        volt_search_t volt_search;
;;;123      
;;;124        set_apple_debug_out(ITEM_IREF);	            //IREF电流注入GPIO03
000004  2001              MOVS     r0,#1
000006  f7fffffe          BL       set_apple_debug_out
;;;125        delay_ms(50);
00000a  2032              MOVS     r0,#0x32
00000c  f7fffffe          BL       bsp_DelayMS
;;;126        default_measure.irefCurrent = iref_get();
000010  f7fffffe          BL       iref_get
000014  491b              LDR      r1,|L2.132|
000016  6008              STR      r0,[r1,#0]  ; default_measure
;;;127    
;;;128        volt_search.tar          = IREF_TAR;
000018  2032              MOVS     r0,#0x32
00001a  9000              STR      r0,[sp,#0]
;;;129        volt_search.trim_val_set = iref_trim_set;
00001c  481a              LDR      r0,|L2.136|
00001e  9001              STR      r0,[sp,#4]
;;;130        volt_search.dir          = 1;//trim值越大，电压越大
000020  2001              MOVS     r0,#1
000022  f88d0011          STRB     r0,[sp,#0x11]
;;;131        volt_search.trim_val_low = IREF_TRIM_LO;
000026  2004              MOVS     r0,#4
000028  f88d0008          STRB     r0,[sp,#8]
;;;132        volt_search.trim_val_hi  = IREF_TRIM_HI;
00002c  2005              MOVS     r0,#5
00002e  f88d0009          STRB     r0,[sp,#9]
;;;133        
;;;134        volt_binary_search(&volt_search); //换一个trim值区间 继续二分法查找
000032  4668              MOV      r0,sp
000034  f7fffffe          BL       volt_binary_search
;;;135        
;;;136        if((volt_search.best_trim_volt <= IREF_HI)  && (volt_search.best_trim_volt >= IREF_LO))
000038  9803              LDR      r0,[sp,#0xc]
00003a  2837              CMP      r0,#0x37
00003c  d810              BHI      |L2.96|
00003e  9803              LDR      r0,[sp,#0xc]
000040  282d              CMP      r0,#0x2d
000042  d30d              BCC      |L2.96|
;;;137        {
;;;138            trim_reg_data.iref_f         = volt_search.best_trim_val;
000044  f89d1010          LDRB     r1,[sp,#0x10]
000048  4810              LDR      r0,|L2.140|
00004a  6800              LDR      r0,[r0,#0]  ; trim_reg_data
00004c  f3614053          BFI      r0,r1,#17,#3
000050  490e              LDR      r1,|L2.140|
000052  6008              STR      r0,[r1,#0]  ; trim_reg_data
;;;139            trim_measure.irefCurrent     = volt_search.best_trim_volt ;
000054  490e              LDR      r1,|L2.144|
000056  9803              LDR      r0,[sp,#0xc]
000058  6008              STR      r0,[r1,#0]  ; trim_measure
;;;140           
;;;141            return fsm_rt_cpl;
00005a  2000              MOVS     r0,#0
                  |L2.92|
;;;142        }
;;;143        else
;;;144        {
;;;145          
;;;146            logging("fail iref:%d,%d.%duA\r\n",volt_search.best_trim_volt/10,volt_search.best_trim_volt%10);
;;;147         
;;;148            return fsm_rt_err_iref;
;;;149            
;;;150        }
;;;151    }
00005c  b005              ADD      sp,sp,#0x14
00005e  bd30              POP      {r4,r5,pc}
                  |L2.96|
000060  210a              MOVS     r1,#0xa               ;146
000062  9803              LDR      r0,[sp,#0xc]          ;146
000064  fbb0f2f1          UDIV     r2,r0,r1              ;146
000068  fb010412          MLS      r4,r1,r2,r0           ;146
00006c  fbb0f5f1          UDIV     r5,r0,r1              ;146
000070  4623              MOV      r3,r4                 ;146
000072  462a              MOV      r2,r5                 ;146
000074  4807              LDR      r0,|L2.148|
000076  6801              LDR      r1,[r0,#0]            ;146  ; g_iRunTime
000078  a007              ADR      r0,|L2.152|
00007a  f7fffffe          BL       logger_buffer_write
00007e  f06f0014          MVN      r0,#0x14              ;148
000082  e7eb              B        |L2.92|
;;;152    
                          ENDP

                  |L2.132|
                          DCD      default_measure
                  |L2.136|
                          DCD      iref_trim_set
                  |L2.140|
                          DCD      trim_reg_data
                  |L2.144|
                          DCD      trim_measure
                  |L2.148|
                          DCD      g_iRunTime
                  |L2.152|
000098  5b253864          DCB      "[%8d]fail iref:%d,%d.%duA\r\n",0
00009c  5d666169
0000a0  6c206972
0000a4  65663a25
0000a8  642c2564
0000ac  2e256475
0000b0  410d0a00

                          AREA ||i.iref_trim_set||, CODE, READONLY, ALIGN=1

                  iref_trim_set PROC
;;;110    //设置trim值，返回电压
;;;111    static uint32_t iref_trim_set(uint8_t val)
000000  b510              PUSH     {r4,lr}
;;;112    {
000002  4604              MOV      r4,r0
;;;113        //apple_prst();
;;;114        //set_apple_debug_out(ITEM_IREF);	            //VREF电压注入GPIO03
;;;115        set_apple_trim_value(ITEM_IREF, val);
000004  4621              MOV      r1,r4
000006  2001              MOVS     r0,#1
000008  f7fffffe          BL       set_apple_trim_value
;;;116        delay_ms(2);
00000c  2002              MOVS     r0,#2
00000e  f7fffffe          BL       bsp_DelayMS
;;;117        return iref_get();
000012  f7fffffe          BL       iref_get
;;;118    }
000016  bd10              POP      {r4,pc}
;;;119    
                          ENDP


                          AREA ||i.lpvdd_trim||, CODE, READONLY, ALIGN=2

                  lpvdd_trim PROC
;;;228    
;;;229    static fsm_rt_t lpvdd_trim(void)
000000  b500              PUSH     {lr}
;;;230    {
000002  b085              SUB      sp,sp,#0x14
;;;231        volt_search_t volt_search;
;;;232     
;;;233        //apple_prst();
;;;234        //set_apple_trim_value(ITEM_VBG,BGR_FIX_VAL);       
;;;235        //set_apple_trim_value(ITEM_VREF, trim_reg_data.vref_f);   //写入最佳trim值     
;;;236        set_apple_debug_out(ITEM_LPVDD);	                                        //VREF电压注入GPIO03
000004  2004              MOVS     r0,#4
000006  f7fffffe          BL       set_apple_debug_out
;;;237        set_apple_work_state(STANDBY);
00000a  2002              MOVS     r0,#2
00000c  f7fffffe          BL       set_apple_work_state
;;;238        delay_ms(2);
000010  2002              MOVS     r0,#2
000012  f7fffffe          BL       bsp_DelayMS
;;;239        default_measure.lpvddVolt = pmu_volt_get();
000016  f7fffffe          BL       pmu_volt_get
00001a  491a              LDR      r1,|L4.132|
00001c  60c8              STR      r0,[r1,#0xc]  ; default_measure
;;;240        volt_search.tar          = LPVDD_TAR;
00001e  f24050dc          MOV      r0,#0x5dc
000022  9000              STR      r0,[sp,#0]
;;;241        volt_search.trim_val_set = lpvdd_trim_set;
000024  4818              LDR      r0,|L4.136|
000026  9001              STR      r0,[sp,#4]
;;;242        volt_search.dir          = 0;//trim值越大，电压越小
000028  2000              MOVS     r0,#0
00002a  f88d0011          STRB     r0,[sp,#0x11]
;;;243        volt_search.trim_val_low = LPVDD_TRIM_LO;
00002e  f88d0008          STRB     r0,[sp,#8]
;;;244        volt_search.trim_val_hi  = LPVDD_TRIM_HI;
000032  2007              MOVS     r0,#7
000034  f88d0009          STRB     r0,[sp,#9]
;;;245        
;;;246        volt_binary_search(&volt_search); //换一个trim值区间 继续二分法查找
000038  4668              MOV      r0,sp
00003a  f7fffffe          BL       volt_binary_search
;;;247        
;;;248        if((volt_search.best_trim_volt <= LPVDD_HI)  && (volt_search.best_trim_volt >= LPVDD_LO))
00003e  9803              LDR      r0,[sp,#0xc]
000040  f5b06fc5          CMP      r0,#0x628
000044  d211              BCS      |L4.106|
000046  9803              LDR      r0,[sp,#0xc]
000048  f5b06fb2          CMP      r0,#0x590
00004c  d90d              BLS      |L4.106|
;;;249        {
;;;250            trim_reg_data.lpvdd_f  = volt_search.best_trim_val;
00004e  f89d1010          LDRB     r1,[sp,#0x10]
000052  480e              LDR      r0,|L4.140|
000054  6800              LDR      r0,[r0,#0]  ; trim_reg_data
000056  f3610043          BFI      r0,r1,#1,#3
00005a  490c              LDR      r1,|L4.140|
00005c  6008              STR      r0,[r1,#0]  ; trim_reg_data
;;;251            trim_measure.lpvddVolt = volt_search.best_trim_volt;
00005e  490c              LDR      r1,|L4.144|
000060  9803              LDR      r0,[sp,#0xc]
000062  60c8              STR      r0,[r1,#0xc]  ; trim_measure
;;;252            
;;;253            return fsm_rt_cpl;
000064  2000              MOVS     r0,#0
                  |L4.102|
;;;254        }
;;;255        else
;;;256        {
;;;257            logging("fail vref:%d,%dmv\r\n",volt_search.best_trim_val*2, volt_search.best_trim_volt);
;;;258            return fsm_rt_err_lpv;
;;;259        }
;;;260    }
000066  b005              ADD      sp,sp,#0x14
000068  bd00              POP      {pc}
                  |L4.106|
00006a  f89d0010          LDRB     r0,[sp,#0x10]         ;257
00006e  0042              LSLS     r2,r0,#1              ;257
000070  4808              LDR      r0,|L4.148|
000072  9b03              LDR      r3,[sp,#0xc]          ;257
000074  6801              LDR      r1,[r0,#0]            ;257  ; g_iRunTime
000076  a008              ADR      r0,|L4.152|
000078  f7fffffe          BL       logger_buffer_write
00007c  f06f002c          MVN      r0,#0x2c              ;258
000080  e7f1              B        |L4.102|
;;;261     
                          ENDP

000082  0000              DCW      0x0000
                  |L4.132|
                          DCD      default_measure
                  |L4.136|
                          DCD      lpvdd_trim_set
                  |L4.140|
                          DCD      trim_reg_data
                  |L4.144|
                          DCD      trim_measure
                  |L4.148|
                          DCD      g_iRunTime
                  |L4.152|
000098  5b253864          DCB      "[%8d]fail vref:%d,%dmv\r\n",0
00009c  5d666169
0000a0  6c207672
0000a4  65663a25
0000a8  642c2564
0000ac  6d760d0a
0000b0  00      
0000b1  00                DCB      0
0000b2  00                DCB      0
0000b3  00                DCB      0

                          AREA ||i.lpvdd_trim_set||, CODE, READONLY, ALIGN=2

                  lpvdd_trim_set PROC
;;;215    //设置trim值，返回电压
;;;216    static uint32_t lpvdd_trim_set(uint8_t val)
000000  b510              PUSH     {r4,lr}
;;;217    {
000002  4604              MOV      r4,r0
;;;218        apple_prst();
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       socket_prst_ctl
00000a  200a              MOVS     r0,#0xa
00000c  f7fffffe          BL       bsp_DelayMS
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       socket_prst_ctl
000016  200a              MOVS     r0,#0xa
000018  f7fffffe          BL       bsp_DelayMS
;;;219        //delay_ms(10);
;;;220        //set_apple_trim_value(ITEM_VBG,BGR_FIX_VAL); 
;;;221        set_apple_trim_value(ITEM_VREF, trim_reg_data.vref_f);   //写入最佳trim值     
00001c  480b              LDR      r0,|L5.76|
00001e  7800              LDRB     r0,[r0,#0]  ; trim_reg_data
000020  f3c01103          UBFX     r1,r0,#4,#4
000024  2002              MOVS     r0,#2
000026  f7fffffe          BL       set_apple_trim_value
;;;222        set_apple_debug_out(ITEM_LPVDD);	                    //VREF电压注入GPIO03
00002a  2004              MOVS     r0,#4
00002c  f7fffffe          BL       set_apple_debug_out
;;;223        set_apple_trim_value(ITEM_LPVDD, val);
000030  4621              MOV      r1,r4
000032  2004              MOVS     r0,#4
000034  f7fffffe          BL       set_apple_trim_value
;;;224        set_apple_work_state(STANDBY);
000038  2002              MOVS     r0,#2
00003a  f7fffffe          BL       set_apple_work_state
;;;225        delay_ms(2);
00003e  2002              MOVS     r0,#2
000040  f7fffffe          BL       bsp_DelayMS
;;;226        return pmu_volt_get();
000044  f7fffffe          BL       pmu_volt_get
;;;227    }
000048  bd10              POP      {r4,pc}
;;;228    
                          ENDP

00004a  0000              DCW      0x0000
                  |L5.76|
                          DCD      trim_reg_data

                          AREA ||i.pmu_volt_get||, CODE, READONLY, ALIGN=2

                  pmu_volt_get PROC
;;;332    //返回电压 mv
;;;333    static uint32_t pmu_volt_get(void)
000000  b570              PUSH     {r4-r6,lr}
;;;334    {
;;;335        uint32_t adc_sum=0;
000002  2400              MOVS     r4,#0
;;;336        for(uint8_t i=0; i<32; i++)
000004  2600              MOVS     r6,#0
000006  e007              B        |L6.24|
                  |L6.8|
;;;337        {
;;;338            delay_us(50);
000008  2032              MOVS     r0,#0x32
00000a  f7fffffe          BL       bsp_DelayUS
;;;339            adc_sum += g_adc_value[ADC_RANK_TRIM_PMU];
00000e  4808              LDR      r0,|L6.48|
000010  8800              LDRH     r0,[r0,#0]  ; g_adc_value
000012  4404              ADD      r4,r4,r0
000014  1c70              ADDS     r0,r6,#1              ;336
000016  b2c6              UXTB     r6,r0                 ;336
                  |L6.24|
000018  2e20              CMP      r6,#0x20              ;336
00001a  dbf5              BLT      |L6.8|
;;;340        }
;;;341    
;;;342        uint32_t pmu_volt = adc_sum/32 * 3300 / 4095;
00001c  0960              LSRS     r0,r4,#5
00001e  f64041e4          MOV      r1,#0xce4
000022  4348              MULS     r0,r1,r0
000024  f64071ff          MOV      r1,#0xfff
000028  fbb0f5f1          UDIV     r5,r0,r1
;;;343       
;;;344        return pmu_volt;
00002c  4628              MOV      r0,r5
;;;345    }
00002e  bd70              POP      {r4-r6,pc}
;;;346    
                          ENDP

                  |L6.48|
                          DCD      g_adc_value

                          AREA ||i.test_pmu||, CODE, READONLY, ALIGN=2

                  test_pmu PROC
;;;26     
;;;27     fsm_rt_t test_pmu(void)
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;28     {
;;;29         static enum
;;;30         {
;;;31             START = 0,
;;;32             IREF_TRIM,
;;;33             VREF_TRIM,  
;;;34             LPV_TRIM,
;;;35         } s_tState = START;
;;;36         
;;;37         fsm_rt_t ret;
;;;38     
;;;39         switch(s_tState)
000004  4852              LDR      r0,|L7.336|
000006  7800              LDRB     r0,[r0,#0]  ; s_tState
000008  b130              CBZ      r0,|L7.24|
00000a  2801              CMP      r0,#1
00000c  d00c              BEQ      |L7.40|
00000e  2802              CMP      r0,#2
000010  d03e              BEQ      |L7.144|
000012  2803              CMP      r0,#3
000014  d13b              BNE      |L7.142|
000016  e05e              B        |L7.214|
                  |L7.24|
;;;40         {
;;;41         case START:
;;;42             {
;;;43                 #if ON_BOARD_FT //在板FT，无法校准IREF项
;;;44                 s_tState = VREF_TRIM;
;;;45                 break;
;;;46                 #else
;;;47                 socket_ivref_iref();
000018  f7fffffe          BL       socket_ivref_iref
;;;48                 //apple_prst();
;;;49                 //uint8_t temp=0x85;//复位寄存器设置：使能debounce,低电平触发，使能上拉，使能复位
;;;50                 //apple_write_addr16(APPLE_DEV_ADDR,&temp,PRST_CTL_REG,1);  
;;;51                 
;;;52                 s_tState++;
00001c  484c              LDR      r0,|L7.336|
00001e  7800              LDRB     r0,[r0,#0]  ; s_tState
000020  1c40              ADDS     r0,r0,#1
000022  494b              LDR      r1,|L7.336|
000024  7008              STRB     r0,[r1,#0]
;;;53                 #endif
;;;54                 
;;;55                 
;;;56             }
;;;57             //break;
;;;58             
;;;59         case IREF_TRIM:
000026  bf00              NOP      
                  |L7.40|
;;;60             {
;;;61                 ret = iref_trim();
000028  f7fffffe          BL       iref_trim
00002c  4604              MOV      r4,r0
;;;62                 if(ret!= fsm_rt_cpl) goto fail;
00002e  b104              CBZ      r4,|L7.50|
000030  e089              B        |L7.326|
                  |L7.50|
;;;63      
;;;64                 set_apple_trim_value(ITEM_IREF, trim_reg_data.iref_f);   //写入最佳trim值 
000032  4848              LDR      r0,|L7.340|
000034  6800              LDR      r0,[r0,#0]  ; trim_reg_data
000036  f3c04142          UBFX     r1,r0,#17,#3
00003a  2001              MOVS     r0,#1
00003c  f7fffffe          BL       set_apple_trim_value
;;;65                 logging("SUCCESS IREF:%d,%d.%duA(%d.%duA)\r\n",trim_reg_data.iref_f, trim_measure.irefCurrent/10,trim_measure.irefCurrent%10,
000040  4845              LDR      r0,|L7.344|
000042  6800              LDR      r0,[r0,#0]  ; default_measure
000044  210a              MOVS     r1,#0xa
000046  fbb0f2f1          UDIV     r2,r0,r1
00004a  fb010512          MLS      r5,r1,r2,r0
00004e  4842              LDR      r0,|L7.344|
000050  6800              LDR      r0,[r0,#0]  ; default_measure
000052  fbb0f6f1          UDIV     r6,r0,r1
000056  4841              LDR      r0,|L7.348|
000058  6800              LDR      r0,[r0,#0]  ; trim_measure
00005a  fbb0f2f1          UDIV     r2,r0,r1
00005e  fb010712          MLS      r7,r1,r2,r0
000062  483e              LDR      r0,|L7.348|
000064  6800              LDR      r0,[r0,#0]  ; trim_measure
000066  fbb0f8f1          UDIV     r8,r0,r1
00006a  483a              LDR      r0,|L7.340|
00006c  e9cd7600          STRD     r7,r6,[sp,#0]
000070  9502              STR      r5,[sp,#8]
000072  6800              LDR      r0,[r0,#0]  ; trim_reg_data
000074  f3c04242          UBFX     r2,r0,#17,#3
000078  4643              MOV      r3,r8
00007a  4839              LDR      r0,|L7.352|
00007c  6801              LDR      r1,[r0,#0]  ; g_iRunTime
00007e  a039              ADR      r0,|L7.356|
000080  f7fffffe          BL       logger_buffer_write
;;;66                                                                               default_measure.irefCurrent/10, default_measure.irefCurrent%10);
;;;67                 socket_ivref_vref();
000084  f7fffffe          BL       socket_ivref_vref
;;;68                 s_tState = VREF_TRIM;    
000088  2002              MOVS     r0,#2
00008a  4931              LDR      r1,|L7.336|
00008c  7008              STRB     r0,[r1,#0]
                  |L7.142|
;;;69             }
;;;70             break;
00008e  e057              B        |L7.320|
                  |L7.144|
;;;71         case VREF_TRIM:
;;;72             {
;;;73                 //apple_prst(); //不复位iref校准会带入脏寄存器值：待排查
;;;74                 //set_apple_trim_value(ITEM_IREF, trim_reg_data.iref_f);   //写入最佳trim值 
;;;75                 
;;;76                 
;;;77                 ret = vref_trim();
000090  f7fffffe          BL       vref_trim
000094  4604              MOV      r4,r0
;;;78                     
;;;79                 if(ret!= fsm_rt_cpl) goto fail;
000096  b104              CBZ      r4,|L7.154|
000098  e055              B        |L7.326|
                  |L7.154|
;;;80                 set_apple_trim_value(ITEM_VREF, trim_reg_data.vref_f);   //写入最佳trim值 
00009a  482e              LDR      r0,|L7.340|
00009c  7800              LDRB     r0,[r0,#0]  ; trim_reg_data
00009e  f3c01103          UBFX     r1,r0,#4,#4
0000a2  2002              MOVS     r0,#2
0000a4  f7fffffe          BL       set_apple_trim_value
;;;81                 
;;;82                 logging("SUCCESS VREF:[%d]%d,%dmv(%dmv)\r\n",trim_reg_data.bgr_f,
0000a8  482b              LDR      r0,|L7.344|
0000aa  6880              LDR      r0,[r0,#8]  ; default_measure
0000ac  492b              LDR      r1,|L7.348|
0000ae  6889              LDR      r1,[r1,#8]  ; trim_measure
0000b0  e9cd1000          STRD     r1,r0,[sp,#0]
0000b4  4827              LDR      r0,|L7.340|
0000b6  7800              LDRB     r0,[r0,#0]  ; trim_reg_data
0000b8  f3c01303          UBFX     r3,r0,#4,#4
0000bc  4825              LDR      r0,|L7.340|
0000be  8800              LDRH     r0,[r0,#0]  ; trim_reg_data
0000c0  f3c02201          UBFX     r2,r0,#8,#2
0000c4  4826              LDR      r0,|L7.352|
0000c6  6801              LDR      r1,[r0,#0]  ; g_iRunTime
0000c8  a030              ADR      r0,|L7.396|
0000ca  f7fffffe          BL       logger_buffer_write
;;;83                                                              trim_reg_data.vref_f, 
;;;84                                                              trim_measure.vrefVolt, default_measure.vrefVolt);
;;;85                 s_tState = LPV_TRIM;    
0000ce  2003              MOVS     r0,#3
0000d0  491f              LDR      r1,|L7.336|
0000d2  7008              STRB     r0,[r1,#0]
;;;86             }
;;;87             //break;
;;;88      
;;;89         case LPV_TRIM:
0000d4  bf00              NOP      
                  |L7.214|
;;;90             {
;;;91                 ret = lpvdd_trim();
0000d6  f7fffffe          BL       lpvdd_trim
0000da  4604              MOV      r4,r0
;;;92                 if(ret!= fsm_rt_cpl) goto fail;
0000dc  b104              CBZ      r4,|L7.224|
0000de  e032              B        |L7.326|
                  |L7.224|
;;;93                 apple_prst();
0000e0  2002              MOVS     r0,#2
0000e2  f7fffffe          BL       socket_prst_ctl
0000e6  200a              MOVS     r0,#0xa
0000e8  f7fffffe          BL       bsp_DelayMS
0000ec  2001              MOVS     r0,#1
0000ee  f7fffffe          BL       socket_prst_ctl
0000f2  200a              MOVS     r0,#0xa
0000f4  f7fffffe          BL       bsp_DelayMS
;;;94                 delay_ms(10);
0000f8  200a              MOVS     r0,#0xa
0000fa  f7fffffe          BL       bsp_DelayMS
;;;95                 set_apple_trim_value(ITEM_LPVDD, trim_reg_data.lpvdd_f);    //写入最佳trim值 
0000fe  4815              LDR      r0,|L7.340|
000100  7800              LDRB     r0,[r0,#0]  ; trim_reg_data
000102  f3c00142          UBFX     r1,r0,#1,#3
000106  2004              MOVS     r0,#4
000108  f7fffffe          BL       set_apple_trim_value
;;;96                 set_apple_trim_value(ITEM_VREF, trim_reg_data.vref_f);      //写入最佳trim值 
00010c  4811              LDR      r0,|L7.340|
00010e  7800              LDRB     r0,[r0,#0]  ; trim_reg_data
000110  f3c01103          UBFX     r1,r0,#4,#4
000114  2002              MOVS     r0,#2
000116  f7fffffe          BL       set_apple_trim_value
;;;97                 logging("SUCCESS LPVDD:%d,%dmv(%dmv)\r\n",trim_reg_data.lpvdd_f, trim_measure.lpvddVolt,default_measure.lpvddVolt);
00011a  480f              LDR      r0,|L7.344|
00011c  68c0              LDR      r0,[r0,#0xc]  ; default_measure
00011e  9000              STR      r0,[sp,#0]
000120  480e              LDR      r0,|L7.348|
000122  68c3              LDR      r3,[r0,#0xc]  ; trim_measure
000124  480b              LDR      r0,|L7.340|
000126  7800              LDRB     r0,[r0,#0]  ; trim_reg_data
000128  f3c00242          UBFX     r2,r0,#1,#3
00012c  480c              LDR      r0,|L7.352|
00012e  6801              LDR      r1,[r0,#0]  ; g_iRunTime
000130  a020              ADR      r0,|L7.436|
000132  f7fffffe          BL       logger_buffer_write
;;;98                 s_tState = START;
000136  2000              MOVS     r0,#0
000138  4905              LDR      r1,|L7.336|
00013a  7008              STRB     r0,[r1,#0]
                  |L7.316|
;;;99                 return fsm_rt_cpl;
;;;100            }
;;;101            //break;
;;;102        }
;;;103        return fsm_rt_on_going;
;;;104        
;;;105        fail:
;;;106        s_tState = START;
;;;107        return ret;
;;;108    }
00013c  e8bd83fe          POP      {r1-r9,pc}
                  |L7.320|
000140  bf00              NOP                            ;70
000142  2001              MOVS     r0,#1                 ;103
000144  e7fa              B        |L7.316|
                  |L7.326|
000146  2000              MOVS     r0,#0                 ;106
000148  4901              LDR      r1,|L7.336|
00014a  7008              STRB     r0,[r1,#0]            ;106
00014c  4620              MOV      r0,r4                 ;107
00014e  e7f5              B        |L7.316|
;;;109    
                          ENDP

                  |L7.336|
                          DCD      s_tState
                  |L7.340|
                          DCD      trim_reg_data
                  |L7.344|
                          DCD      default_measure
                  |L7.348|
                          DCD      trim_measure
                  |L7.352|
                          DCD      g_iRunTime
                  |L7.356|
000164  5b253864          DCB      "[%8d]SUCCESS IREF:%d,%d.%duA(%d.%duA)\r\n",0
000168  5d535543
00016c  43455353
000170  20495245
000174  463a2564
000178  2c25642e
00017c  25647541
000180  2825642e
000184  25647541
000188  290d0a00
                  |L7.396|
00018c  5b253864          DCB      "[%8d]SUCCESS VREF:[%d]%d,%dmv(%dmv)\r\n",0
000190  5d535543
000194  43455353
000198  20565245
00019c  463a5b25
0001a0  645d2564
0001a4  2c25646d
0001a8  76282564
0001ac  6d76290d
0001b0  0a00    
0001b2  00                DCB      0
0001b3  00                DCB      0
                  |L7.436|
0001b4  5b253864          DCB      "[%8d]SUCCESS LPVDD:%d,%dmv(%dmv)\r\n",0
0001b8  5d535543
0001bc  43455353
0001c0  204c5056
0001c4  44443a25
0001c8  642c2564
0001cc  6d762825
0001d0  646d7629
0001d4  0d0a00  
0001d7  00                DCB      0

                          AREA ||i.volt_binary_search||, CODE, READONLY, ALIGN=1

                  volt_binary_search PROC
;;;267    //dir 考虑 trim增大与频率增大是否通向
;;;268    static void volt_binary_search(volt_search_t*  volt_search_struct)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;269    {
000004  4606              MOV      r6,r0
;;;270        uint32_t tar                    = (*volt_search_struct).tar;
000006  6837              LDR      r7,[r6,#0]
;;;271        uint32_t(*trim_set)(uint8_t )   = (*volt_search_struct).trim_val_set;
000008  f8d6b004          LDR      r11,[r6,#4]
;;;272        uint8_t high                    = (*volt_search_struct).trim_val_hi;
00000c  f8968009          LDRB     r8,[r6,#9]
;;;273        uint8_t low                     = (*volt_search_struct).trim_val_low;
000010  f8969008          LDRB     r9,[r6,#8]
;;;274        uint8_t dir                     = (*volt_search_struct).dir;
000014  7c70              LDRB     r0,[r6,#0x11]
000016  9001              STR      r0,[sp,#4]
;;;275        uint8_t mid;
;;;276        uint32_t mid_volt;
;;;277        uint32_t min_diff               = tar;
000018  9700              STR      r7,[sp,#0]
;;;278      
;;;279        
;;;280        while (low <= high) 
00001a  e033              B        |L8.132|
                  |L8.28|
;;;281        {
;;;282            mid = (low + high) / 2;
00001c  eb090008          ADD      r0,r9,r8
000020  eb0071d0          ADD      r1,r0,r0,LSR #31
000024  f3c10447          UBFX     r4,r1,#1,#8
;;;283            mid_volt = trim_set(mid);
000028  4620              MOV      r0,r4
00002a  47d8              BLX      r11
00002c  4605              MOV      r5,r0
;;;284            //debug("mid=%3d, low=%3d, high=%3d, mid_volt=%8d\r\n",mid,low,high,mid_volt);
;;;285            
;;;286            uint32_t diff = (mid_volt > tar)?(mid_volt-tar):(tar-mid_volt);         //当前频率与目标频率的差值
00002e  42bd              CMP      r5,r7
000030  d901              BLS      |L8.54|
000032  1be8              SUBS     r0,r5,r7
000034  e000              B        |L8.56|
                  |L8.54|
000036  1b78              SUBS     r0,r7,r5
                  |L8.56|
000038  4682              MOV      r10,r0
;;;287            if (diff < min_diff) 
00003a  9800              LDR      r0,[sp,#0]
00003c  4582              CMP      r10,r0
00003e  d203              BCS      |L8.72|
;;;288            {
;;;289                min_diff = diff;
000040  f8cda000          STR      r10,[sp,#0]
;;;290                (*volt_search_struct).best_trim_val  = mid;
000044  7434              STRB     r4,[r6,#0x10]
;;;291                (*volt_search_struct).best_trim_volt = mid_volt;
000046  60f5              STR      r5,[r6,#0xc]
                  |L8.72|
;;;292            }
;;;293            
;;;294            
;;;295            if (mid_volt == tar ) 
000048  42bd              CMP      r5,r7
00004a  d100              BNE      |L8.78|
;;;296            {
;;;297                break;//return mid;
00004c  e01c              B        |L8.136|
                  |L8.78|
;;;298            } 
;;;299            else if((mid == low) && (mid== high)) /* low mid high三个数为同一值，穷举完毕 */
00004e  454c              CMP      r4,r9
000050  d102              BNE      |L8.88|
000052  4544              CMP      r4,r8
000054  d100              BNE      |L8.88|
;;;300            {
;;;301                break;
000056  e017              B        |L8.136|
                  |L8.88|
;;;302            }
;;;303            else 
;;;304            {
;;;305                if(dir)
000058  9801              LDR      r0,[sp,#4]
00005a  b148              CBZ      r0,|L8.112|
;;;306                {
;;;307                    if (mid_volt < tar) 
00005c  42bd              CMP      r5,r7
00005e  d203              BCS      |L8.104|
;;;308                    {
;;;309                        low = mid + 1;
000060  1c60              ADDS     r0,r4,#1
000062  f00009ff          AND      r9,r0,#0xff
000066  e00c              B        |L8.130|
                  |L8.104|
;;;310                    } 
;;;311                    else 
;;;312                    {
;;;313                        high = mid - 1;
000068  1e60              SUBS     r0,r4,#1
00006a  f00008ff          AND      r8,r0,#0xff
00006e  e008              B        |L8.130|
                  |L8.112|
;;;314                    }
;;;315                }
;;;316                else
;;;317                {
;;;318                    if (mid_volt < tar) 
000070  42bd              CMP      r5,r7
000072  d203              BCS      |L8.124|
;;;319                    {
;;;320                       
;;;321                        high = mid - 1;
000074  1e60              SUBS     r0,r4,#1
000076  f00008ff          AND      r8,r0,#0xff
00007a  e002              B        |L8.130|
                  |L8.124|
;;;322                    } 
;;;323                    else 
;;;324                    {
;;;325                        low = mid + 1;
00007c  1c60              ADDS     r0,r4,#1
00007e  f00009ff          AND      r9,r0,#0xff
                  |L8.130|
;;;326                    }
;;;327                }
;;;328            }
;;;329        }
000082  bf00              NOP      
                  |L8.132|
000084  45c1              CMP      r9,r8                 ;280
000086  ddc9              BLE      |L8.28|
                  |L8.136|
000088  bf00              NOP                            ;297
;;;330    }
00008a  e8bd9ffc          POP      {r2-r12,pc}
;;;331    
                          ENDP


                          AREA ||i.vref_trim||, CODE, READONLY, ALIGN=2

                  vref_trim PROC
;;;161    
;;;162    static fsm_rt_t vref_trim(void)
000000  b530              PUSH     {r4,r5,lr}
;;;163    {
000002  b08d              SUB      sp,sp,#0x34
;;;164        volt_search_t volt_search;
;;;165        uint32_t search_result[4][2]={0};
000004  2120              MOVS     r1,#0x20
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       __aeabi_memclr4
;;;166        static uint8_t bgr_squence[4] = {2,3,1,0};
;;;167        //set_apple_trim_value(ITEM_VBG,BGR_FIX_VAL);   
;;;168        set_apple_debug_out(ITEM_VREF);	            //VREF电压注入GPIO03
00000c  2002              MOVS     r0,#2
00000e  f7fffffe          BL       set_apple_debug_out
;;;169        delay_ms(2);
000012  2002              MOVS     r0,#2
000014  f7fffffe          BL       bsp_DelayMS
;;;170        default_measure.vrefVolt = pmu_volt_get();
000018  f7fffffe          BL       pmu_volt_get
00001c  4938              LDR      r1,|L9.256|
00001e  6088              STR      r0,[r1,#8]  ; default_measure
;;;171        volt_search.tar          = VREF_TAR;
000020  f2405046          MOV      r0,#0x546
000024  9008              STR      r0,[sp,#0x20]
;;;172        volt_search.trim_val_set = vref_trim_set;
000026  4837              LDR      r0,|L9.260|
000028  9009              STR      r0,[sp,#0x24]
;;;173        volt_search.dir          = 1;//trim值越大，电压越大
00002a  2001              MOVS     r0,#1
00002c  f88d0031          STRB     r0,[sp,#0x31]
;;;174        volt_search.trim_val_low = VREF_TRIM_LO;
000030  2000              MOVS     r0,#0
000032  f88d0028          STRB     r0,[sp,#0x28]
;;;175        volt_search.trim_val_hi  = VREF_TRIM_HI;
000036  200f              MOVS     r0,#0xf
000038  f88d0029          STRB     r0,[sp,#0x29]
;;;176        uint8_t trim_val_get_flg = 0;
00003c  2500              MOVS     r5,#0
;;;177        for(uint8_t num=0; num < 4; num++)
00003e  2400              MOVS     r4,#0
000040  e036              B        |L9.176|
                  |L9.66|
;;;178        {
;;;179            set_apple_trim_value(ITEM_VBG, bgr_squence[num]);
000042  4831              LDR      r0,|L9.264|
000044  5d01              LDRB     r1,[r0,r4]
000046  2003              MOVS     r0,#3
000048  f7fffffe          BL       set_apple_trim_value
;;;180            volt_binary_search(&volt_search);
00004c  a808              ADD      r0,sp,#0x20
00004e  f7fffffe          BL       volt_binary_search
;;;181            search_result[bgr_squence[num]][0] = volt_search.best_trim_val;
000052  f89d0030          LDRB     r0,[sp,#0x30]
000056  492c              LDR      r1,|L9.264|
000058  5d09              LDRB     r1,[r1,r4]
00005a  f84d0031          STR      r0,[sp,r1,LSL #3]
;;;182            search_result[bgr_squence[num]][1] = volt_search.best_trim_volt;
00005e  492a              LDR      r1,|L9.264|
000060  5d09              LDRB     r1,[r1,r4]
000062  466a              MOV      r2,sp
000064  eb0201c1          ADD      r1,r2,r1,LSL #3
000068  980b              LDR      r0,[sp,#0x2c]
00006a  6048              STR      r0,[r1,#4]
;;;183            
;;;184            if(trim_val_get_flg == 0)
00006c  b9f5              CBNZ     r5,|L9.172|
;;;185            {
;;;186                if((volt_search.best_trim_volt <= VREF_HI)  && (volt_search.best_trim_volt >= VREF_LO))
00006e  f2405189          MOV      r1,#0x589
000072  980b              LDR      r0,[sp,#0x2c]
000074  4288              CMP      r0,r1
000076  d819              BHI      |L9.172|
000078  f2405102          MOV      r1,#0x502
00007c  980b              LDR      r0,[sp,#0x2c]
00007e  4288              CMP      r0,r1
000080  d314              BCC      |L9.172|
;;;187                {
;;;188                    trim_val_get_flg = 1;
000082  2501              MOVS     r5,#1
;;;189                    trim_reg_data.bgr_f     = bgr_squence[num]; //BGR设置固定的
000084  4820              LDR      r0,|L9.264|
000086  5d01              LDRB     r1,[r0,r4]
000088  4820              LDR      r0,|L9.268|
00008a  6800              LDR      r0,[r0,#0]  ; trim_reg_data
00008c  f3612009          BFI      r0,r1,#8,#2
000090  491e              LDR      r1,|L9.268|
000092  6008              STR      r0,[r1,#0]  ; trim_reg_data
;;;190                    trim_reg_data.vref_f    = volt_search.best_trim_val;
000094  f89d1030          LDRB     r1,[sp,#0x30]
000098  481c              LDR      r0,|L9.268|
00009a  6800              LDR      r0,[r0,#0]  ; trim_reg_data
00009c  f3611007          BFI      r0,r1,#4,#4
0000a0  491a              LDR      r1,|L9.268|
0000a2  6008              STR      r0,[r1,#0]  ; trim_reg_data
;;;191                    trim_measure.vrefVolt   = volt_search.best_trim_volt;
0000a4  491a              LDR      r1,|L9.272|
0000a6  980b              LDR      r0,[sp,#0x2c]
0000a8  6088              STR      r0,[r1,#8]  ; trim_measure
;;;192                    break;
0000aa  e003              B        |L9.180|
                  |L9.172|
0000ac  1c60              ADDS     r0,r4,#1              ;177
0000ae  b2c4              UXTB     r4,r0                 ;177
                  |L9.176|
0000b0  2c04              CMP      r4,#4                 ;177
0000b2  dbc6              BLT      |L9.66|
                  |L9.180|
0000b4  bf00              NOP      
;;;193                }
;;;194            }
;;;195        }
;;;196        if(trim_val_get_flg == 0) //未获得可用的trim值
0000b6  2d00              CMP      r5,#0
0000b8  d11f              BNE      |L9.250|
;;;197        {
;;;198            logging("fail vref:[0]%d,%dmv\r\n",search_result[0][0],search_result[0][1]);
0000ba  4816              LDR      r0,|L9.276|
0000bc  e9dd2300          LDRD     r2,r3,[sp,#0]
0000c0  6801              LDR      r1,[r0,#0]  ; g_iRunTime
0000c2  a015              ADR      r0,|L9.280|
0000c4  f7fffffe          BL       logger_buffer_write
;;;199            logging("fail vref:[1]%d,%dmv\r\n",search_result[1][0],search_result[1][1]);
0000c8  4812              LDR      r0,|L9.276|
0000ca  e9dd2302          LDRD     r2,r3,[sp,#8]
0000ce  6801              LDR      r1,[r0,#0]  ; g_iRunTime
0000d0  a018              ADR      r0,|L9.308|
0000d2  f7fffffe          BL       logger_buffer_write
;;;200            logging("fail vref:[2]%d,%dmv\r\n",search_result[2][0],search_result[2][1]);
0000d6  480f              LDR      r0,|L9.276|
0000d8  e9dd2304          LDRD     r2,r3,[sp,#0x10]
0000dc  6801              LDR      r1,[r0,#0]  ; g_iRunTime
0000de  a01c              ADR      r0,|L9.336|
0000e0  f7fffffe          BL       logger_buffer_write
;;;201            logging("fail vref:[3]%d,%dmv\r\n",search_result[3][0],search_result[3][1]);
0000e4  480b              LDR      r0,|L9.276|
0000e6  e9dd2306          LDRD     r2,r3,[sp,#0x18]
0000ea  6801              LDR      r1,[r0,#0]  ; g_iRunTime
0000ec  a01f              ADR      r0,|L9.364|
0000ee  f7fffffe          BL       logger_buffer_write
;;;202            return fsm_rt_err_vref;
0000f2  f06f0013          MVN      r0,#0x13
                  |L9.246|
;;;203        }
;;;204        else
;;;205        {
;;;206            return fsm_rt_cpl;
;;;207        }
;;;208        
;;;209        
;;;210        
;;;211        
;;;212    }
0000f6  b00d              ADD      sp,sp,#0x34
0000f8  bd30              POP      {r4,r5,pc}
                  |L9.250|
0000fa  2000              MOVS     r0,#0                 ;206
0000fc  e7fb              B        |L9.246|
;;;213    
                          ENDP

0000fe  0000              DCW      0x0000
                  |L9.256|
                          DCD      default_measure
                  |L9.260|
                          DCD      vref_trim_set
                  |L9.264|
                          DCD      bgr_squence
                  |L9.268|
                          DCD      trim_reg_data
                  |L9.272|
                          DCD      trim_measure
                  |L9.276|
                          DCD      g_iRunTime
                  |L9.280|
000118  5b253864          DCB      "[%8d]fail vref:[0]%d,%dmv\r\n",0
00011c  5d666169
000120  6c207672
000124  65663a5b
000128  305d2564
00012c  2c25646d
000130  760d0a00
                  |L9.308|
000134  5b253864          DCB      "[%8d]fail vref:[1]%d,%dmv\r\n",0
000138  5d666169
00013c  6c207672
000140  65663a5b
000144  315d2564
000148  2c25646d
00014c  760d0a00
                  |L9.336|
000150  5b253864          DCB      "[%8d]fail vref:[2]%d,%dmv\r\n",0
000154  5d666169
000158  6c207672
00015c  65663a5b
000160  325d2564
000164  2c25646d
000168  760d0a00
                  |L9.364|
00016c  5b253864          DCB      "[%8d]fail vref:[3]%d,%dmv\r\n",0
000170  5d666169
000174  6c207672
000178  65663a5b
00017c  335d2564
000180  2c25646d
000184  760d0a00

                          AREA ||i.vref_trim_set||, CODE, READONLY, ALIGN=1

                  vref_trim_set PROC
;;;154    //设置trim值，返回电压
;;;155    static uint32_t vref_trim_set(uint8_t val)
000000  b510              PUSH     {r4,lr}
;;;156    {
000002  4604              MOV      r4,r0
;;;157        set_apple_trim_value(ITEM_VREF, val);
000004  4621              MOV      r1,r4
000006  2002              MOVS     r0,#2
000008  f7fffffe          BL       set_apple_trim_value
;;;158        delay_ms(1);
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       bsp_DelayMS
;;;159        return pmu_volt_get();
000012  f7fffffe          BL       pmu_volt_get
;;;160    }
000016  bd10              POP      {r4,pc}
;;;161    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  s_tState
000000  00                DCB      0x00
                  bgr_squence
000001  020301            DCB      0x02,0x03,0x01
000004  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\chip_ft\\test_pmu.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_test_pmu_c_test_pmu____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_test_pmu_c_test_pmu____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_test_pmu_c_test_pmu____REVSH|
#line 144
|__asm___10_test_pmu_c_test_pmu____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
