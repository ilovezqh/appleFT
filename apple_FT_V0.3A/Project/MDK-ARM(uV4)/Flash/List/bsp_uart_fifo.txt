; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\flash\obj\bsp_uart_fifo.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_uart_fifo.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\User -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\User\FatFS\src -I..\..\Libraries\STM32_USB_Device_Library\Class\msc\inc -I..\..\Libraries\STM32_USB_Device_Library\Core\inc -I..\..\Libraries\STM32_USB_OTG_Driver\inc -I..\..\User\usbd_mass_storage -I..\..\User\ft_support -I..\..\User\test -I..\..\User\emenu -I..\..\User\chip_ft -I..\..\User\lwrb -I..\..\User\easylogger\inc -I..\..\User\easylogger\plugins\file -I..\..\User\LOG -I..\..\User\MultiButton-1.1.0 -I..\..\User\cm_backtrace -I..\..\User\MultiTimer -I.\RTE\_Flash -IC:\Users\qizha\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\qizha\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.17.1\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F407xx -D_RTE_ -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY --signed_chars --omf_browse=.\flash\obj\bsp_uart_fifo.crf ..\..\User\bsp_stm32f4xx\src\bsp_uart_fifo.c]
                          THUMB

                          AREA ||i.ComToUart||, CODE, READONLY, ALIGN=2

                  ComToUart PROC
;;;90     */
;;;91     UART_T *ComToUart(COM_PORT_E _ucPort)
000000  4601              MOV      r1,r0
;;;92     {
;;;93     	if (_ucPort == COM1)
000002  b909              CBNZ     r1,|L1.8|
;;;94     	{
;;;95     		#if UART1_FIFO_EN == 1
;;;96     			return &g_tUart1;
000004  480b              LDR      r0,|L1.52|
                  |L1.6|
;;;97     		#else
;;;98     			return 0;
;;;99     		#endif
;;;100    	}
;;;101    	else if (_ucPort == COM2)
;;;102    	{
;;;103    		#if UART2_FIFO_EN == 1
;;;104    			return &g_tUart2;
;;;105    		#else
;;;106    			return;
;;;107    		#endif
;;;108    	}
;;;109    	else if (_ucPort == COM3)
;;;110    	{
;;;111    		#if UART3_FIFO_EN == 1
;;;112    			return &g_tUart3;
;;;113    		#else
;;;114    			return 0;
;;;115    		#endif
;;;116    	}
;;;117    	else if (_ucPort == COM4)
;;;118    	{
;;;119    		#if UART4_FIFO_EN == 1
;;;120    			return &g_tUart4;
;;;121    		#else
;;;122    			return 0;
;;;123    		#endif
;;;124    	}
;;;125    	else if (_ucPort == COM5)
;;;126    	{
;;;127    		#if UART5_FIFO_EN == 1
;;;128    			return &g_tUart5;
;;;129    		#else
;;;130    			return 0;
;;;131    		#endif
;;;132    	}
;;;133    	else if (_ucPort == COM6)
;;;134    	{
;;;135    		#if UART6_FIFO_EN == 1
;;;136    			return &g_tUart6;
;;;137    		#else
;;;138    			return 0;
;;;139    		#endif
;;;140    	}
;;;141    	else
;;;142    	{
;;;143    		/* 不做任何处理 */
;;;144    		return 0;
;;;145    	}
;;;146    }
000006  4770              BX       lr
                  |L1.8|
000008  2901              CMP      r1,#1                 ;101
00000a  d101              BNE      |L1.16|
00000c  480a              LDR      r0,|L1.56|
00000e  e7fa              B        |L1.6|
                  |L1.16|
000010  2902              CMP      r1,#2                 ;109
000012  d101              BNE      |L1.24|
000014  2000              MOVS     r0,#0                 ;114
000016  e7f6              B        |L1.6|
                  |L1.24|
000018  2903              CMP      r1,#3                 ;117
00001a  d101              BNE      |L1.32|
00001c  2000              MOVS     r0,#0                 ;122
00001e  e7f2              B        |L1.6|
                  |L1.32|
000020  2904              CMP      r1,#4                 ;125
000022  d101              BNE      |L1.40|
000024  2000              MOVS     r0,#0                 ;130
000026  e7ee              B        |L1.6|
                  |L1.40|
000028  2905              CMP      r1,#5                 ;133
00002a  d101              BNE      |L1.48|
00002c  2000              MOVS     r0,#0                 ;138
00002e  e7ea              B        |L1.6|
                  |L1.48|
000030  2000              MOVS     r0,#0                 ;144
000032  e7e8              B        |L1.6|
;;;147    
                          ENDP

                  |L1.52|
                          DCD      g_tUart1
                  |L1.56|
                          DCD      g_tUart2

                          AREA ||i.ConfigUartNVIC||, CODE, READONLY, ALIGN=1

                  ConfigUartNVIC PROC
;;;847    */
;;;848    static void ConfigUartNVIC(void)
000000  b508              PUSH     {r3,lr}
;;;849    {
;;;850    	NVIC_InitTypeDef NVIC_InitStructure;
;;;851    
;;;852    	/* Configure the NVIC Preemption Priority Bits */
;;;853    	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);
000002  f44f7040          MOV      r0,#0x300
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;854    
;;;855    #if UART1_FIFO_EN == 1
;;;856    	/* 使能串口1中断 */
;;;857    	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
00000a  2025              MOVS     r0,#0x25
00000c  f88d0000          STRB     r0,[sp,#0]
;;;858        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
000010  2002              MOVS     r0,#2
000012  f88d0001          STRB     r0,[sp,#1]
;;;859    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000016  2000              MOVS     r0,#0
000018  f88d0002          STRB     r0,[sp,#2]
;;;860    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00001c  2001              MOVS     r0,#1
00001e  f88d0003          STRB     r0,[sp,#3]
;;;861    	NVIC_Init(&NVIC_InitStructure);
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       NVIC_Init
;;;862    #endif
;;;863    
;;;864    #if UART2_FIFO_EN == 1
;;;865    	/* 使能串口2中断 */
;;;866    	NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
000028  2026              MOVS     r0,#0x26
00002a  f88d0000          STRB     r0,[sp,#0]
;;;867        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
00002e  2000              MOVS     r0,#0
000030  f88d0001          STRB     r0,[sp,#1]
;;;868    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
000034  2001              MOVS     r0,#1
000036  f88d0002          STRB     r0,[sp,#2]
;;;869    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00003a  f88d0003          STRB     r0,[sp,#3]
;;;870    	NVIC_Init(&NVIC_InitStructure);
00003e  4668              MOV      r0,sp
000040  f7fffffe          BL       NVIC_Init
;;;871    #endif
;;;872    
;;;873    #if UART3_FIFO_EN == 1
;;;874    	/* 使能串口3中断t */
;;;875    	NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;
;;;876    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;
;;;877    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;878    	NVIC_Init(&NVIC_InitStructure);
;;;879    #endif
;;;880    
;;;881    #if UART4_FIFO_EN == 1
;;;882    	/* 使能串口4中断t */
;;;883    	NVIC_InitStructure.NVIC_IRQChannel = UART4_IRQn;
;;;884    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;
;;;885    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;886    	NVIC_Init(&NVIC_InitStructure);
;;;887    #endif
;;;888    
;;;889    #if UART5_FIFO_EN == 1
;;;890    	/* 使能串口5中断t */
;;;891    	NVIC_InitStructure.NVIC_IRQChannel = UART5_IRQn;
;;;892    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 4;
;;;893    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;894    	NVIC_Init(&NVIC_InitStructure);
;;;895    #endif
;;;896    
;;;897    #if UART6_FIFO_EN == 1
;;;898    	/* 使能串口6中断t */
;;;899    	NVIC_InitStructure.NVIC_IRQChannel = USART6_IRQn;
;;;900    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 5;
;;;901    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;902    	NVIC_Init(&NVIC_InitStructure);
;;;903    #endif
;;;904    }
000044  bd08              POP      {r3,pc}
;;;905    
                          ENDP


                          AREA ||i.InitHardUart||, CODE, READONLY, ALIGN=2

                  InitHardUart PROC
;;;435    */
;;;436    static void InitHardUart(void)
000000  b500              PUSH     {lr}
;;;437    {
000002  b087              SUB      sp,sp,#0x1c
;;;438    	GPIO_InitTypeDef GPIO_InitStructure={0};
000004  2000              MOVS     r0,#0
000006  9005              STR      r0,[sp,#0x14]
000008  9006              STR      r0,[sp,#0x18]
;;;439    	USART_InitTypeDef USART_InitStructure={0};
00000a  9001              STR      r0,[sp,#4]
00000c  9002              STR      r0,[sp,#8]
00000e  9003              STR      r0,[sp,#0xc]
000010  9004              STR      r0,[sp,#0x10]
;;;440    
;;;441    #if UART1_FIFO_EN == 1		/* 串口1 TX = PA9   RX = PA10 或 TX = PB6   RX = PB7*/
;;;442    
;;;443    	/* 第1步： 配置GPIO */
;;;444    	#if 1	/* TX = PA9   RX = PA10 */
;;;445    		/* 打开 GPIO 时钟 */
;;;446    		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
000012  2101              MOVS     r1,#1
000014  4608              MOV      r0,r1
000016  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;447    
;;;448    		/* 打开 UART 时钟 */
;;;449    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
00001a  2101              MOVS     r1,#1
00001c  2010              MOVS     r0,#0x10
00001e  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;450    
;;;451    		/* 将 PA9 映射为 USART1_TX */
;;;452    		GPIO_PinAFConfig(GPIOA, GPIO_PinSource9, GPIO_AF_USART1);
000022  2207              MOVS     r2,#7
000024  2109              MOVS     r1,#9
000026  484a              LDR      r0,|L3.336|
000028  f7fffffe          BL       GPIO_PinAFConfig
;;;453    
;;;454    		/* 将 PA10 映射为 USART1_RX */
;;;455    		GPIO_PinAFConfig(GPIOA, GPIO_PinSource10, GPIO_AF_USART1);
00002c  2207              MOVS     r2,#7
00002e  210a              MOVS     r1,#0xa
000030  4847              LDR      r0,|L3.336|
000032  f7fffffe          BL       GPIO_PinAFConfig
;;;456    
;;;457    		/* 配置 USART Tx 为复用功能 */
;;;458    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	/* 输出类型为推挽 */
000036  2000              MOVS     r0,#0
000038  f88d001a          STRB     r0,[sp,#0x1a]
;;;459    		GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;	/* 内部上拉电阻使能 */
00003c  2001              MOVS     r0,#1
00003e  f88d001b          STRB     r0,[sp,#0x1b]
;;;460    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	/* 复用模式 */
000042  2002              MOVS     r0,#2
000044  f88d0018          STRB     r0,[sp,#0x18]
;;;461    
;;;462    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000048  0200              LSLS     r0,r0,#8
00004a  9005              STR      r0,[sp,#0x14]
;;;463    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00004c  2002              MOVS     r0,#2
00004e  f88d0019          STRB     r0,[sp,#0x19]
;;;464    		GPIO_Init(GPIOA, &GPIO_InitStructure);
000052  a905              ADD      r1,sp,#0x14
000054  483e              LDR      r0,|L3.336|
000056  f7fffffe          BL       GPIO_Init
;;;465    
;;;466    		/* 配置 USART Rx 为复用功能 */
;;;467    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
00005a  2002              MOVS     r0,#2
00005c  f88d0018          STRB     r0,[sp,#0x18]
;;;468    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000060  0240              LSLS     r0,r0,#9
000062  9005              STR      r0,[sp,#0x14]
;;;469    		GPIO_Init(GPIOA, &GPIO_InitStructure);
000064  a905              ADD      r1,sp,#0x14
000066  483a              LDR      r0,|L3.336|
000068  f7fffffe          BL       GPIO_Init
;;;470    	#else	/* TX = PB6   RX = PB7  */
;;;471    		/* 打开 GPIO 时钟 */
;;;472    		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
;;;473    
;;;474    		/* 打开 UART 时钟 */
;;;475    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
;;;476    
;;;477    		/* 将 PB6 映射为 USART1_TX */
;;;478    		GPIO_PinAFConfig(GPIOB, GPIO_PinSource6, GPIO_AF_USART1);
;;;479    
;;;480    		/* 将 PB7 映射为 USART1_RX */
;;;481    		GPIO_PinAFConfig(GPIOB, GPIO_PinSource7, GPIO_AF_USART1);
;;;482    
;;;483    		/* 配置 USART Tx 为复用功能 */
;;;484    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	/* 输出类型为推挽 */
;;;485    		GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;	/* 内部上拉电阻使能 */
;;;486    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	/* 复用模式 */
;;;487    
;;;488    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
;;;489    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;490    		GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;491    
;;;492    		/* 配置 USART Rx 为复用功能 */
;;;493    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;494    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;
;;;495    		GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;496    	#endif
;;;497    
;;;498    	/* 第2步： 配置串口硬件参数 */
;;;499    	USART_InitStructure.USART_BaudRate = UART1_BAUD;	/* 波特率 */
00006c  f44f30e1          MOV      r0,#0x1c200
000070  9001              STR      r0,[sp,#4]
;;;500    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000072  2000              MOVS     r0,#0
000074  f8ad0008          STRH     r0,[sp,#8]
;;;501    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
000078  f8ad000a          STRH     r0,[sp,#0xa]
;;;502    	USART_InitStructure.USART_Parity = USART_Parity_No ;
00007c  f8ad000c          STRH     r0,[sp,#0xc]
;;;503    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000080  f8ad0010          STRH     r0,[sp,#0x10]
;;;504    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000084  200c              MOVS     r0,#0xc
000086  f8ad000e          STRH     r0,[sp,#0xe]
;;;505    	USART_Init(USART1, &USART_InitStructure);
00008a  a901              ADD      r1,sp,#4
00008c  4831              LDR      r0,|L3.340|
00008e  f7fffffe          BL       USART_Init
;;;506    
;;;507    	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
000092  2201              MOVS     r2,#1
000094  f2405125          MOV      r1,#0x525
000098  482e              LDR      r0,|L3.340|
00009a  f7fffffe          BL       USART_ITConfig
;;;508        //USART_ITConfig(USART1, USART_IT_ERR, ENABLE);	/* 使能错误接收中断 */
;;;509    	/*
;;;510    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;511    		注意: 不要在此处打开发送中断
;;;512    		发送中断使能在SendUart()函数打开
;;;513    	*/
;;;514    	USART_Cmd(USART1, ENABLE);		/* 使能串口 */
00009e  2101              MOVS     r1,#1
0000a0  482c              LDR      r0,|L3.340|
0000a2  f7fffffe          BL       USART_Cmd
;;;515        
;;;516    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;517    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;518    	USART_ClearFlag(USART1, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
0000a6  2140              MOVS     r1,#0x40
0000a8  482a              LDR      r0,|L3.340|
0000aa  f7fffffe          BL       USART_ClearFlag
;;;519    #endif
;;;520    
;;;521    #if UART2_FIFO_EN == 1		/* 串口2 TX = PD5   RX = PD6 或  TX = PA2， RX = PA3  */
;;;522    	/* 第1步： 配置GPIO */
;;;523    	#if 1	/* 串口2 TX = PD5   RX = PD6 */
;;;524    		/* 打开 GPIO 时钟 */
;;;525    		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
0000ae  2101              MOVS     r1,#1
0000b0  2008              MOVS     r0,#8
0000b2  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;526    
;;;527    		/* 打开 UART 时钟 */
;;;528    		RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
0000b6  2101              MOVS     r1,#1
0000b8  0448              LSLS     r0,r1,#17
0000ba  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;529    
;;;530    		/* 将 PD5 映射为 USART2_TX */
;;;531    		GPIO_PinAFConfig(GPIOD, GPIO_PinSource5, GPIO_AF_USART2);
0000be  2207              MOVS     r2,#7
0000c0  2105              MOVS     r1,#5
0000c2  4825              LDR      r0,|L3.344|
0000c4  f7fffffe          BL       GPIO_PinAFConfig
;;;532    
;;;533    		/* 将 PD6 映射为 USART2_RX */
;;;534    		GPIO_PinAFConfig(GPIOD, GPIO_PinSource6, GPIO_AF_USART2);
0000c8  2207              MOVS     r2,#7
0000ca  2106              MOVS     r1,#6
0000cc  4822              LDR      r0,|L3.344|
0000ce  f7fffffe          BL       GPIO_PinAFConfig
;;;535    
;;;536    		/* 配置 USART Tx 为复用功能 */
;;;537    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	/* 输出类型为推挽 */
0000d2  2000              MOVS     r0,#0
0000d4  f88d001a          STRB     r0,[sp,#0x1a]
;;;538    		GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;	/* 内部上拉电阻使能 */
0000d8  2001              MOVS     r0,#1
0000da  f88d001b          STRB     r0,[sp,#0x1b]
;;;539    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	/* 复用模式 */
0000de  2002              MOVS     r0,#2
0000e0  f88d0018          STRB     r0,[sp,#0x18]
;;;540    
;;;541    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
0000e4  2020              MOVS     r0,#0x20
0000e6  9005              STR      r0,[sp,#0x14]
;;;542    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000e8  2002              MOVS     r0,#2
0000ea  f88d0019          STRB     r0,[sp,#0x19]
;;;543    		GPIO_Init(GPIOD, &GPIO_InitStructure);
0000ee  a905              ADD      r1,sp,#0x14
0000f0  4819              LDR      r0,|L3.344|
0000f2  f7fffffe          BL       GPIO_Init
;;;544            
;;;545            
;;;546     
;;;547    
;;;548    		/* 配置 USART Rx 为复用功能 */
;;;549    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
0000f6  2002              MOVS     r0,#2
0000f8  f88d0018          STRB     r0,[sp,#0x18]
;;;550    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
0000fc  2040              MOVS     r0,#0x40
0000fe  9005              STR      r0,[sp,#0x14]
;;;551    		GPIO_Init(GPIOD, &GPIO_InitStructure);
000100  a905              ADD      r1,sp,#0x14
000102  4815              LDR      r0,|L3.344|
000104  f7fffffe          BL       GPIO_Init
;;;552    
;;;553    	#else	/* 串口2   TX = PA2， RX = PA3 */
;;;554    		/* 打开 GPIO 时钟 */
;;;555    		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
;;;556    
;;;557    		/* 打开 UART 时钟 */
;;;558    		RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
;;;559    
;;;560    		/* 将 PA2 映射为 USART2_TX. 在FT_F4板中，PA2 管脚用于以太网 */
;;;561    		//GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_USART2);
;;;562    
;;;563    		/* 将 PA3 映射为 USART2_RX */
;;;564    		GPIO_PinAFConfig(GPIOD, GPIO_PinSource6, GPIO_AF_USART2);
;;;565    
;;;566    		/* 配置 USART Tx 为复用功能 */
;;;567    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	/* 输出类型为推挽 */
;;;568    		GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;	/* 内部上拉电阻使能 */
;;;569    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	/* 复用模式 */
;;;570    
;;;571    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
;;;572    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;573    		GPIO_Init(GPIOD, &GPIO_InitStructure);
;;;574    
;;;575    		/* 配置 USART Rx 为复用功能 */
;;;576    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;577    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
;;;578    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;579    		GPIO_Init(GPIOD, &GPIO_InitStructure);
;;;580    	#endif
;;;581    
;;;582    	/* 第2步： 配置串口硬件参数 */
;;;583    	USART_InitStructure.USART_BaudRate = dut.asu_baud;	/* 波特率 */
000108  4814              LDR      r0,|L3.348|
00010a  6840              LDR      r0,[r0,#4]  ; dut
00010c  9001              STR      r0,[sp,#4]
;;;584    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
00010e  2000              MOVS     r0,#0
000110  f8ad0008          STRH     r0,[sp,#8]
;;;585    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
000114  f8ad000a          STRH     r0,[sp,#0xa]
;;;586    	USART_InitStructure.USART_Parity = USART_Parity_No ;
000118  f8ad000c          STRH     r0,[sp,#0xc]
;;;587    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
00011c  f8ad0010          STRH     r0,[sp,#0x10]
;;;588    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;		/* 选择接收模式 和发送模式 */
000120  200c              MOVS     r0,#0xc
000122  f8ad000e          STRH     r0,[sp,#0xe]
;;;589    	USART_Init(USART2, &USART_InitStructure);
000126  a901              ADD      r1,sp,#4
000128  480d              LDR      r0,|L3.352|
00012a  f7fffffe          BL       USART_Init
;;;590        //USART_HalfDuplexCmd(USART2,ENABLE);
;;;591    //    CLEAR_BIT(USART2->CR2,(USART_CR2_LINEN|USART_CR2_CLKEN));
;;;592    //    CLEAR_BIT(USART2->CR3,(USART_CR3_IREN |USART_CR3_SCEN));
;;;593    	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
00012e  2201              MOVS     r2,#1
000130  f2405125          MOV      r1,#0x525
000134  480a              LDR      r0,|L3.352|
000136  f7fffffe          BL       USART_ITConfig
;;;594        //USART_ITConfig(USART2, USART_IT_ERR, ENABLE);	/* 使能错误接收中断 */
;;;595    	/*
;;;596    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;597    		注意: 不要在此处打开发送中断
;;;598    		发送中断使能在SendUart()函数打开
;;;599    	*/
;;;600    	USART_Cmd(USART2, ENABLE);		/* 使能串口 */
00013a  2101              MOVS     r1,#1
00013c  4808              LDR      r0,|L3.352|
00013e  f7fffffe          BL       USART_Cmd
;;;601    
;;;602    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;603    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;604    	USART_ClearFlag(USART2, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
000142  2140              MOVS     r1,#0x40
000144  4806              LDR      r0,|L3.352|
000146  f7fffffe          BL       USART_ClearFlag
;;;605    #endif
;;;606    
;;;607    #if UART3_FIFO_EN == 1			/* 串口3 TX = PB10   RX = PB11 */
;;;608    
;;;609    	/* 配置 PB2为推挽输出，用于切换 RS485芯片的收发状态 */
;;;610    	{
;;;611    		RCC_AHB1PeriphClockCmd(RCC_RS485_TXEN, ENABLE);
;;;612    
;;;613    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;		/* 设为输出口 */
;;;614    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;		/* 设为推挽模式 */
;;;615    		GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;	/* 上下拉电阻不使能 */
;;;616    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;	/* IO口最大速度 */
;;;617    
;;;618    		GPIO_InitStructure.GPIO_Pin = PIN_RS485_TXEN;
;;;619    		GPIO_Init(PORT_RS485_TXEN, &GPIO_InitStructure);
;;;620    	}
;;;621    
;;;622    	/* 打开 GPIO 时钟 */
;;;623    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
;;;624    
;;;625    	/* 打开 UART 时钟 */
;;;626    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
;;;627    
;;;628    	/* 将 PB10 映射为 USART3_TX */
;;;629    	GPIO_PinAFConfig(GPIOB, GPIO_PinSource10, GPIO_AF_USART3);
;;;630    
;;;631    	/* 将 PB11 映射为 USART3_RX */
;;;632    	GPIO_PinAFConfig(GPIOB, GPIO_PinSource11, GPIO_AF_USART3);
;;;633    
;;;634    	/* 配置 USART Tx 为复用功能 */
;;;635    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	/* 输出类型为推挽 */
;;;636    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;	/* 内部上拉电阻使能 */
;;;637    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	/* 复用模式 */
;;;638    
;;;639    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
;;;640    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;641    	GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;642    
;;;643    	/* 配置 USART Rx 为复用功能 */
;;;644    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;645    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
;;;646    	GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;647    
;;;648    	/* 第2步： 配置串口硬件参数 */
;;;649    	USART_InitStructure.USART_BaudRate = UART3_BAUD;	/* 波特率 */
;;;650    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;651    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;652    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;653    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;654    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;655    	USART_Init(USART3, &USART_InitStructure);
;;;656    
;;;657    	USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
;;;658    	/*
;;;659    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;660    		注意: 不要在此处打开发送中断
;;;661    		发送中断使能在SendUart()函数打开
;;;662    	*/
;;;663    	USART_Cmd(USART3, ENABLE);		/* 使能串口 */
;;;664    
;;;665    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;666    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;667    	USART_ClearFlag(USART3, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;668    #endif
;;;669    
;;;670    #if UART4_FIFO_EN == 1			/* 串口4 TX = PC10   RX = PC11 */
;;;671    	/* 第1步： 配置GPIO */
;;;672    
;;;673    	/* 打开 GPIO 时钟 */
;;;674    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
;;;675    
;;;676    	/* 打开 UART 时钟 */
;;;677    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);
;;;678    
;;;679    	/* 将 PC10 映射为 UART4_TX */
;;;680    	GPIO_PinAFConfig(GPIOC, GPIO_PinSource10, GPIO_AF_USART1);
;;;681    
;;;682    	/* 将 PC11 映射为 UART4_RX */
;;;683    	GPIO_PinAFConfig(GPIOC, GPIO_PinSource10, GPIO_AF_USART1);
;;;684    
;;;685    	/* 配置 USART Tx 为复用功能 */
;;;686    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	/* 输出类型为推挽 */
;;;687    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;	/* 内部上拉电阻使能 */
;;;688    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	/* 复用模式 */
;;;689    
;;;690    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
;;;691    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;692    	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;693    
;;;694    	/* 配置 USART Rx 为复用功能 */
;;;695    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;696    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
;;;697    	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;698    
;;;699    	/* 第2步： 配置串口硬件参数 */
;;;700    	USART_InitStructure.USART_BaudRate = UART1_BAUD;	/* 波特率 */
;;;701    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;702    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;703    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;704    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;705    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;706    	USART_Init(UART4, &USART_InitStructure);
;;;707    
;;;708    	USART_ITConfig(UART4, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
;;;709    	/*
;;;710    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;711    		注意: 不要在此处打开发送中断
;;;712    		发送中断使能在SendUart()函数打开
;;;713    	*/
;;;714    	USART_Cmd(UART4, ENABLE);		/* 使能串口 */
;;;715    
;;;716    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;717    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;718    	USART_ClearFlag(UART4, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;719    #endif
;;;720    
;;;721    #if UART5_FIFO_EN == 1			/* 串口5 TX = PC12   RX = PD2 */
;;;722    	/* 第1步： 配置GPIO */
;;;723    
;;;724    	/* 打开 GPIO 时钟 */
;;;725    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC |RCC_AHB1Periph_GPIOD, ENABLE);
;;;726    
;;;727    	/* 打开 UART 时钟 */
;;;728    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART5, ENABLE);
;;;729    
;;;730    	/* 将 PC12 映射为 UART5_TX */
;;;731    	GPIO_PinAFConfig(GPIOC, GPIO_PinSource12, GPIO_AF_UART5);
;;;732    
;;;733    	/* 将 PD2 映射为 UART5_RX */
;;;734    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource2, GPIO_AF_UART5);
;;;735    
;;;736    	/* 配置 UART Tx 为复用功能 */
;;;737    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	/* 输出类型为推挽 */
;;;738    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;	/* 内部上拉电阻使能 */
;;;739    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	/* 复用模式 */
;;;740    
;;;741    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
;;;742    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;743    	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;744    
;;;745    	/* 配置 UART Rx 为复用功能 */
;;;746    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;747    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
;;;748    	GPIO_Init(GPIOD, &GPIO_InitStructure);
;;;749    
;;;750    	/* 第2步： 配置串口硬件参数 */
;;;751    	USART_InitStructure.USART_BaudRate = UART5_BAUD;	/* 波特率 */
;;;752    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;753    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;754    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;755    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;756    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;757    	USART_Init(UART5, &USART_InitStructure);
;;;758    
;;;759    	USART_ITConfig(UART5, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
;;;760    	/*
;;;761    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;762    		注意: 不要在此处打开发送中断
;;;763    		发送中断使能在SendUart()函数打开
;;;764    	*/
;;;765    	USART_Cmd(UART5, ENABLE);		/* 使能串口 */
;;;766    
;;;767    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;768    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;769    	USART_ClearFlag(UART5, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;770    #endif
;;;771    
;;;772    #if UART6_FIFO_EN == 1			/* PG14/USART6_TX , PC7/USART6_RX,PG8/USART6_RTS, PG15/USART6_CTS */
;;;773    	/* 第1步： 配置GPIO */
;;;774    
;;;775    	/* 打开 GPIO 时钟 */
;;;776    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC |RCC_AHB1Periph_GPIOG, ENABLE);
;;;777    
;;;778    	/* 打开 UART 时钟 */
;;;779    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART6, ENABLE);
;;;780    
;;;781    	/* 将 PG14 映射为 USART6_TX */
;;;782    	GPIO_PinAFConfig(GPIOG, GPIO_PinSource14, GPIO_AF_USART6);
;;;783    
;;;784    	/* 将 PC7 映射为 USART6_RX */
;;;785    	GPIO_PinAFConfig(GPIOC, GPIO_PinSource7, GPIO_AF_USART6);
;;;786    
;;;787    	/* 将 PG8 映射为 USART6_RTS */
;;;788    	GPIO_PinAFConfig(GPIOG, GPIO_PinSource8, GPIO_AF_USART6);
;;;789    
;;;790    	/* 将 PG15 映射为 USART6_CTS */
;;;791    	GPIO_PinAFConfig(GPIOG, GPIO_PinSource15, GPIO_AF_USART6);
;;;792    
;;;793    	/* 配置 PG14/USART6_TX 为复用功能 */
;;;794    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	/* 输出类型为推挽 */
;;;795    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;	/* 内部上拉电阻使能 */
;;;796    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	/* 复用模式 */
;;;797    
;;;798    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;
;;;799    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;800    	GPIO_Init(GPIOG, &GPIO_InitStructure);
;;;801    
;;;802    	/* 配置 PC7/USART6_RX 为复用功能 */
;;;803    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;804    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;
;;;805    	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;806    
;;;807    	/* 配置 PG8/USART6_RTS 为复用功能 */
;;;808    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;809    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
;;;810    	GPIO_Init(GPIOG, &GPIO_InitStructure);
;;;811    
;;;812    	/* 配置 PG15/USART6_CTS 为复用功能 */
;;;813    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;814    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_15;
;;;815    	GPIO_Init(GPIOG, &GPIO_InitStructure);
;;;816    
;;;817    	/* 第2步： 配置串口硬件参数 */
;;;818    	USART_InitStructure.USART_BaudRate = UART6_BAUD;	/* 波特率 */
;;;819    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;820    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;821    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;822    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_RTS_CTS;	/* 选择硬件流控 */
;;;823    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;824    	USART_Init(USART6, &USART_InitStructure);
;;;825    
;;;826    	USART_ITConfig(USART6, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
;;;827    	/*
;;;828    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;829    		注意: 不要在此处打开发送中断
;;;830    		发送中断使能在SendUart()函数打开
;;;831    	*/
;;;832    	USART_Cmd(USART6, ENABLE);		/* 使能串口 */
;;;833    
;;;834    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;835    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;836    	USART_ClearFlag(USART6, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;837    #endif
;;;838    }
00014a  b007              ADD      sp,sp,#0x1c
00014c  bd00              POP      {pc}
;;;839    
                          ENDP

00014e  0000              DCW      0x0000
                  |L3.336|
                          DCD      0x40020000
                  |L3.340|
                          DCD      0x40011000
                  |L3.344|
                          DCD      0x40020c00
                  |L3.348|
                          DCD      ||dut||
                  |L3.352|
                          DCD      0x40004400

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;1170   #if UART1_FIFO_EN == 1
;;;1171   void USART1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1172   {
;;;1173   	UartIRQ(&g_tUart1);
000002  4802              LDR      r0,|L4.12|
000004  f7fffffe          BL       UartIRQ
;;;1174   }
000008  bd10              POP      {r4,pc}
;;;1175   #endif
                          ENDP

00000a  0000              DCW      0x0000
                  |L4.12|
                          DCD      g_tUart1

                          AREA ||i.USART2_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART2_IRQHandler PROC
;;;1177   #if UART2_FIFO_EN == 1
;;;1178   void USART2_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1179   {
;;;1180   	UartIRQ(&g_tUart2);
000002  4802              LDR      r0,|L5.12|
000004  f7fffffe          BL       UartIRQ
;;;1181   }
000008  bd10              POP      {r4,pc}
;;;1182   #endif
                          ENDP

00000a  0000              DCW      0x0000
                  |L5.12|
                          DCD      g_tUart2

                          AREA ||i.USART2_SendBefor||, CODE, READONLY, ALIGN=2

                  USART2_SendBefor PROC
;;;268    */
;;;269    void USART2_SendBefor(void)
000000  4805              LDR      r0,|L6.24|
;;;270    {
;;;271    	//RS485_TX_EN();	/* 切换RS485收发芯片为发送模式 */
;;;272        //USART_HalfDuplexCmd(USART2,DISABLE);
;;;273    //    GPIO_InitTypeDef GPIO_InitStructure={0};
;;;274        
;;;275    //    GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;	/* 输出类型为推挽 */
;;;276    //    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;	/* 内部上拉电阻使能 */
;;;277    //    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	/* 复用模式 */
;;;278    
;;;279    //    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
;;;280    //    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;281    //    GPIO_Init(GPIOD, &GPIO_InitStructure);
;;;282    //    GPIO_SetBits(GPIOD,GPIO_Pin_10);
;;;283        sendOnly(USART2); 
000002  8800              LDRH     r0,[r0,#0]
000004  f0400008          ORR      r0,r0,#8
000008  4903              LDR      r1,|L6.24|
00000a  8008              STRH     r0,[r1,#0]
00000c  4608              MOV      r0,r1
00000e  8800              LDRH     r0,[r0,#0]
000010  f0200004          BIC      r0,r0,#4
000014  8008              STRH     r0,[r1,#0]
;;;284    }
000016  4770              BX       lr
;;;285    
                          ENDP

                  |L6.24|
                          DCD      0x4000440c

                          AREA ||i.USART2_SendOver||, CODE, READONLY, ALIGN=2

                  USART2_SendOver PROC
;;;294    */
;;;295    void USART2_SendOver(void)
000000  4805              LDR      r0,|L7.24|
;;;296    {
;;;297    	//RS485_RX_EN();	/* 切换RS485收发芯片为接收模式 */
;;;298        //USART_HalfDuplexCmd(USART2,ENABLE);
;;;299        	 
;;;300    //    GPIO_InitTypeDef GPIO_InitStructure={0};
;;;301    //    
;;;302    //    GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;	/* 输出类型为推挽 */
;;;303    //    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;	/* 内部上拉电阻使能 */
;;;304    //    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	/* 复用模式 */
;;;305    
;;;306    //    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
;;;307    //    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;308    //    GPIO_Init(GPIOD, &GPIO_InitStructure);
;;;309    ////    
;;;310    //    GPIO_ResetBits(GPIOD,GPIO_Pin_10);
;;;311        readOnly(USART2);
000002  8800              LDRH     r0,[r0,#0]
000004  f0400004          ORR      r0,r0,#4
000008  4903              LDR      r1,|L7.24|
00000a  8008              STRH     r0,[r1,#0]
00000c  4608              MOV      r0,r1
00000e  8800              LDRH     r0,[r0,#0]
000010  f0200008          BIC      r0,r0,#8
000014  8008              STRH     r0,[r1,#0]
;;;312    }
000016  4770              BX       lr
;;;313    
                          ENDP

                  |L7.24|
                          DCD      0x4000440c

                          AREA ||i.UartGetChar||, CODE, READONLY, ALIGN=1

                  UartGetChar PROC
;;;1029   */
;;;1030   static uint8_t UartGetChar(UART_T *_pUart, uint8_t *_pByte)
000000  b570              PUSH     {r4-r6,lr}
;;;1031   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1032   	uint16_t usCount;
;;;1033   
;;;1034   	/* usRxWrite 变量在中断函数中被改写，主程序读取该变量时，必须进行临界区保护 */
;;;1035   	DISABLE_INT();
000006  2001              MOVS     r0,#1
000008  f7fffffe          BL       __set_PRIMASK
;;;1036   	usCount = _pUart->usRxCount;
00000c  8b66              LDRH     r6,[r4,#0x1a]
;;;1037   	ENABLE_INT();
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       __set_PRIMASK
;;;1038   
;;;1039   	/* 如果读和写索引相同，则返回0 */
;;;1040   	//if (_pUart->usRxRead == usRxWrite)
;;;1041   	if (usCount == 0)	/* 已经没有数据 */
000014  b90e              CBNZ     r6,|L8.26|
;;;1042   	{
;;;1043   		return 0;
000016  2000              MOVS     r0,#0
                  |L8.24|
;;;1044   	}
;;;1045   	else
;;;1046   	{
;;;1047   		*_pByte = _pUart->pRxBuf[_pUart->usRxRead];		/* 从串口接收FIFO取1个数据 */
;;;1048   
;;;1049   		/* 改写FIFO读索引 */
;;;1050   		DISABLE_INT();
;;;1051   		if (++_pUart->usRxRead >= _pUart->usRxBufSize)
;;;1052   		{
;;;1053   			_pUart->usRxRead = 0;
;;;1054   		}
;;;1055   		_pUart->usRxCount--;
;;;1056   		ENABLE_INT();
;;;1057   		return 1;
;;;1058   	}
;;;1059   }
000018  bd70              POP      {r4-r6,pc}
                  |L8.26|
00001a  8b21              LDRH     r1,[r4,#0x18]         ;1047
00001c  68a0              LDR      r0,[r4,#8]            ;1047
00001e  5c40              LDRB     r0,[r0,r1]            ;1047
000020  7028              STRB     r0,[r5,#0]            ;1047
000022  2001              MOVS     r0,#1                 ;1050
000024  f7fffffe          BL       __set_PRIMASK
000028  8b20              LDRH     r0,[r4,#0x18]         ;1051
00002a  1c40              ADDS     r0,r0,#1              ;1051
00002c  b280              UXTH     r0,r0                 ;1051
00002e  8320              STRH     r0,[r4,#0x18]         ;1051
000030  89e1              LDRH     r1,[r4,#0xe]          ;1051
000032  4288              CMP      r0,r1                 ;1051
000034  db01              BLT      |L8.58|
000036  2000              MOVS     r0,#0                 ;1053
000038  8320              STRH     r0,[r4,#0x18]         ;1053
                  |L8.58|
00003a  8b60              LDRH     r0,[r4,#0x1a]         ;1055
00003c  1e40              SUBS     r0,r0,#1              ;1055
00003e  8360              STRH     r0,[r4,#0x1a]         ;1055
000040  2000              MOVS     r0,#0                 ;1056
000042  f7fffffe          BL       __set_PRIMASK
000046  2001              MOVS     r0,#1                 ;1057
000048  e7e6              B        |L8.24|
;;;1060   
                          ENDP


                          AREA ||i.UartIRQ||, CODE, READONLY, ALIGN=1

                  UartIRQ PROC
;;;1068   */
;;;1069   static void UartIRQ(UART_T *_pUart)
000000  b570              PUSH     {r4-r6,lr}
;;;1070   {
000002  4604              MOV      r4,r0
;;;1071   	/* 处理接收中断  */
;;;1072   	if (USART_GetITStatus(_pUart->uart, USART_IT_RXNE) != RESET)
000004  f2405125          MOV      r1,#0x525
000008  6820              LDR      r0,[r4,#0]
00000a  f7fffffe          BL       USART_GetITStatus
00000e  b1e0              CBZ      r0,|L9.74|
;;;1073   	{
;;;1074   		/* 从串口接收数据寄存器读取数据存放到接收FIFO */
;;;1075   		_pUart->pRxBuf[_pUart->usRxWrite] = USART_ReceiveData(_pUart->uart);
000010  6820              LDR      r0,[r4,#0]
000012  f7fffffe          BL       USART_ReceiveData
000016  8ae2              LDRH     r2,[r4,#0x16]
000018  68a1              LDR      r1,[r4,#8]
00001a  5488              STRB     r0,[r1,r2]
;;;1076   		if (++_pUart->usRxWrite >= _pUart->usRxBufSize)
00001c  8ae0              LDRH     r0,[r4,#0x16]
00001e  1c40              ADDS     r0,r0,#1
000020  b280              UXTH     r0,r0
000022  82e0              STRH     r0,[r4,#0x16]
000024  89e1              LDRH     r1,[r4,#0xe]
000026  4288              CMP      r0,r1
000028  db01              BLT      |L9.46|
;;;1077   		{
;;;1078   			_pUart->usRxWrite = 0;
00002a  2000              MOVS     r0,#0
00002c  82e0              STRH     r0,[r4,#0x16]
                  |L9.46|
;;;1079   		}
;;;1080   		if (_pUart->usRxCount < _pUart->usRxBufSize)
00002e  8b60              LDRH     r0,[r4,#0x1a]
000030  89e1              LDRH     r1,[r4,#0xe]
000032  4288              CMP      r0,r1
000034  da02              BGE      |L9.60|
;;;1081   		{
;;;1082   			_pUart->usRxCount++;
000036  8b60              LDRH     r0,[r4,#0x1a]
000038  1c40              ADDS     r0,r0,#1
00003a  8360              STRH     r0,[r4,#0x1a]
                  |L9.60|
;;;1083   		}
;;;1084   
;;;1085   		/* 回调函数,通知应用程序收到新数据,一般是发送1个消息或者设置一个标记 */
;;;1086   		//if (_pUart->usRxWrite == _pUart->usRxRead)
;;;1087   		if (_pUart->usRxCount == 1)
00003c  8b60              LDRH     r0,[r4,#0x1a]
00003e  2801              CMP      r0,#1
000040  d103              BNE      |L9.74|
;;;1088   		{
;;;1089   			if (_pUart->ReciveNew)
000042  6a60              LDR      r0,[r4,#0x24]
000044  b108              CBZ      r0,|L9.74|
;;;1090   			{
;;;1091   				_pUart->ReciveNew();
000046  6a60              LDR      r0,[r4,#0x24]
000048  4780              BLX      r0
                  |L9.74|
;;;1092   			}
;;;1093   		}		
;;;1094   	}
;;;1095       
;;;1096       if (USART_GetITStatus(_pUart->uart, USART_FLAG_ORE) != RESET) //过载，数据溢出（干扰数据错乱）
00004a  2108              MOVS     r1,#8
00004c  6820              LDR      r0,[r4,#0]
00004e  f7fffffe          BL       USART_GetITStatus
000052  b120              CBZ      r0,|L9.94|
;;;1097       {
;;;1098           uint16_t temp = USART_ReceiveData(_pUart->uart); //取出扔掉
000054  6820              LDR      r0,[r4,#0]
000056  f7fffffe          BL       USART_ReceiveData
00005a  4605              MOV      r5,r0
;;;1099           //USART_ClearFlag(_pUart->uart, USART_FLAG_ORE);
;;;1100       }
00005c  bf00              NOP      
                  |L9.94|
;;;1101   
;;;1102   	/* 处理发送缓冲区空中断 */
;;;1103   	if (USART_GetITStatus(_pUart->uart, USART_IT_TXE) != RESET)
00005e  f2407127          MOV      r1,#0x727
000062  6820              LDR      r0,[r4,#0]
000064  f7fffffe          BL       USART_GetITStatus
000068  b308              CBZ      r0,|L9.174|
;;;1104   	{
;;;1105   		//if (_pUart->usTxRead == _pUart->usTxWrite)
;;;1106   		if (_pUart->usTxCount == 0)
00006a  8aa0              LDRH     r0,[r4,#0x14]
00006c  b960              CBNZ     r0,|L9.136|
;;;1107   		{
;;;1108   			/* 发送缓冲区的数据已取完时， 禁止发送缓冲区空中断 （注意：此时最后1个数据还未真正发送完毕）*/
;;;1109   			USART_ITConfig(_pUart->uart, USART_IT_TXE, DISABLE);
00006e  2200              MOVS     r2,#0
000070  f2407127          MOV      r1,#0x727
000074  6820              LDR      r0,[r4,#0]
000076  f7fffffe          BL       USART_ITConfig
;;;1110   
;;;1111   			/* 使能数据发送完毕中断 */
;;;1112   			USART_ITConfig(_pUart->uart, USART_IT_TC, ENABLE);
00007a  2201              MOVS     r2,#1
00007c  f2406126          MOV      r1,#0x626
000080  6820              LDR      r0,[r4,#0]
000082  f7fffffe          BL       USART_ITConfig
000086  e037              B        |L9.248|
                  |L9.136|
;;;1113               /* 回调函数, 一般用来处理RS485通信，将RS485芯片设置为接收模式，避免抢占总线 */
;;;1114   //			if (_pUart->SendOver)
;;;1115   //			{
;;;1116   //				_pUart->SendOver();
;;;1117   //			}
;;;1118   		}
;;;1119   		else
;;;1120   		{
;;;1121   			/* 从发送FIFO取1个字节写入串口发送数据寄存器 */
;;;1122   			USART_SendData(_pUart->uart, _pUart->pTxBuf[_pUart->usTxRead]);
000088  8a63              LDRH     r3,[r4,#0x12]
00008a  6862              LDR      r2,[r4,#4]
00008c  5cd1              LDRB     r1,[r2,r3]
00008e  6820              LDR      r0,[r4,#0]
000090  f7fffffe          BL       USART_SendData
;;;1123   			if (++_pUart->usTxRead >= _pUart->usTxBufSize)
000094  8a60              LDRH     r0,[r4,#0x12]
000096  1c40              ADDS     r0,r0,#1
000098  b280              UXTH     r0,r0
00009a  8260              STRH     r0,[r4,#0x12]
00009c  89a1              LDRH     r1,[r4,#0xc]
00009e  4288              CMP      r0,r1
0000a0  db01              BLT      |L9.166|
;;;1124   			{
;;;1125   				_pUart->usTxRead = 0;
0000a2  2000              MOVS     r0,#0
0000a4  8260              STRH     r0,[r4,#0x12]
                  |L9.166|
;;;1126   			}
;;;1127   			_pUart->usTxCount--;
0000a6  8aa0              LDRH     r0,[r4,#0x14]
0000a8  1e40              SUBS     r0,r0,#1
0000aa  82a0              STRH     r0,[r4,#0x14]
0000ac  e024              B        |L9.248|
                  |L9.174|
;;;1128   		}
;;;1129   
;;;1130   	}
;;;1131   	/* 数据bit位全部发送完毕的中断 */
;;;1132   	else if (USART_GetITStatus(_pUart->uart, USART_IT_TC) != RESET)
0000ae  f2406126          MOV      r1,#0x626
0000b2  6820              LDR      r0,[r4,#0]
0000b4  f7fffffe          BL       USART_GetITStatus
0000b8  b1f0              CBZ      r0,|L9.248|
;;;1133   	{
;;;1134   		//if (_pUart->usTxRead == _pUart->usTxWrite)
;;;1135   		if (_pUart->usTxCount == 0)
0000ba  8aa0              LDRH     r0,[r4,#0x14]
0000bc  b950              CBNZ     r0,|L9.212|
;;;1136   		{
;;;1137   			/* 如果发送FIFO的数据全部发送完毕，禁止数据发送完毕中断 */
;;;1138   			USART_ITConfig(_pUart->uart, USART_IT_TC, DISABLE);
0000be  2200              MOVS     r2,#0
0000c0  f2406126          MOV      r1,#0x626
0000c4  6820              LDR      r0,[r4,#0]
0000c6  f7fffffe          BL       USART_ITConfig
;;;1139   
;;;1140   			/* 回调函数, 一般用来处理RS485通信，将RS485芯片设置为接收模式，避免抢占总线 */
;;;1141   			if (_pUart->SendOver)
0000ca  6a20              LDR      r0,[r4,#0x20]
0000cc  b1a0              CBZ      r0,|L9.248|
;;;1142   			{
;;;1143   				_pUart->SendOver();
0000ce  6a20              LDR      r0,[r4,#0x20]
0000d0  4780              BLX      r0
0000d2  e011              B        |L9.248|
                  |L9.212|
;;;1144                   
;;;1145   			}
;;;1146   		}
;;;1147   		else
;;;1148   		{
;;;1149   			/* 正常情况下，不会进入此分支 */
;;;1150   			
;;;1151   			/* 如果发送FIFO的数据还未完毕，则从发送FIFO取1个数据写入发送数据寄存器 */
;;;1152   			USART_SendData(_pUart->uart, _pUart->pTxBuf[_pUart->usTxRead]);
0000d4  8a63              LDRH     r3,[r4,#0x12]
0000d6  6862              LDR      r2,[r4,#4]
0000d8  5cd1              LDRB     r1,[r2,r3]
0000da  6820              LDR      r0,[r4,#0]
0000dc  f7fffffe          BL       USART_SendData
;;;1153   			if (++_pUart->usTxRead >= _pUart->usTxBufSize)
0000e0  8a60              LDRH     r0,[r4,#0x12]
0000e2  1c40              ADDS     r0,r0,#1
0000e4  b280              UXTH     r0,r0
0000e6  8260              STRH     r0,[r4,#0x12]
0000e8  89a1              LDRH     r1,[r4,#0xc]
0000ea  4288              CMP      r0,r1
0000ec  db01              BLT      |L9.242|
;;;1154   			{
;;;1155   				_pUart->usTxRead = 0;
0000ee  2000              MOVS     r0,#0
0000f0  8260              STRH     r0,[r4,#0x12]
                  |L9.242|
;;;1156   			}
;;;1157   			_pUart->usTxCount--;
0000f2  8aa0              LDRH     r0,[r4,#0x14]
0000f4  1e40              SUBS     r0,r0,#1
0000f6  82a0              STRH     r0,[r4,#0x14]
                  |L9.248|
;;;1158   		}
;;;1159   	}
;;;1160   }
0000f8  bd70              POP      {r4-r6,pc}
;;;1161   
                          ENDP


                          AREA ||i.UartSend||, CODE, READONLY, ALIGN=1

                  UartSend PROC
;;;914    #if 1
;;;915    static void UartSend(UART_T *_pUart, uint8_t *_ucaBuf, uint16_t _usLen)
000000  b5f8              PUSH     {r3-r7,lr}
;;;916    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;917            uint16_t i;
;;;918    
;;;919            for (i = 0; i < _usLen; i++)
000008  2500              MOVS     r5,#0
00000a  e039              B        |L10.128|
                  |L10.12|
;;;920            {
;;;921                    /* 如果发送缓冲区已经满了，则等待缓冲区空 */
;;;922                    while (1)
00000c  e01e              B        |L10.76|
                  |L10.14|
;;;923                    {
;;;924                            __IO uint16_t usCount;
;;;925    
;;;926                            DISABLE_INT();
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       __set_PRIMASK
;;;927                            usCount = _pUart->usTxCount;
000014  8aa0              LDRH     r0,[r4,#0x14]
000016  9000              STR      r0,[sp,#0]
;;;928                            ENABLE_INT();
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       __set_PRIMASK
;;;929    
;;;930                            if (usCount < _pUart->usTxBufSize)
00001e  89a0              LDRH     r0,[r4,#0xc]
000020  f8bd1000          LDRH     r1,[sp,#0]
000024  4288              CMP      r0,r1
000026  dd00              BLE      |L10.42|
;;;931                            {
;;;932                                    break;
000028  e011              B        |L10.78|
                  |L10.42|
;;;933                            }
;;;934                            else if(usCount == _pUart->usTxBufSize)/* 数据已填满缓冲区 */
00002a  89a0              LDRH     r0,[r4,#0xc]
00002c  f8bd1000          LDRH     r1,[sp,#0]
000030  4288              CMP      r0,r1
000032  d10a              BNE      |L10.74|
;;;935                            {
;;;936                                    if((_pUart->uart->CR1 & USART_CR1_TXEIE) == 0)
000034  6820              LDR      r0,[r4,#0]
000036  8980              LDRH     r0,[r0,#0xc]
000038  f0000080          AND      r0,r0,#0x80
00003c  b928              CBNZ     r0,|L10.74|
;;;937                                    {
;;;938                                            USART_ITConfig(_pUart->uart, USART_IT_TXE, ENABLE);
00003e  2201              MOVS     r2,#1
000040  f2407127          MOV      r1,#0x727
000044  6820              LDR      r0,[r4,#0]
000046  f7fffffe          BL       USART_ITConfig
                  |L10.74|
;;;939                                    }  
;;;940                            }
;;;941                    }
00004a  bf00              NOP      
                  |L10.76|
00004c  e7df              B        |L10.14|
                  |L10.78|
00004e  bf00              NOP                            ;932
;;;942    
;;;943                    /* 将新数据填入发送缓冲区 */
;;;944                    _pUart->pTxBuf[_pUart->usTxWrite] = _ucaBuf[i];
000050  5d70              LDRB     r0,[r6,r5]
000052  8a22              LDRH     r2,[r4,#0x10]
000054  6861              LDR      r1,[r4,#4]
000056  5488              STRB     r0,[r1,r2]
;;;945    
;;;946                    DISABLE_INT();
000058  2001              MOVS     r0,#1
00005a  f7fffffe          BL       __set_PRIMASK
;;;947                    if (++_pUart->usTxWrite >= _pUart->usTxBufSize)
00005e  8a20              LDRH     r0,[r4,#0x10]
000060  1c40              ADDS     r0,r0,#1
000062  b280              UXTH     r0,r0
000064  8220              STRH     r0,[r4,#0x10]
000066  89a1              LDRH     r1,[r4,#0xc]
000068  4288              CMP      r0,r1
00006a  db01              BLT      |L10.112|
;;;948                    {
;;;949                            _pUart->usTxWrite = 0;
00006c  2000              MOVS     r0,#0
00006e  8220              STRH     r0,[r4,#0x10]
                  |L10.112|
;;;950                    }
;;;951                    _pUart->usTxCount++;
000070  8aa0              LDRH     r0,[r4,#0x14]
000072  1c40              ADDS     r0,r0,#1
000074  82a0              STRH     r0,[r4,#0x14]
;;;952                    ENABLE_INT();
000076  2000              MOVS     r0,#0
000078  f7fffffe          BL       __set_PRIMASK
00007c  1c68              ADDS     r0,r5,#1              ;919
00007e  b285              UXTH     r5,r0                 ;919
                  |L10.128|
000080  42bd              CMP      r5,r7                 ;919
000082  dbc3              BLT      |L10.12|
;;;953            }
;;;954    
;;;955            USART_ITConfig(_pUart->uart, USART_IT_TXE, ENABLE);
000084  2201              MOVS     r2,#1
000086  f2407127          MOV      r1,#0x727
00008a  6820              LDR      r0,[r4,#0]
00008c  f7fffffe          BL       USART_ITConfig
;;;956    }
000090  bdf8              POP      {r3-r7,pc}
;;;957    
                          ENDP


                          AREA ||i.UartVarInit||, CODE, READONLY, ALIGN=2

                  UartVarInit PROC
;;;321    */
;;;322    static void UartVarInit(void)
000000  4815              LDR      r0,|L11.88|
;;;323    {
;;;324    #if UART1_FIFO_EN == 1
;;;325    	g_tUart1.uart = USART1;						/* STM32 串口设备 */
000002  4916              LDR      r1,|L11.92|
000004  6008              STR      r0,[r1,#0]  ; g_tUart1
;;;326    	g_tUart1.pTxBuf = g_TxBuf1;					/* 发送缓冲区指针 */
000006  4816              LDR      r0,|L11.96|
000008  6048              STR      r0,[r1,#4]  ; g_tUart1
;;;327    	g_tUart1.pRxBuf = g_RxBuf1;					/* 接收缓冲区指针 */
00000a  4816              LDR      r0,|L11.100|
00000c  6088              STR      r0,[r1,#8]  ; g_tUart1
;;;328    	g_tUart1.usTxBufSize = UART1_TX_BUF_SIZE;	/* 发送缓冲区大小 */
00000e  f44f5080          MOV      r0,#0x1000
000012  8188              STRH     r0,[r1,#0xc]
;;;329    	g_tUart1.usRxBufSize = UART1_RX_BUF_SIZE;	/* 接收缓冲区大小 */
000014  1080              ASRS     r0,r0,#2
000016  81c8              STRH     r0,[r1,#0xe]
;;;330    	g_tUart1.usTxWrite = 0;						/* 发送FIFO写索引 */
000018  2000              MOVS     r0,#0
00001a  8208              STRH     r0,[r1,#0x10]
;;;331    	g_tUart1.usTxRead = 0;						/* 发送FIFO读索引 */
00001c  8248              STRH     r0,[r1,#0x12]
;;;332    	g_tUart1.usRxWrite = 0;						/* 接收FIFO写索引 */
00001e  82c8              STRH     r0,[r1,#0x16]
;;;333    	g_tUart1.usRxRead = 0;						/* 接收FIFO读索引 */
000020  8308              STRH     r0,[r1,#0x18]
;;;334    	g_tUart1.usRxCount = 0;						/* 接收到的新数据个数 */
000022  8348              STRH     r0,[r1,#0x1a]
;;;335    	g_tUart1.usTxCount = 0;						/* 待发送的数据个数 */
000024  8288              STRH     r0,[r1,#0x14]
;;;336    	g_tUart1.SendBefor = 0;						/* 发送数据前的回调函数 */
000026  61c8              STR      r0,[r1,#0x1c]  ; g_tUart1
;;;337    	g_tUart1.SendOver = 0;						/* 发送完毕后的回调函数 */
000028  6208              STR      r0,[r1,#0x20]  ; g_tUart1
;;;338    	g_tUart1.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
00002a  6248              STR      r0,[r1,#0x24]  ; g_tUart1
;;;339    #endif
;;;340    
;;;341    #if UART2_FIFO_EN == 1
;;;342    	g_tUart2.uart = USART2;						/* STM32 串口设备 */
00002c  480e              LDR      r0,|L11.104|
00002e  490f              LDR      r1,|L11.108|
000030  6008              STR      r0,[r1,#0]  ; g_tUart2
;;;343    	g_tUart2.pTxBuf = g_TxBuf2;					/* 发送缓冲区指针 */
000032  480f              LDR      r0,|L11.112|
000034  6048              STR      r0,[r1,#4]  ; g_tUart2
;;;344    	g_tUart2.pRxBuf = g_RxBuf2;					/* 接收缓冲区指针 */
000036  480f              LDR      r0,|L11.116|
000038  6088              STR      r0,[r1,#8]  ; g_tUart2
;;;345    	g_tUart2.usTxBufSize = UART2_TX_BUF_SIZE;	/* 发送缓冲区大小 */
00003a  f44f5080          MOV      r0,#0x1000
00003e  8188              STRH     r0,[r1,#0xc]
;;;346    	g_tUart2.usRxBufSize = UART2_RX_BUF_SIZE;	/* 接收缓冲区大小 */
000040  81c8              STRH     r0,[r1,#0xe]
;;;347    	g_tUart2.usTxWrite = 0;						/* 发送FIFO写索引 */
000042  2000              MOVS     r0,#0
000044  8208              STRH     r0,[r1,#0x10]
;;;348    	g_tUart2.usTxRead = 0;						/* 发送FIFO读索引 */
000046  8248              STRH     r0,[r1,#0x12]
;;;349    	g_tUart2.usRxWrite = 0;						/* 接收FIFO写索引 */
000048  82c8              STRH     r0,[r1,#0x16]
;;;350    	g_tUart2.usRxRead = 0;						/* 接收FIFO读索引 */
00004a  8308              STRH     r0,[r1,#0x18]
;;;351    	g_tUart2.usRxCount = 0;						/* 接收到的新数据个数 */
00004c  8348              STRH     r0,[r1,#0x1a]
;;;352    	g_tUart2.usTxCount = 0;						/* 待发送的数据个数 */	
00004e  8288              STRH     r0,[r1,#0x14]
;;;353    	g_tUart2.SendBefor = 0;//USART2_SendBefor;						/* 发送数据前的回调函数 */
000050  61c8              STR      r0,[r1,#0x1c]  ; g_tUart2
;;;354    	g_tUart2.SendOver = 0;//USART2_SendOver;						/* 发送完毕后的回调函数 */
000052  6208              STR      r0,[r1,#0x20]  ; g_tUart2
;;;355    	g_tUart2.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
000054  6248              STR      r0,[r1,#0x24]  ; g_tUart2
;;;356    #endif
;;;357    
;;;358    #if UART3_FIFO_EN == 1
;;;359    	g_tUart3.uart = USART3;						/* STM32 串口设备 */
;;;360    	g_tUart3.pTxBuf = g_TxBuf3;					/* 发送缓冲区指针 */
;;;361    	g_tUart3.pRxBuf = g_RxBuf3;					/* 接收缓冲区指针 */
;;;362    	g_tUart3.usTxBufSize = UART3_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;363    	g_tUart3.usRxBufSize = UART3_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;364    	g_tUart3.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;365    	g_tUart3.usTxRead = 0;						/* 发送FIFO读索引 */
;;;366    	g_tUart3.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;367    	g_tUart3.usRxRead = 0;						/* 接收FIFO读索引 */
;;;368    	g_tUart3.usRxCount = 0;						/* 接收到的新数据个数 */
;;;369    	g_tUart3.usTxCount = 0;						/* 待发送的数据个数 */	
;;;370    	g_tUart3.SendBefor = USART3_SendBefor;		/* 发送数据前的回调函数 */
;;;371    	g_tUart3.SendOver = USART3_SendOver;		/* 发送完毕后的回调函数 */
;;;372    	g_tUart3.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
;;;373    #endif
;;;374    
;;;375    #if UART4_FIFO_EN == 1
;;;376    	g_tUart4.uart = UART4;						/* STM32 串口设备 */
;;;377    	g_tUart4.pTxBuf = g_TxBuf4;					/* 发送缓冲区指针 */
;;;378    	g_tUart4.pRxBuf = g_RxBuf4;					/* 接收缓冲区指针 */
;;;379    	g_tUart4.usTxBufSize = UART4_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;380    	g_tUart4.usRxBufSize = UART4_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;381    	g_tUart4.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;382    	g_tUart4.usTxRead = 0;						/* 发送FIFO读索引 */
;;;383    	g_tUart4.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;384    	g_tUart4.usRxRead = 0;						/* 接收FIFO读索引 */
;;;385    	g_tUart4.usRxCount = 0;						/* 接收到的新数据个数 */
;;;386    	g_tUart4.usTxCount = 0;						/* 待发送的数据个数 */	
;;;387    	g_tUart4.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;388    	g_tUart4.SendOver = 0;						/* 发送完毕后的回调函数 */
;;;389    	g_tUart4.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
;;;390    #endif
;;;391    
;;;392    #if UART5_FIFO_EN == 1
;;;393    	g_tUart5.uart = UART5;						/* STM32 串口设备 */
;;;394    	g_tUart5.pTxBuf = g_TxBuf5;					/* 发送缓冲区指针 */
;;;395    	g_tUart5.pRxBuf = g_RxBuf5;					/* 接收缓冲区指针 */
;;;396    	g_tUart5.usTxBufSize = UART5_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;397    	g_tUart5.usRxBufSize = UART5_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;398    	g_tUart5.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;399    	g_tUart5.usTxRead = 0;						/* 发送FIFO读索引 */
;;;400    	g_tUart5.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;401    	g_tUart5.usRxRead = 0;						/* 接收FIFO读索引 */
;;;402    	g_tUart5.usRxCount = 0;						/* 接收到的新数据个数 */
;;;403    	g_tUart5.usTxCount = 0;						/* 待发送的数据个数 */	
;;;404    	g_tUart5.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;405    	g_tUart5.SendOver = 0;						/* 发送完毕后的回调函数 */
;;;406    	g_tUart5.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
;;;407    #endif
;;;408    
;;;409    
;;;410    #if UART6_FIFO_EN == 1
;;;411    	g_tUart6.uart = USART6;						/* STM32 串口设备 */
;;;412    	g_tUart6.pTxBuf = g_TxBuf6;					/* 发送缓冲区指针 */
;;;413    	g_tUart6.pRxBuf = g_RxBuf6;					/* 接收缓冲区指针 */
;;;414    	g_tUart6.usTxBufSize = UART6_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;415    	g_tUart6.usRxBufSize = UART6_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;416    	g_tUart6.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;417    	g_tUart6.usTxRead = 0;						/* 发送FIFO读索引 */
;;;418    	g_tUart6.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;419    	g_tUart6.usRxRead = 0;						/* 接收FIFO读索引 */
;;;420    	g_tUart6.usRxCount = 0;						/* 接收到的新数据个数 */
;;;421    	g_tUart6.usTxCount = 0;						/* 待发送的数据个数 */	
;;;422    	g_tUart6.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;423    	g_tUart6.SendOver = 0;						/* 发送完毕后的回调函数 */
;;;424    	g_tUart6.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
;;;425    #endif
;;;426    }
000056  4770              BX       lr
;;;427    
                          ENDP

                  |L11.88|
                          DCD      0x40011000
                  |L11.92|
                          DCD      g_tUart1
                  |L11.96|
                          DCD      g_TxBuf1
                  |L11.100|
                          DCD      g_RxBuf1
                  |L11.104|
                          DCD      0x40004400
                  |L11.108|
                          DCD      g_tUart2
                  |L11.112|
                          DCD      g_TxBuf2
                  |L11.116|
                          DCD      g_RxBuf2

                          AREA ||i.__set_PRIMASK||, CODE, READONLY, ALIGN=1

                  __set_PRIMASK PROC
;;;193     */
;;;194    __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
000000  f3808810          MSR      PRIMASK,r0
;;;195    {
;;;196      register uint32_t __regPriMask         __ASM("primask");
;;;197      __regPriMask = (priMask);
;;;198    }
000004  4770              BX       lr
;;;199    
                          ENDP


                          AREA ||i.bsp_InitUart||, CODE, READONLY, ALIGN=1

                  bsp_InitUart PROC
;;;73     */
;;;74     void bsp_InitUart(void)
000000  b510              PUSH     {r4,lr}
;;;75     {
;;;76     	UartVarInit();		/* 必须先初始化全局变量,再配置硬件 */
000002  f7fffffe          BL       UartVarInit
;;;77     
;;;78     	InitHardUart();		/* 配置串口的硬件参数(波特率等) */
000006  f7fffffe          BL       InitHardUart
;;;79     
;;;80     	ConfigUartNVIC();	/* 配置串口中断 */
00000a  f7fffffe          BL       ConfigUartNVIC
;;;81     }
00000e  bd10              POP      {r4,pc}
;;;82     
                          ENDP


                          AREA ||i.comClearRxFifo||, CODE, READONLY, ALIGN=1

                  comClearRxFifo PROC
;;;242    */
;;;243    void comClearRxFifo(COM_PORT_E _ucPort)
000000  b500              PUSH     {lr}
;;;244    {
000002  4603              MOV      r3,r0
;;;245    	UART_T *pUart;
;;;246    
;;;247    	pUart = ComToUart(_ucPort);
000004  4618              MOV      r0,r3
000006  f7fffffe          BL       ComToUart
00000a  4602              MOV      r2,r0
;;;248    	if (pUart == 0)
00000c  b902              CBNZ     r2,|L14.16|
                  |L14.14|
;;;249    	{
;;;250    		return;
;;;251    	}
;;;252    
;;;253    	pUart->usRxWrite = 0;
;;;254    	pUart->usRxRead = 0;
;;;255    	pUart->usRxCount = 0;
;;;256    }
00000e  bd00              POP      {pc}
                  |L14.16|
000010  2000              MOVS     r0,#0                 ;253
000012  82d0              STRH     r0,[r2,#0x16]         ;253
000014  8310              STRH     r0,[r2,#0x18]         ;254
000016  8350              STRH     r0,[r2,#0x1a]         ;255
000018  bf00              NOP      
00001a  e7f8              B        |L14.14|
;;;257    
                          ENDP


                          AREA ||i.comClearTxFifo||, CODE, READONLY, ALIGN=1

                  comClearTxFifo PROC
;;;219    */
;;;220    void comClearTxFifo(COM_PORT_E _ucPort)
000000  b500              PUSH     {lr}
;;;221    {
000002  4603              MOV      r3,r0
;;;222    	UART_T *pUart;
;;;223    
;;;224    	pUart = ComToUart(_ucPort);
000004  4618              MOV      r0,r3
000006  f7fffffe          BL       ComToUart
00000a  4602              MOV      r2,r0
;;;225    	if (pUart == 0)
00000c  b902              CBNZ     r2,|L15.16|
                  |L15.14|
;;;226    	{
;;;227    		return;
;;;228    	}
;;;229    
;;;230    	pUart->usTxWrite = 0;
;;;231    	pUart->usTxRead = 0;
;;;232    	pUart->usTxCount = 0;
;;;233    }
00000e  bd00              POP      {pc}
                  |L15.16|
000010  2000              MOVS     r0,#0                 ;230
000012  8210              STRH     r0,[r2,#0x10]         ;230
000014  8250              STRH     r0,[r2,#0x12]         ;231
000016  8290              STRH     r0,[r2,#0x14]         ;232
000018  bf00              NOP      
00001a  e7f8              B        |L15.14|
;;;234    
                          ENDP


                          AREA ||i.comGetChar||, CODE, READONLY, ALIGN=1

                  comGetChar PROC
;;;198    */
;;;199    uint8_t comGetChar(COM_PORT_E _ucPort, uint8_t *_pByte)
000000  b570              PUSH     {r4-r6,lr}
;;;200    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;201    	UART_T *pUart;
;;;202    
;;;203    	pUart = ComToUart(_ucPort);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       ComToUart
00000c  4604              MOV      r4,r0
;;;204    	if (pUart == 0)
00000e  b90c              CBNZ     r4,|L16.20|
;;;205    	{
;;;206    		return 0;
000010  2000              MOVS     r0,#0
                  |L16.18|
;;;207    	}
;;;208    
;;;209    	return UartGetChar(pUart, _pByte);
;;;210    }
000012  bd70              POP      {r4-r6,pc}
                  |L16.20|
000014  4631              MOV      r1,r6                 ;209
000016  4620              MOV      r0,r4                 ;209
000018  f7fffffe          BL       UartGetChar
00001c  e7f9              B        |L16.18|
;;;211    
                          ENDP


                          AREA ||i.comSendBuf||, CODE, READONLY, ALIGN=1

                  comSendBuf PROC
;;;157    */
;;;158    void comSendBuf(COM_PORT_E _ucPort, uint8_t *_ucaBuf, uint16_t _usLen)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;159    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;160    	UART_T *pUart;
;;;161    
;;;162    	pUart = ComToUart(_ucPort);
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       ComToUart
000010  4604              MOV      r4,r0
;;;163    	if (pUart == 0)
000012  b90c              CBNZ     r4,|L17.24|
                  |L17.20|
;;;164    	{
;;;165    		return;
;;;166    	}
;;;167    
;;;168    	if (pUart->SendBefor != 0)
;;;169    	{
;;;170    		pUart->SendBefor();		/* 如果是RS485通信，可以在这个函数中将RS485设置为发送模式 */
;;;171    	}
;;;172    
;;;173    	UartSend(pUart, _ucaBuf, _usLen);
;;;174    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L17.24|
000018  69e0              LDR      r0,[r4,#0x1c]         ;168
00001a  b108              CBZ      r0,|L17.32|
00001c  69e0              LDR      r0,[r4,#0x1c]         ;170
00001e  4780              BLX      r0                    ;170
                  |L17.32|
000020  463a              MOV      r2,r7                 ;173
000022  4631              MOV      r1,r6                 ;173
000024  4620              MOV      r0,r4                 ;173
000026  f7fffffe          BL       UartSend
00002a  bf00              NOP      
00002c  e7f2              B        |L17.20|
;;;175    
                          ENDP


                          AREA ||i.comSendChar||, CODE, READONLY, ALIGN=1

                  comSendChar PROC
;;;184    */
;;;185    void comSendChar(COM_PORT_E _ucPort, uint8_t _ucByte)
000000  b513              PUSH     {r0,r1,r4,lr}
;;;186    {
000002  4604              MOV      r4,r0
;;;187    	comSendBuf(_ucPort, &_ucByte, 1);
000004  2201              MOVS     r2,#1
000006  a901              ADD      r1,sp,#4
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       comSendBuf
;;;188    }
00000e  bd1c              POP      {r2-r4,pc}
;;;189    
                          ENDP


                          AREA ||i.fgetc||, CODE, READONLY, ALIGN=1

                  fgetc PROC
;;;1245   */
;;;1246   int fgetc(FILE *f)
000000  b538              PUSH     {r3-r5,lr}
;;;1247   {
000002  4604              MOV      r4,r0
;;;1248   
;;;1249   #if 1	/* 从串口接收FIFO中取1个数据, 只有取到数据才返回 */
;;;1250   	uint8_t ucData;
;;;1251   
;;;1252   	while(comGetChar(COM1, &ucData) == 0);
000004  bf00              NOP      
                  |L19.6|
000006  4669              MOV      r1,sp
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       comGetChar
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L19.6|
;;;1253   
;;;1254   	return ucData;
000012  f89d0000          LDRB     r0,[sp,#0]
;;;1255   #else
;;;1256   	/* 等待串口1输入数据 */
;;;1257   	while (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET);
;;;1258   
;;;1259   	return (int)USART_ReceiveData(USART1);
;;;1260   #endif
;;;1261   }
000016  bd38              POP      {r3-r5,pc}
;;;1262   
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=1

                  fputc PROC
;;;1219   */
;;;1220   int fputc(int ch, FILE *f)
000000  b570              PUSH     {r4-r6,lr}
;;;1221   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1222   #if 1	/* 将需要printf的字符通过串口中断FIFO发送出去，printf函数会立即返回 */
;;;1223   	comSendChar(COM1, ch);
000006  b2e1              UXTB     r1,r4
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       comSendChar
;;;1224   
;;;1225   	return ch;
00000e  4620              MOV      r0,r4
;;;1226   #else	/* 采用阻塞方式发送每个字符,等待数据发送完毕 */
;;;1227   	/* 写一个字节到USART1 */
;;;1228   	USART_SendData(USART1, (uint8_t) ch);
;;;1229   
;;;1230   	/* 等待发送结束 */
;;;1231   	while (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET)
;;;1232   	{}
;;;1233   
;;;1234   	return ch;
;;;1235   #endif
;;;1236   }
000010  bd70              POP      {r4-r6,pc}
;;;1237   
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_tUart1
                          %        40
                  g_TxBuf1
                          %        4096
                  g_RxBuf1
                          %        1024
                  g_tUart2
                          %        40
                  g_TxBuf2
                          %        4096
                  g_RxBuf2
                          %        4096

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\src\\bsp_uart_fifo.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_uart_fifo_c_b28b0d00____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_bsp_uart_fifo_c_b28b0d00____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_uart_fifo_c_b28b0d00____REVSH|
#line 144
|__asm___15_bsp_uart_fifo_c_b28b0d00____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
