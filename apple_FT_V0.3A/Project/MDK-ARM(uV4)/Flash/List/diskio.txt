; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\flash\obj\diskio.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\diskio.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\User -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\User\FatFS\src -I..\..\Libraries\STM32_USB_Device_Library\Class\msc\inc -I..\..\Libraries\STM32_USB_Device_Library\Core\inc -I..\..\Libraries\STM32_USB_OTG_Driver\inc -I..\..\User\usbd_mass_storage -I..\..\User\ft_support -I..\..\User\test -I..\..\User\emenu -I..\..\User\chip_ft -I..\..\User\lwrb -I..\..\User\easylogger\inc -I..\..\User\easylogger\plugins\file -I..\..\User\LOG -I..\..\User\MultiButton-1.1.0 -I..\..\User\cm_backtrace -I..\..\User\MultiTimer -I.\RTE\_Flash -IC:\Users\qizha\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\qizha\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.17.1\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F407xx -D_RTE_ -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY --signed_chars --omf_browse=.\flash\obj\diskio.crf ..\..\User\FatFS\src\diskio.c]
                          THUMB

                          AREA ||i.disk_initialize||, CODE, READONLY, ALIGN=1

                  disk_initialize PROC
;;;17     /*-----------------------------------------------------------------------*/
;;;18     DSTATUS disk_initialize (
000000  b570              PUSH     {r4-r6,lr}
;;;19     	BYTE pdrv				/* Physical drive nmuber (0..) */
;;;20     )
;;;21     {
000002  4604              MOV      r4,r0
;;;22     	DSTATUS stat = STA_NOINIT;
000004  2501              MOVS     r5,#1
;;;23     	
;;;24     	switch (pdrv) {
000006  b114              CBZ      r4,|L1.14|
000008  2c01              CMP      r4,#1
00000a  d10a              BNE      |L1.34|
00000c  e003              B        |L1.22|
                  |L1.14|
;;;25     
;;;26     		case FS_SPI_FLASH :
;;;27     			bsp_InitSFlash();
00000e  f7fffffe          BL       bsp_InitSFlash
;;;28     			stat =  RES_OK;
000012  2500              MOVS     r5,#0
;;;29     			break;
000014  e005              B        |L1.34|
                  |L1.22|
;;;30     		
;;;31     		case FS_SD :		
;;;32     			if (SD_Init() == SD_OK)
000016  f7fffffe          BL       SD_Init
00001a  b908              CBNZ     r0,|L1.32|
;;;33     			{
;;;34     				stat = RES_OK;
00001c  2500              MOVS     r5,#0
00001e  e000              B        |L1.34|
                  |L1.32|
;;;35     			}
;;;36     			else
;;;37     			{
;;;38     				stat = STA_NODISK;
000020  2502              MOVS     r5,#2
                  |L1.34|
000022  bf00              NOP                            ;29
;;;39     			}	
;;;40     	}
;;;41     	return stat;
000024  4628              MOV      r0,r5
;;;42     }
000026  bd70              POP      {r4-r6,pc}
;;;43     
                          ENDP


                          AREA ||i.disk_ioctl||, CODE, READONLY, ALIGN=2

                  disk_ioctl PROC
;;;199    #if _USE_IOCTL
;;;200    DRESULT disk_ioctl (
000000  4603              MOV      r3,r0
;;;201    	BYTE pdrv,		/* Physical drive nmuber (0..) */
;;;202    	BYTE cmd,		/* Control code */
;;;203    	void *buff		/* Buffer to send/receive control data */
;;;204    )
;;;205    {
;;;206    	
;;;207    	switch (pdrv) {
000002  b113              CBZ      r3,|L2.10|
000004  2b01              CMP      r3,#1
000006  d121              BNE      |L2.76|
000008  e018              B        |L2.60|
                  |L2.10|
;;;208    		
;;;209    	case FS_SPI_FLASH :
;;;210    		switch(cmd)
00000a  2905              CMP      r1,#5
00000c  d215              BCS      |L2.58|
00000e  e8dff001          TBB      [pc,r1]
000012  030a              DCB      0x03,0x0a
000014  05101200          DCB      0x05,0x10,0x12,0x00
;;;211    		{
;;;212    			/* SPI Flash不需要同步 */
;;;213    			case CTRL_SYNC :  
;;;214    				return RES_OK;
000018  2000              MOVS     r0,#0
                  |L2.26|
;;;215    			
;;;216    			/* 返回SPI Flash扇区大小 */
;;;217    			case GET_SECTOR_SIZE:
;;;218    				*((WORD *)buff) = 4096;  
;;;219    				return RES_OK;
;;;220    			
;;;221    			/* 返回SPI Flash扇区数 */
;;;222    			case GET_SECTOR_COUNT:
;;;223    				*((DWORD *)buff) = g_tSF.TotalSize/4096;    
;;;224    				return RES_OK;
;;;225    			
;;;226    			/* 下面这两项暂时未用 */
;;;227    			case GET_BLOCK_SIZE:   
;;;228    				return RES_OK;
;;;229    			
;;;230    			case CTRL_ERASE_SECTOR:
;;;231    				return RES_OK;       
;;;232    		}
;;;233    		
;;;234    	 case FS_SD :
;;;235    		{	
;;;236    		   switch(cmd)
;;;237    		   {
;;;238    			/* 返回SD扇区大小 */
;;;239    			case GET_SECTOR_SIZE:
;;;240    				*((WORD *)buff) = 512;  
;;;241    				return RES_OK;
;;;242    			
;;;243    			default:
;;;244    				return RES_OK;    
;;;245    		   }  
;;;246    	   }		   
;;;247    	}
;;;248    	
;;;249    	return RES_PARERR;
;;;250    }
00001a  4770              BX       lr
00001c  f44f5080          MOV      r0,#0x1000            ;218
000020  8010              STRH     r0,[r2,#0]            ;218
000022  2000              MOVS     r0,#0                 ;219
000024  e7f9              B        |L2.26|
000026  480a              LDR      r0,|L2.80|
000028  6940              LDR      r0,[r0,#0x14]         ;223  ; g_tSF
00002a  0b00              LSRS     r0,r0,#12             ;223
00002c  6010              STR      r0,[r2,#0]            ;223
00002e  2000              MOVS     r0,#0                 ;224
000030  e7f3              B        |L2.26|
000032  2000              MOVS     r0,#0                 ;228
000034  e7f1              B        |L2.26|
000036  2000              MOVS     r0,#0                 ;231
000038  e7ef              B        |L2.26|
                  |L2.58|
00003a  bf00              NOP                            ;234
                  |L2.60|
00003c  2902              CMP      r1,#2                 ;236
00003e  d103              BNE      |L2.72|
000040  0208              LSLS     r0,r1,#8              ;240
000042  8010              STRH     r0,[r2,#0]            ;240
000044  2000              MOVS     r0,#0                 ;241
000046  e7e8              B        |L2.26|
                  |L2.72|
000048  2000              MOVS     r0,#0                 ;244
00004a  e7e6              B        |L2.26|
                  |L2.76|
00004c  2004              MOVS     r0,#4                 ;249
00004e  e7e4              B        |L2.26|
;;;251    #endif
                          ENDP

                  |L2.80|
                          DCD      g_tSF

                          AREA ||i.disk_read||, CODE, READONLY, ALIGN=1

                  disk_read PROC
;;;69     
;;;70     DRESULT disk_read (
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;71     	BYTE pdrv,		/* Physical drive nmuber (0..) */
;;;72     	BYTE *buff,		/* Data buffer to store read data */
;;;73     	DWORD sector,	/* Sector address (LBA) */
;;;74     	BYTE count		/* Number of sectors to read (1..128) */
;;;75     )
;;;76     {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;77     	DRESULT res = RES_PARERR;
00000c  f04f0904          MOV      r9,#4
;;;78     	
;;;79     	switch (pdrv) {
000010  b116              CBZ      r6,|L3.24|
000012  2e01              CMP      r6,#1
000014  d137              BNE      |L3.134|
000016  e007              B        |L3.40|
                  |L3.24|
;;;80     
;;;81     		case FS_SPI_FLASH :
;;;82     			sf_ReadBuffer(buff, sector << 12, count<<12);
000018  032a              LSLS     r2,r5,#12
00001a  0321              LSLS     r1,r4,#12
00001c  4638              MOV      r0,r7
00001e  f7fffffe          BL       sf_ReadBuffer
;;;83     			res =  RES_OK;
000022  f04f0900          MOV      r9,#0
;;;84     			break;
000026  e02e              B        |L3.134|
                  |L3.40|
;;;85     		
;;;86     		case FS_SD :
;;;87     		{
;;;88     			SD_Error Status = SD_OK;
000028  f04f0800          MOV      r8,#0
;;;89     
;;;90     			if (count == 1)
00002c  2d01              CMP      r5,#1
00002e  d109              BNE      |L3.68|
;;;91     			{
;;;92     				Status = SD_ReadBlock(buff, sector << 9 , SECTOR_SIZE);
000030  0268              LSLS     r0,r5,#9
000032  0261              LSLS     r1,r4,#9
000034  460a              MOV      r2,r1
000036  2300              MOVS     r3,#0
000038  9000              STR      r0,[sp,#0]
00003a  4638              MOV      r0,r7
00003c  f7fffffe          BL       SD_ReadBlock
000040  4680              MOV      r8,r0
000042  e00a              B        |L3.90|
                  |L3.68|
;;;93     			}
;;;94     			else
;;;95     			{
;;;96     				Status = SD_ReadMultiBlocks(buff, sector << 9 , SECTOR_SIZE, count);
000044  f44f7000          MOV      r0,#0x200
000048  0261              LSLS     r1,r4,#9
00004a  460a              MOV      r2,r1
00004c  2300              MOVS     r3,#0
00004e  e9cd0500          STRD     r0,r5,[sp,#0]
000052  4638              MOV      r0,r7
000054  f7fffffe          BL       SD_ReadMultiBlocks
000058  4680              MOV      r8,r0
                  |L3.90|
;;;97     			}
;;;98     			if (Status != SD_OK)
00005a  f1b80f00          CMP      r8,#0
00005e  d002              BEQ      |L3.102|
;;;99     			{
;;;100    				res = RES_ERROR;
000060  f04f0901          MOV      r9,#1
;;;101    				break;
000064  e00f              B        |L3.134|
                  |L3.102|
;;;102    			}
;;;103    
;;;104    		#ifdef SD_DMA_MODE
;;;105    			Status = SD_WaitReadOperation();
000066  f7fffffe          BL       SD_WaitReadOperation
00006a  4680              MOV      r8,r0
;;;106    			if (Status != SD_OK)
00006c  f1b80f00          CMP      r8,#0
000070  d002              BEQ      |L3.120|
;;;107    			{
;;;108    				res = RES_ERROR;
000072  f04f0901          MOV      r9,#1
;;;109    				break;
000076  e006              B        |L3.134|
                  |L3.120|
;;;110    			}
;;;111    
;;;112    			while(SD_GetStatus() != SD_TRANSFER_OK);
000078  bf00              NOP      
                  |L3.122|
00007a  f7fffffe          BL       SD_GetStatus
00007e  2800              CMP      r0,#0
000080  d1fb              BNE      |L3.122|
;;;113    		#endif
;;;114    
;;;115    			res = RES_OK;
000082  4681              MOV      r9,r0
;;;116    			break;
000084  bf00              NOP      
                  |L3.134|
000086  bf00              NOP                            ;84
;;;117    		}
;;;118    
;;;119    	}
;;;120    	return res;
000088  4648              MOV      r0,r9
;;;121    }
00008a  e8bd87fc          POP      {r2-r10,pc}
;;;122    
                          ENDP


                          AREA ||i.disk_status||, CODE, READONLY, ALIGN=1

                  disk_status PROC
;;;46     /*-----------------------------------------------------------------------*/
;;;47     DSTATUS disk_status (
000000  4601              MOV      r1,r0
;;;48     	BYTE pdrv		/* Physical drive nmuber (0..) */
;;;49     )
;;;50     {
;;;51     	DSTATUS stat = STA_NOINIT;
000002  2001              MOVS     r0,#1
;;;52     
;;;53     	switch (pdrv)
000004  b111              CBZ      r1,|L4.12|
000006  2901              CMP      r1,#1
000008  d104              BNE      |L4.20|
00000a  e001              B        |L4.16|
                  |L4.12|
;;;54     	{
;;;55     		case FS_SPI_FLASH :
;;;56     			stat = 0;
00000c  2000              MOVS     r0,#0
;;;57     			break;
00000e  e001              B        |L4.20|
                  |L4.16|
;;;58     		
;;;59     		case FS_SD :
;;;60     			stat = 0;
000010  2000              MOVS     r0,#0
;;;61     			break;
000012  bf00              NOP      
                  |L4.20|
000014  bf00              NOP                            ;57
;;;62     	}
;;;63     	return stat;
;;;64     }
000016  4770              BX       lr
;;;65     
                          ENDP


                          AREA ||i.disk_write||, CODE, READONLY, ALIGN=1

                  disk_write PROC
;;;128    #if _USE_WRITE
;;;129    DRESULT disk_write (
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;130    	BYTE pdrv,			/* Physical drive nmuber (0..) */
;;;131    	const BYTE *buff,	/* Data to be written */
;;;132    	DWORD sector,		/* Sector address (LBA) */
;;;133    	BYTE count			/* Number of sectors to write (1..128) */
;;;134    )
;;;135    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;136    	switch (pdrv) {
00000c  b116              CBZ      r6,|L5.20|
00000e  2e01              CMP      r6,#1
000010  d138              BNE      |L5.132|
000012  e00a              B        |L5.42|
                  |L5.20|
;;;137    		
;;;138    		case FS_SPI_FLASH :
;;;139    			{
;;;140    			#if 0
;;;141    				uint8_t i;
;;;142    				BYTE *p;
;;;143    				
;;;144    				p = (BYTE *)buff;
;;;145    				for(i = 0; i < count; i++)
;;;146    				{
;;;147    					sf_WriteBuffer((uint8_t *)p, (sector+i) << 12, 4096);
;;;148    					p += 4096;					
;;;149    				}
;;;150    			#else
;;;151    				sf_WriteBuffer((uint8_t *)buff, sector << 12, count<<12);
000014  f64f70ff          MOV      r0,#0xffff
000018  ea003205          AND      r2,r0,r5,LSL #12
00001c  0321              LSLS     r1,r4,#12
00001e  4638              MOV      r0,r7
000020  f7fffffe          BL       sf_WriteBuffer
;;;152    			#endif
;;;153    				return RES_OK;
000024  2000              MOVS     r0,#0
                  |L5.38|
;;;154    			}
;;;155    			
;;;156    		case FS_SD :
;;;157    		{
;;;158    			SD_Error Status = SD_OK;
;;;159    
;;;160    			if (count == 1)
;;;161    			{
;;;162    				Status = SD_WriteBlock((uint8_t *)buff, sector << 9 ,SECTOR_SIZE);
;;;163    			}
;;;164    			else
;;;165    			{
;;;166    				
;;;167    				//Status = SD_WriteMultiBlocks((uint8_t *)buff, sector << 9 ,SECTOR_SIZE, count);
;;;168    				Status = SD_WriteMultiBlocks((uint8_t *)buff, sector << 9 ,SECTOR_SIZE, count + 1);
;;;169    			}
;;;170    			
;;;171    			if (Status != SD_OK)
;;;172    			{
;;;173    				return RES_ERROR;
;;;174    			}
;;;175    
;;;176    		#ifdef SD_DMA_MODE
;;;177    			Status = SD_WaitReadOperation();
;;;178    			if (Status != SD_OK)
;;;179    			{
;;;180    				return RES_ERROR;
;;;181    			}
;;;182    			while(SD_GetStatus() != SD_TRANSFER_OK);
;;;183    		#endif
;;;184    			
;;;185    			return RES_OK;
;;;186    		}
;;;187    	
;;;188    	}
;;;189    	
;;;190    	return RES_PARERR;
;;;191    }
000026  e8bd81fc          POP      {r2-r8,pc}
                  |L5.42|
00002a  f04f0800          MOV      r8,#0                 ;158
00002e  2d01              CMP      r5,#1                 ;160
000030  d109              BNE      |L5.70|
000032  0268              LSLS     r0,r5,#9              ;162
000034  0261              LSLS     r1,r4,#9              ;162
000036  460a              MOV      r2,r1                 ;162
000038  2300              MOVS     r3,#0                 ;162
00003a  9000              STR      r0,[sp,#0]            ;162
00003c  4638              MOV      r0,r7                 ;162
00003e  f7fffffe          BL       SD_WriteBlock
000042  4680              MOV      r8,r0                 ;162
000044  e00b              B        |L5.94|
                  |L5.70|
000046  1c68              ADDS     r0,r5,#1              ;168
000048  f44f7100          MOV      r1,#0x200             ;168
00004c  e9cd1000          STRD     r1,r0,[sp,#0]         ;168
000050  0261              LSLS     r1,r4,#9              ;168
000052  460a              MOV      r2,r1                 ;168
000054  2300              MOVS     r3,#0                 ;168
000056  4638              MOV      r0,r7                 ;168
000058  f7fffffe          BL       SD_WriteMultiBlocks
00005c  4680              MOV      r8,r0                 ;168
                  |L5.94|
00005e  f1b80f00          CMP      r8,#0                 ;171
000062  d001              BEQ      |L5.104|
000064  2001              MOVS     r0,#1                 ;173
000066  e7de              B        |L5.38|
                  |L5.104|
000068  f7fffffe          BL       SD_WaitReadOperation
00006c  4680              MOV      r8,r0                 ;177
00006e  f1b80f00          CMP      r8,#0                 ;178
000072  d001              BEQ      |L5.120|
000074  2001              MOVS     r0,#1                 ;180
000076  e7d6              B        |L5.38|
                  |L5.120|
000078  bf00              NOP                            ;182
                  |L5.122|
00007a  f7fffffe          BL       SD_GetStatus
00007e  2800              CMP      r0,#0                 ;182
000080  d1fb              BNE      |L5.122|
000082  e7d0              B        |L5.38|
                  |L5.132|
000084  2004              MOVS     r0,#4                 ;190
000086  e7ce              B        |L5.38|
;;;192    #endif
                          ENDP


                          AREA ||i.get_fattime||, CODE, READONLY, ALIGN=2

                  get_fattime PROC
;;;260    */
;;;261    DWORD get_fattime (void)
000000  4800              LDR      r0,|L6.4|
;;;262    {
;;;263    	/* 如果有全局时钟，可按下面的格式进行时钟转换. 这个例子是2013-01-01 00:00:00 */
;;;264    
;;;265    	return	  ((DWORD)(2013 - 1980) << 25)	/* Year = 2013 */
;;;266    			| ((DWORD)1 << 21)				/* Month = 1 */
;;;267    			| ((DWORD)1 << 16)				/* Day_m = 1*/
;;;268    			| ((DWORD)0 << 11)				/* Hour = 0 */
;;;269    			| ((DWORD)0 << 5)				/* Min = 0 */
;;;270    			| ((DWORD)0 >> 1);				/* Sec = 0 */
;;;271    }
000002  4770              BX       lr
;;;272    
                          ENDP

                  |L6.4|
                          DCD      0x42210000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\FatFS\\src\\diskio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_diskio_c_b3252454____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_diskio_c_b3252454____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_diskio_c_b3252454____REVSH|
#line 144
|__asm___8_diskio_c_b3252454____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
