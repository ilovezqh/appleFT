; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\flash\obj\bsp_apple_asu.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_apple_asu.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\User -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\User\FatFS\src -I..\..\Libraries\STM32_USB_Device_Library\Class\msc\inc -I..\..\Libraries\STM32_USB_Device_Library\Core\inc -I..\..\Libraries\STM32_USB_OTG_Driver\inc -I..\..\User\usbd_mass_storage -I..\..\User\ft_support -I..\..\User\test -I..\..\User\emenu -I..\..\User\chip_ft -I..\..\User\lwrb -I..\..\User\easylogger\inc -I..\..\User\easylogger\plugins\file -I..\..\User\LOG -I..\..\User\MultiButton-1.1.0 -I..\..\User\cm_backtrace -I..\..\User\MultiTimer -I.\RTE\_Flash -IC:\Users\qizha\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\qizha\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.17.1\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F407xx -D_RTE_ -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY --signed_chars --omf_browse=.\flash\obj\bsp_apple_asu.crf ..\..\User\bsp_stm32f4xx\src\bsp_apple_asu.c]
                          THUMB

                          AREA ||i.asu_Ack||, CODE, READONLY, ALIGN=2

                  asu_Ack PROC
;;;259    */
;;;260    void asu_Ack(void)
000000  b510              PUSH     {r4,lr}
;;;261    {
;;;262    	ASU_SDA_0();	/* CPU驱动SDA = 0 */
000002  2040              MOVS     r0,#0x40
000004  4908              LDR      r1,|L1.40|
000006  8348              STRH     r0,[r1,#0x1a]
;;;263    	asu_Delay();
000008  f7fffffe          BL       asu_Delay
;;;264    	ASU_SCL_1();	/* CPU产生1个时钟 */
00000c  2080              MOVS     r0,#0x80
00000e  4906              LDR      r1,|L1.40|
000010  8308              STRH     r0,[r1,#0x18]
;;;265    	asu_Delay();
000012  f7fffffe          BL       asu_Delay
;;;266    	ASU_SCL_0();
000016  2080              MOVS     r0,#0x80
000018  4903              LDR      r1,|L1.40|
00001a  8348              STRH     r0,[r1,#0x1a]
;;;267    	asu_Delay();
00001c  f7fffffe          BL       asu_Delay
;;;268    	ASU_SDA_1();	/* CPU释放SDA总线 */
000020  2040              MOVS     r0,#0x40
000022  4901              LDR      r1,|L1.40|
000024  8308              STRH     r0,[r1,#0x18]
;;;269    }
000026  bd10              POP      {r4,pc}
;;;270    
                          ENDP

                  |L1.40|
                          DCD      0x40020000

                          AREA ||i.asu_CheckDevice||, CODE, READONLY, ALIGN=2

                  asu_CheckDevice PROC
;;;296    */
;;;297    uint8_t asu_CheckDevice(uint8_t _Address)
000000  b570              PUSH     {r4-r6,lr}
;;;298    {
000002  4604              MOV      r4,r0
;;;299    	uint8_t ucAck;
;;;300    
;;;301    	if (ASU_SDA_READ() && ASU_SCL_READ())
000004  480b              LDR      r0,|L2.52|
000006  6900              LDR      r0,[r0,#0x10]
000008  f0000040          AND      r0,r0,#0x40
00000c  b180              CBZ      r0,|L2.48|
00000e  4809              LDR      r0,|L2.52|
000010  6900              LDR      r0,[r0,#0x10]
000012  f0000080          AND      r0,r0,#0x80
000016  b158              CBZ      r0,|L2.48|
;;;302    	{
;;;303    		asu_Start();		/* 发送启动信号 */
000018  f7fffffe          BL       asu_Start
;;;304    
;;;305    		/* 发送设备地址+读写控制bit（0 = w， 1 = r) bit7 先传 */
;;;306    		asu_SendByte(_Address | ASU_WR);
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       asu_SendByte
;;;307    		ucAck = asu_WaitAck();	/* 检测设备的ACK应答 */
000022  f7fffffe          BL       asu_WaitAck
000026  4605              MOV      r5,r0
;;;308    
;;;309    		asu_Stop();			/* 发送停止信号 */
000028  f7fffffe          BL       asu_Stop
;;;310    
;;;311    		return ucAck;
00002c  4628              MOV      r0,r5
                  |L2.46|
;;;312    	}
;;;313    	return 1;	/* ASU总线异常 */
;;;314    }
00002e  bd70              POP      {r4-r6,pc}
                  |L2.48|
000030  2001              MOVS     r0,#1                 ;313
000032  e7fc              B        |L2.46|
                          ENDP

                  |L2.52|
                          DCD      0x40020000

                          AREA ||i.asu_Delay||, CODE, READONLY, ALIGN=1

                  asu_Delay PROC
;;;98     */
;;;99     static void asu_Delay(void)
000000  2000              MOVS     r0,#0
;;;100    {
;;;101    	uint8_t i;
;;;102    
;;;103    	/*　
;;;104    		CPU主频168MHz时，在内部Flash运行, MDK工程不优化。用台式示波器观测波形。
;;;105    		循环次数为5时，SCL频率 = 1.78MHz (读耗时: 92ms, 读写正常，但是用示波器探头碰上就读写失败。时序接近临界)
;;;106    		循环次数为10时，SCL频率 = 1.1MHz (读耗时: 138ms, 读速度: 118724B/s)
;;;107    		循环次数为30时，SCL频率 = 440KHz， SCL高电平时间1.0us，SCL低电平时间1.2us
;;;108    
;;;109    		上拉电阻选择2.2K欧时，SCL上升沿时间约0.5us，如果选4.7K欧，则上升沿约1us
;;;110    
;;;111    		实际应用选择400KHz左右的速率即可
;;;112    	*/
;;;113    	for (i = 0; i < 10; i++)
000002  e002              B        |L3.10|
                  |L3.4|
;;;114        {
;;;115            __nop();
000004  bf00              NOP      
000006  1c41              ADDS     r1,r0,#1              ;113
000008  b2c8              UXTB     r0,r1                 ;113
                  |L3.10|
00000a  280a              CMP      r0,#0xa               ;113
00000c  dbfa              BLT      |L3.4|
;;;116        }
;;;117     
;;;118    }
00000e  4770              BX       lr
;;;119    
                          ENDP


                          AREA ||i.asu_NAck||, CODE, READONLY, ALIGN=2

                  asu_NAck PROC
;;;278    */
;;;279    void asu_NAck(void)
000000  b510              PUSH     {r4,lr}
;;;280    {
;;;281    	ASU_SDA_1();	/* CPU驱动SDA = 1 */
000002  2040              MOVS     r0,#0x40
000004  4907              LDR      r1,|L4.36|
000006  8308              STRH     r0,[r1,#0x18]
;;;282    	asu_Delay();
000008  f7fffffe          BL       asu_Delay
;;;283    	ASU_SCL_1();	/* CPU产生1个时钟 */
00000c  2080              MOVS     r0,#0x80
00000e  4905              LDR      r1,|L4.36|
000010  8308              STRH     r0,[r1,#0x18]
;;;284    	asu_Delay();
000012  f7fffffe          BL       asu_Delay
;;;285    	ASU_SCL_0();
000016  2080              MOVS     r0,#0x80
000018  4902              LDR      r1,|L4.36|
00001a  8348              STRH     r0,[r1,#0x1a]
;;;286    	asu_Delay();
00001c  f7fffffe          BL       asu_Delay
;;;287    }
000020  bd10              POP      {r4,pc}
;;;288    
                          ENDP

000022  0000              DCW      0x0000
                  |L4.36|
                          DCD      0x40020000

                          AREA ||i.asu_ReadByte||, CODE, READONLY, ALIGN=2

                  asu_ReadByte PROC
;;;200    */
;;;201    uint8_t asu_ReadByte(void)
000000  b570              PUSH     {r4-r6,lr}
;;;202    {
;;;203    	uint8_t i;
;;;204    	uint8_t value;
;;;205    
;;;206    	/* 读到第1个bit为数据的bit7 */
;;;207    	value = 0;
000002  2400              MOVS     r4,#0
;;;208    	for (i = 0; i < 8; i++)
000004  2500              MOVS     r5,#0
000006  e014              B        |L5.50|
                  |L5.8|
;;;209    	{
;;;210    		value <<= 1;
000008  0660              LSLS     r0,r4,#25
00000a  0e04              LSRS     r4,r0,#24
;;;211    		ASU_SCL_1();
00000c  2080              MOVS     r0,#0x80
00000e  490b              LDR      r1,|L5.60|
000010  8308              STRH     r0,[r1,#0x18]
;;;212    		asu_Delay();
000012  f7fffffe          BL       asu_Delay
;;;213    		if (ASU_SDA_READ())
000016  4809              LDR      r0,|L5.60|
000018  6900              LDR      r0,[r0,#0x10]
00001a  f0000040          AND      r0,r0,#0x40
00001e  b108              CBZ      r0,|L5.36|
;;;214    		{
;;;215    			value++;
000020  1c60              ADDS     r0,r4,#1
000022  b2c4              UXTB     r4,r0
                  |L5.36|
;;;216    		}
;;;217    		ASU_SCL_0();
000024  2080              MOVS     r0,#0x80
000026  4905              LDR      r1,|L5.60|
000028  8348              STRH     r0,[r1,#0x1a]
;;;218    		asu_Delay();
00002a  f7fffffe          BL       asu_Delay
00002e  1c68              ADDS     r0,r5,#1              ;208
000030  b2c5              UXTB     r5,r0                 ;208
                  |L5.50|
000032  2d08              CMP      r5,#8                 ;208
000034  dbe8              BLT      |L5.8|
;;;219    	}
;;;220    	return value;
000036  4620              MOV      r0,r4
;;;221    }
000038  bd70              POP      {r4-r6,pc}
;;;222    
                          ENDP

00003a  0000              DCW      0x0000
                  |L5.60|
                          DCD      0x40020000

                          AREA ||i.asu_SendByte||, CODE, READONLY, ALIGN=2

                  asu_SendByte PROC
;;;164    */
;;;165    void asu_SendByte(uint8_t _ucByte)
000000  b570              PUSH     {r4-r6,lr}
;;;166    {
000002  4604              MOV      r4,r0
;;;167    	uint8_t i;
;;;168    
;;;169    	/* 先发送字节的高位bit7 */
;;;170    	for (i = 0; i < 8; i++)
000004  2500              MOVS     r5,#0
000006  e01d              B        |L6.68|
                  |L6.8|
;;;171    	{
;;;172    		if (_ucByte & 0x80)
000008  f0040080          AND      r0,r4,#0x80
00000c  b118              CBZ      r0,|L6.22|
;;;173    		{
;;;174    			ASU_SDA_1();
00000e  2040              MOVS     r0,#0x40
000010  490e              LDR      r1,|L6.76|
000012  8308              STRH     r0,[r1,#0x18]
000014  e002              B        |L6.28|
                  |L6.22|
;;;175    		}
;;;176    		else
;;;177    		{
;;;178    			ASU_SDA_0();
000016  2040              MOVS     r0,#0x40
000018  490c              LDR      r1,|L6.76|
00001a  8348              STRH     r0,[r1,#0x1a]
                  |L6.28|
;;;179    		}
;;;180    		asu_Delay();
00001c  f7fffffe          BL       asu_Delay
;;;181    		ASU_SCL_1();
000020  2080              MOVS     r0,#0x80
000022  490a              LDR      r1,|L6.76|
000024  8308              STRH     r0,[r1,#0x18]
;;;182    		asu_Delay();
000026  f7fffffe          BL       asu_Delay
;;;183    		ASU_SCL_0();
00002a  2080              MOVS     r0,#0x80
00002c  4907              LDR      r1,|L6.76|
00002e  8348              STRH     r0,[r1,#0x1a]
;;;184    		if (i == 7)
000030  2d07              CMP      r5,#7
000032  d101              BNE      |L6.56|
;;;185    		{
;;;186    			 ASU_SDA_1(); // 释放总线
000034  2040              MOVS     r0,#0x40
000036  8308              STRH     r0,[r1,#0x18]
                  |L6.56|
;;;187    		}
;;;188    		_ucByte <<= 1;	/* 左移一个bit */
000038  0660              LSLS     r0,r4,#25
00003a  0e04              LSRS     r4,r0,#24
;;;189    		asu_Delay();
00003c  f7fffffe          BL       asu_Delay
000040  1c68              ADDS     r0,r5,#1              ;170
000042  b2c5              UXTB     r5,r0                 ;170
                  |L6.68|
000044  2d08              CMP      r5,#8                 ;170
000046  dbdf              BLT      |L6.8|
;;;190    	}
;;;191    }
000048  bd70              POP      {r4-r6,pc}
;;;192    
                          ENDP

00004a  0000              DCW      0x0000
                  |L6.76|
                          DCD      0x40020000

                          AREA ||i.asu_Start||, CODE, READONLY, ALIGN=2

                  asu_Start PROC
;;;127    */
;;;128    void asu_Start(void)
000000  b510              PUSH     {r4,lr}
;;;129    {
;;;130    	/* 当SCL高电平时，SDA出现一个下跳沿表示ASU总线启动信号 */
;;;131    	ASU_SDA_1();
000002  2040              MOVS     r0,#0x40
000004  4908              LDR      r1,|L7.40|
000006  8308              STRH     r0,[r1,#0x18]
;;;132    	ASU_SCL_1();
000008  2080              MOVS     r0,#0x80
00000a  8308              STRH     r0,[r1,#0x18]
;;;133    	asu_Delay();
00000c  f7fffffe          BL       asu_Delay
;;;134    	ASU_SDA_0();
000010  2040              MOVS     r0,#0x40
000012  4905              LDR      r1,|L7.40|
000014  8348              STRH     r0,[r1,#0x1a]
;;;135    	asu_Delay();
000016  f7fffffe          BL       asu_Delay
;;;136    	ASU_SCL_0();
00001a  2080              MOVS     r0,#0x80
00001c  4902              LDR      r1,|L7.40|
00001e  8348              STRH     r0,[r1,#0x1a]
;;;137    	asu_Delay();
000020  f7fffffe          BL       asu_Delay
;;;138    }
000024  bd10              POP      {r4,pc}
;;;139    
                          ENDP

000026  0000              DCW      0x0000
                  |L7.40|
                          DCD      0x40020000

                          AREA ||i.asu_Stop||, CODE, READONLY, ALIGN=2

                  asu_Stop PROC
;;;147    */
;;;148    void asu_Stop(void)
000000  b510              PUSH     {r4,lr}
;;;149    {
;;;150    	/* 当SCL高电平时，SDA出现一个上跳沿表示ASU总线停止信号 */
;;;151    	ASU_SDA_0();
000002  2040              MOVS     r0,#0x40
000004  4904              LDR      r1,|L8.24|
000006  8348              STRH     r0,[r1,#0x1a]
;;;152    	ASU_SCL_1();
000008  2080              MOVS     r0,#0x80
00000a  8308              STRH     r0,[r1,#0x18]
;;;153    	asu_Delay();
00000c  f7fffffe          BL       asu_Delay
;;;154    	ASU_SDA_1();
000010  2040              MOVS     r0,#0x40
000012  4901              LDR      r1,|L8.24|
000014  8308              STRH     r0,[r1,#0x18]
;;;155    }
000016  bd10              POP      {r4,pc}
;;;156    
                          ENDP

                  |L8.24|
                          DCD      0x40020000

                          AREA ||i.asu_WaitAck||, CODE, READONLY, ALIGN=2

                  asu_WaitAck PROC
;;;230    */
;;;231    uint8_t asu_WaitAck(void)
000000  b510              PUSH     {r4,lr}
;;;232    {
;;;233    	uint8_t re;
;;;234    
;;;235    	ASU_SDA_1();	/* CPU释放SDA总线 */
000002  2040              MOVS     r0,#0x40
000004  490b              LDR      r1,|L9.52|
000006  8308              STRH     r0,[r1,#0x18]
;;;236    	asu_Delay();
000008  f7fffffe          BL       asu_Delay
;;;237    	ASU_SCL_1();	/* CPU驱动SCL = 1, 此时器件会返回ACK应答 */
00000c  2080              MOVS     r0,#0x80
00000e  4909              LDR      r1,|L9.52|
000010  8308              STRH     r0,[r1,#0x18]
;;;238    	asu_Delay();
000012  f7fffffe          BL       asu_Delay
;;;239    	if (ASU_SDA_READ())	/* CPU读取SDA口线状态 */
000016  4807              LDR      r0,|L9.52|
000018  6900              LDR      r0,[r0,#0x10]
00001a  f0000040          AND      r0,r0,#0x40
00001e  b108              CBZ      r0,|L9.36|
;;;240    	{
;;;241    		re = 1;
000020  2401              MOVS     r4,#1
000022  e000              B        |L9.38|
                  |L9.36|
;;;242    	}
;;;243    	else
;;;244    	{
;;;245    		re = 0;
000024  2400              MOVS     r4,#0
                  |L9.38|
;;;246    	}
;;;247    	ASU_SCL_0();
000026  2080              MOVS     r0,#0x80
000028  4902              LDR      r1,|L9.52|
00002a  8348              STRH     r0,[r1,#0x1a]
;;;248    	asu_Delay();
00002c  f7fffffe          BL       asu_Delay
;;;249    	return re;
000030  4620              MOV      r0,r4
;;;250    }
000032  bd10              POP      {r4,pc}
;;;251    
                          ENDP

                  |L9.52|
                          DCD      0x40020000

                          AREA ||i.bsp_InitASU||, CODE, READONLY, ALIGN=2

                  bsp_InitASU PROC
;;;54     */
;;;55     void bsp_InitASU(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;56     {
;;;57     	GPIO_InitTypeDef GPIO_InitStructure;
;;;58     
;;;59     	RCC_AHB1PeriphClockCmd(RCC_ASU_PORT, ENABLE);	/* 打开GPIO时钟 */
000002  2101              MOVS     r1,#1
000004  4608              MOV      r0,r1
000006  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;60     
;;;61     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;		/* 设为输出口 */
00000a  2001              MOVS     r0,#1
00000c  f88d0004          STRB     r0,[sp,#4]
;;;62     	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;		/* 设为开漏模式 */
000010  f88d0006          STRB     r0,[sp,#6]
;;;63     	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;	/* 上下拉电阻不使能 */
000014  2000              MOVS     r0,#0
000016  f88d0007          STRB     r0,[sp,#7]
;;;64     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;	/* IO口最大速度 */
00001a  2003              MOVS     r0,#3
00001c  f88d0005          STRB     r0,[sp,#5]
;;;65     
;;;66     	GPIO_InitStructure.GPIO_Pin = ASU_SCL_PIN | ASU_SDA_PIN;
000020  20c0              MOVS     r0,#0xc0
000022  9000              STR      r0,[sp,#0]
;;;67     	GPIO_Init(GPIO_PORT_ASU, &GPIO_InitStructure);
000024  4669              MOV      r1,sp
000026  4803              LDR      r0,|L10.52|
000028  f7fffffe          BL       GPIO_Init
;;;68     
;;;69     	/* 给一个停止信号, 复位ASU总线上的所有设备到待机模式 */
;;;70     	asu_Stop();
00002c  f7fffffe          BL       asu_Stop
;;;71     }
000030  bd1c              POP      {r2-r4,pc}
;;;72     
                          ENDP

000032  0000              DCW      0x0000
                  |L10.52|
                          DCD      0x40020000

                          AREA ||i.bsp_deinitASU||, CODE, READONLY, ALIGN=2

                  bsp_deinitASU PROC
;;;73     
;;;74     void bsp_deinitASU(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;75     {
;;;76     	GPIO_InitTypeDef GPIO_InitStructure;
;;;77     
;;;78     	RCC_AHB1PeriphClockCmd(RCC_ASU_PORT, ENABLE);	/* 打开GPIO时钟 */
000002  2101              MOVS     r1,#1
000004  4608              MOV      r0,r1
000006  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;79         ASU_SDA_0();
00000a  2040              MOVS     r0,#0x40
00000c  490a              LDR      r1,|L11.56|
00000e  8348              STRH     r0,[r1,#0x1a]
;;;80         ASU_SCL_0();
000010  2080              MOVS     r0,#0x80
000012  8348              STRH     r0,[r1,#0x1a]
;;;81     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;		/* 设为输出口 */
000014  2001              MOVS     r0,#1
000016  f88d0004          STRB     r0,[sp,#4]
;;;82     	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;		/* 设为开漏模式 */
00001a  f88d0006          STRB     r0,[sp,#6]
;;;83     	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;	/* 上下拉电阻不使能 */
00001e  2000              MOVS     r0,#0
000020  f88d0007          STRB     r0,[sp,#7]
;;;84     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;	/* IO口最大速度 */
000024  2003              MOVS     r0,#3
000026  f88d0005          STRB     r0,[sp,#5]
;;;85     
;;;86     	GPIO_InitStructure.GPIO_Pin = ASU_SCL_PIN | ASU_SDA_PIN;
00002a  20c0              MOVS     r0,#0xc0
00002c  9000              STR      r0,[sp,#0]
;;;87     	GPIO_Init(GPIO_PORT_ASU, &GPIO_InitStructure);
00002e  4669              MOV      r1,sp
000030  4801              LDR      r0,|L11.56|
000032  f7fffffe          BL       GPIO_Init
;;;88      
;;;89     }
000036  bd1c              POP      {r2-r4,pc}
;;;90     
                          ENDP

                  |L11.56|
                          DCD      0x40020000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\src\\bsp_apple_asu.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_apple_asu_c_6a39b25d____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_bsp_apple_asu_c_6a39b25d____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_apple_asu_c_6a39b25d____REVSH|
#line 144
|__asm___15_bsp_apple_asu_c_6a39b25d____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
