; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\flash\obj\bsp_spi_asu.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_spi_asu.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\User -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\User\FatFS\src -I..\..\Libraries\STM32_USB_Device_Library\Class\msc\inc -I..\..\Libraries\STM32_USB_Device_Library\Core\inc -I..\..\Libraries\STM32_USB_OTG_Driver\inc -I..\..\User\usbd_mass_storage -I..\..\User\berry_ft -I..\..\User\ft_support -I..\..\User\test_common -I..\..\User\emenu -I..\..\User\kiwi_ft -I..\..\User\kiwi_ft\spv40 -I..\..\User\kiwi_ft\spv40\peripheral -I..\..\User\lwrb -I..\..\User\easylogger\inc -I..\..\User\easylogger\plugins\file -I..\..\User\LOG -I..\..\User\kiwi_ft -I..\..\User\MultiButton-1.1.0 -I.\RTE\_Flash -IC:\Users\qizha\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\qizha\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.16.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F407xx -D_RTE_ -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY --signed_chars --omf_browse=.\flash\obj\bsp_spi_asu.crf ..\..\User\bsp_stm32f4xx\src\bsp_spi_asu.c]
                          THUMB

                          AREA ||i.bsp_SpiBusBusy_ASU||, CODE, READONLY, ALIGN=2

                  bsp_SpiBusBusy_ASU PROC
;;;445    */
;;;446    uint8_t bsp_SpiBusBusy_ASU(void)
000000  4801              LDR      r0,|L1.8|
;;;447    {
;;;448    	return g_spi_busy_asu;
000002  7800              LDRB     r0,[r0,#0]  ; g_spi_busy_asu
;;;449    }
000004  4770              BX       lr
;;;450    
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      g_spi_busy_asu

                          AREA ||i.bsp_SpiBusEnter_ASU||, CODE, READONLY, ALIGN=2

                  bsp_SpiBusEnter_ASU PROC
;;;419    */
;;;420    void bsp_SpiBusEnter_ASU(void)
000000  2001              MOVS     r0,#1
;;;421    {
;;;422    	g_spi_busy_asu = 1;
000002  4901              LDR      r1,|L2.8|
000004  7008              STRB     r0,[r1,#0]
;;;423    }
000006  4770              BX       lr
;;;424    
                          ENDP

                  |L2.8|
                          DCD      g_spi_busy_asu

                          AREA ||i.bsp_SpiBusExit_ASU||, CODE, READONLY, ALIGN=2

                  bsp_SpiBusExit_ASU PROC
;;;432    */
;;;433    void bsp_SpiBusExit_ASU(void)
000000  2000              MOVS     r0,#0
;;;434    {
;;;435    	g_spi_busy_asu = 0;
000002  4901              LDR      r1,|L3.8|
000004  7008              STRB     r0,[r1,#0]
;;;436    }
000006  4770              BX       lr
;;;437    
                          ENDP

                  |L3.8|
                          DCD      g_spi_busy_asu

                          AREA ||i.bsp_asu_deinit||, CODE, READONLY, ALIGN=2

                  bsp_asu_deinit PROC
;;;146    
;;;147    void bsp_asu_deinit(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;148    {
;;;149     
;;;150    	GPIO_InitTypeDef  GPIO_InitStructure={0};
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
000006  9001              STR      r0,[sp,#4]
;;;151    
;;;152    	/* 打开GPIO时钟 */
;;;153    	RCC_AHB1PeriphClockCmd(ASU_RCC_SCK | ASU_RCC_MOSI | ASU_RCC_MISO, ENABLE);	
000008  2101              MOVS     r1,#1
00000a  2002              MOVS     r0,#2
00000c  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;154        
;;;155    	/* 配置SPI引脚SCK、MISO 和 MOSI为复用推挽模式 */
;;;156    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
000010  2003              MOVS     r0,#3
000012  f88d0005          STRB     r0,[sp,#5]
;;;157        GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
000016  2001              MOVS     r0,#1
000018  f88d0006          STRB     r0,[sp,#6]
;;;158    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;	/* 推挽输出模式 */
00001c  2000              MOVS     r0,#0
00001e  f88d0004          STRB     r0,[sp,#4]
;;;159        GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
000022  f88d0007          STRB     r0,[sp,#7]
;;;160    	GPIO_InitStructure.GPIO_Pin = ASU_PIN_SCK;
000026  2008              MOVS     r0,#8
000028  9000              STR      r0,[sp,#0]
;;;161    	GPIO_Init(ASU_PORT_SCK, &GPIO_InitStructure);
00002a  4669              MOV      r1,sp
00002c  4807              LDR      r0,|L4.76|
00002e  f7fffffe          BL       GPIO_Init
;;;162    
;;;163    	GPIO_InitStructure.GPIO_Pin = ASU_PIN_MOSI;
000032  2020              MOVS     r0,#0x20
000034  9000              STR      r0,[sp,#0]
;;;164    	GPIO_Init(ASU_PORT_MOSI, &GPIO_InitStructure);	
000036  4669              MOV      r1,sp
000038  4804              LDR      r0,|L4.76|
00003a  f7fffffe          BL       GPIO_Init
;;;165    
;;;166     
;;;167    	GPIO_InitStructure.GPIO_Pin = ASU_PIN_MISO;
00003e  2010              MOVS     r0,#0x10
000040  9000              STR      r0,[sp,#0]
;;;168    	GPIO_Init(ASU_PORT_MISO, &GPIO_InitStructure);
000042  4669              MOV      r1,sp
000044  4801              LDR      r0,|L4.76|
000046  f7fffffe          BL       GPIO_Init
;;;169    }
00004a  bd1c              POP      {r2-r4,pc}
;;;170    
                          ENDP

                  |L4.76|
                          DCD      0x40020400

                          AREA ||i.bsp_asu_init||, CODE, READONLY, ALIGN=1

                  bsp_asu_init PROC
;;;79     */
;;;80     void bsp_asu_init(void)
000000  4770              BX       lr
;;;81     {
;;;82     #ifdef SOFT_SPI_ASU		/* 软件SPI */
;;;83     	GPIO_InitTypeDef  GPIO_InitStructure={0};
;;;84     
;;;85     	/* 打开GPIO时钟 */
;;;86     	RCC_AHB1PeriphClockCmd(ASU_RCC_SCK | ASU_RCC_MOSI | ASU_RCC_MISO, ENABLE);	
;;;87         
;;;88     	/* 配置SPI引脚SCK、MISO 和 MOSI为复用推挽模式 */
;;;89     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
;;;90         GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;91     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;	/* 推挽输出模式 */
;;;92         GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
;;;93     	GPIO_InitStructure.GPIO_Pin = ASU_PIN_SCK;
;;;94     	GPIO_Init(ASU_PORT_SCK, &GPIO_InitStructure);
;;;95     
;;;96     	GPIO_InitStructure.GPIO_Pin = ASU_PIN_MOSI;
;;;97     	GPIO_Init(ASU_PORT_MOSI, &GPIO_InitStructure);	
;;;98     
;;;99      
;;;100       // GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;101    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;		/* MISO 设置为输入上拉 */
;;;102    	GPIO_InitStructure.GPIO_Pin = ASU_PIN_MISO;
;;;103    	GPIO_Init(ASU_PORT_MISO, &GPIO_InitStructure);
;;;104    #endif
;;;105    
;;;106    #ifdef HARD_SPI_ASU		/* 硬件SPI */
;;;107    	GPIO_InitTypeDef GPIO_InitStructure;
;;;108    
;;;109    	/* 开启 SPI 时钟 */
;;;110    	//RCC_APB2PeriphClockCmd(RCC_SPI, ENABLE);
;;;111    	
;;;112    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);
;;;113    	
;;;114    	/* 使能 GPIO 时钟 */
;;;115    	RCC_APB2PeriphClockCmd(ASU_RCC_SCK | ASU_RCC_MOSI | ASU_RCC_MISO, ENABLE);	
;;;116    
;;;117    	/* 配置 SPI引脚SCK、MISO 和 MOSI为复用推挽模式 */
;;;118    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
;;;119    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;120    	GPIO_InitStructure.GPIO_Pin = ASU_PIN_SCK;	
;;;121    	GPIO_Init(ASU_PORT_SCK, &GPIO_InitStructure);
;;;122    	
;;;123    	GPIO_InitStructure.GPIO_Pin = ASU_PIN_MISO;	
;;;124    	GPIO_Init(ASU_PORT_MISO, &GPIO_InitStructure);
;;;125    
;;;126    	GPIO_InitStructure.GPIO_Pin = ASU_PIN_MOSI;	
;;;127    	GPIO_Init(ASU_PORT_MOSI, &GPIO_InitStructure);
;;;128    		
;;;129    	bsp_SPI_Init(SPI_Direction_2Lines_FullDuplex | SPI_Mode_Master | SPI_DataSize_8b
;;;130    		| SPI_CPOL_Low | SPI_CPHA_1Edge | SPI_NSS_Soft | SPI_BaudRatePrescaler_64 | SPI_FirstBit_MSB);	
;;;131    	
;;;132    	/* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
;;;133    	SPI_HARD->I2SCFGR &= SPI_Mode_Select;		/* 选择SPI模式，不是I2S模式 */
;;;134    
;;;135    	/*---------------------------- SPIx CRCPOLY Configuration --------------------*/
;;;136    	/* Write to SPIx CRCPOLY */
;;;137    	SPI_HARD->CRCPR = 7;		/* 一般不用 */
;;;138    
;;;139    
;;;140    	SPI_Cmd(SPI_HARD, DISABLE);			/* 先禁止SPI  */
;;;141    
;;;142    	SPI_Cmd(SPI_HARD, ENABLE);			/* 使能SPI  */
;;;143    #endif
;;;144    }
;;;145    
                          ENDP


                          AREA ||i.bsp_spiRead0_ASU||, CODE, READONLY, ALIGN=1

                  bsp_spiRead0_ASU PROC
;;;274    */
;;;275    uint8_t bsp_spiRead0_ASU(void)
000000  4770              BX       lr
;;;276    {
;;;277    #ifdef SOFT_SPI_ASU		/* 软件SPI */
;;;278    	uint8_t i;
;;;279    	uint8_t read = 0;
;;;280    
;;;281    	for (i = 0; i < 8; i++)
;;;282    	{
;;;283    		read = read<<1;
;;;284    
;;;285    		if (ASU_MISO_IS_HIGH())
;;;286    		{
;;;287    			read++;
;;;288    		}
;;;289    		ASU_SCK_1();
;;;290    		bsp_spiDelay_ASU();
;;;291    		ASU_SCK_0();
;;;292    		bsp_spiDelay_ASU();
;;;293    	}
;;;294    	return read;
;;;295    #endif
;;;296    
;;;297    #ifdef HARD_SPI_ASU		/* 硬件SPI */
;;;298    	uint8_t read;
;;;299    
;;;300    	/* 等待发送缓冲区空 */
;;;301    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);
;;;302    
;;;303    	/* 发送一个字节 */
;;;304    	SPI_I2S_SendData(SPI1, 0);
;;;305    
;;;306    	/* 等待数据接收完毕 */
;;;307    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);
;;;308    
;;;309    	/* 读取接收到的数据 */
;;;310    	read = SPI_I2S_ReceiveData(SPI1);
;;;311    
;;;312    	/* 返回读到的数据 */
;;;313    	return read;
;;;314    #endif
;;;315    }
;;;316    
                          ENDP


                          AREA ||i.bsp_spiRead1_ASU||, CODE, READONLY, ALIGN=1

                  bsp_spiRead1_ASU PROC
;;;370    */
;;;371    uint8_t bsp_spiRead1_ASU(void)
000000  4770              BX       lr
;;;372    {
;;;373    #ifdef SOFT_SPI_ASU		/* 软件SPI */
;;;374    	uint8_t i;
;;;375    	uint8_t read = 0;
;;;376    
;;;377    	for (i = 0; i < 8; i++)
;;;378    	{
;;;379    		ASU_SCK_0();
;;;380    		bsp_spiDelay_ASU();
;;;381    		read = read << 1;
;;;382    		if (ASU_MISO_IS_HIGH())
;;;383    		{
;;;384    			read++;
;;;385    		}
;;;386    		ASU_SCK_1();
;;;387    		bsp_spiDelay_ASU();
;;;388    	}
;;;389    	return read;
;;;390    #endif
;;;391    
;;;392    #ifdef HARD_SPI_ASU		/* 硬件SPI */
;;;393    	uint8_t read;
;;;394    
;;;395    	/* 等待发送缓冲区空 */
;;;396    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);
;;;397    
;;;398    	/* 发送一个字节 */
;;;399    	SPI_I2S_SendData(SPI1, 0);
;;;400    
;;;401    	/* 等待数据接收完毕 */
;;;402    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);
;;;403    
;;;404    	/* 读取接收到的数据 */
;;;405    	read = SPI_I2S_ReceiveData(SPI1);
;;;406    
;;;407    	/* 返回读到的数据 */
;;;408    	return read;
;;;409    #endif
;;;410    }
;;;411    
                          ENDP


                          AREA ||i.bsp_spiWrite0_ASU||, CODE, READONLY, ALIGN=1

                  bsp_spiWrite0_ASU PROC
;;;217    */
;;;218    uint8_t  bsp_spiWrite0_ASU(uint8_t _ucByte)
000000  4601              MOV      r1,r0
;;;219    {
;;;220    #ifdef SOFT_SPI_ASU		/* 软件SPI */
;;;221    	uint8_t i;
;;;222        uint8_t read = 0;
;;;223        
;;;224    	for(i = 0; i < 8; i++)
;;;225    	{
;;;226            read = read<<1;
;;;227            if(ASU_MISO_IS_HIGH())
;;;228            {
;;;229                read++;
;;;230            }
;;;231            
;;;232    		if (_ucByte & 0x80)  
;;;233    		{
;;;234    			ASU_MOSI_1();
;;;235    		}
;;;236    		else
;;;237    		{
;;;238    			ASU_MOSI_0();
;;;239    		}
;;;240    		bsp_spiDelay_ASU();
;;;241    		ASU_SCK_1();
;;;242    		_ucByte <<= 1;
;;;243    		bsp_spiDelay_ASU();
;;;244    		ASU_SCK_0();
;;;245           // bsp_spiDelay_ASU();
;;;246            
;;;247    	}
;;;248    	bsp_spiDelay_ASU();
;;;249        return read;
;;;250    #endif
;;;251    
;;;252    #ifdef HARD_SPI_ASU		/* 硬件SPI */
;;;253    	/* 等待发送缓冲区空 */
;;;254    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);
;;;255    
;;;256    	/* 发送一个字节 */
;;;257    	SPI_I2S_SendData(SPI1, _ucByte);
;;;258    
;;;259    	/* 等待数据接收完毕 */
;;;260    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);
;;;261    
;;;262    	/* 读取接收到的数据 */
;;;263    	SPI_I2S_ReceiveData(SPI1);
;;;264    #endif
;;;265    }
000002  4770              BX       lr
;;;266    
                          ENDP


                          AREA ||i.bsp_spiWrite1_ASU||, CODE, READONLY, ALIGN=1

                  bsp_spiWrite1_ASU PROC
;;;324    */
;;;325    void bsp_spiWrite1_ASU(uint8_t _ucByte)
000000  4770              BX       lr
;;;326    {
;;;327    #ifdef SOFT_SPI_ASU		/* 软件SPI */
;;;328    	uint8_t i;
;;;329    
;;;330    	for(i = 0; i < 8; i++)
;;;331    	{
;;;332    		if (_ucByte & 0x80)
;;;333    		{
;;;334    			ASU_MOSI_1();
;;;335    		}
;;;336    		else
;;;337    		{
;;;338    			ASU_MOSI_0();
;;;339    		}
;;;340    		ASU_SCK_0();
;;;341    		_ucByte <<= 1;
;;;342    		bsp_spiDelay_ASU();
;;;343    		ASU_SCK_1();				/* SCK上升沿采集数据, SCK空闲时为高电平 */
;;;344    		bsp_spiDelay_ASU();
;;;345    	}
;;;346    #endif
;;;347    
;;;348    #ifdef HARD_SPI_ASU		/* 硬件SPI */
;;;349    	/* 等待发送缓冲区空 */
;;;350    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);
;;;351    
;;;352    	/* 发送一个字节 */
;;;353    	SPI_I2S_SendData(SPI1, _ucByte);
;;;354    
;;;355    	/* 等待数据接收完毕 */
;;;356    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);
;;;357    
;;;358    	/* 读取接收到的数据 */
;;;359    	SPI_I2S_ReceiveData(SPI1);
;;;360    #endif
;;;361    }
;;;362    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  g_spi_busy_asu
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\src\\bsp_spi_asu.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_spi_asu_c_9052aa7e____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_bsp_spi_asu_c_9052aa7e____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_spi_asu_c_9052aa7e____REVSH|
#line 144
|__asm___13_bsp_spi_asu_c_9052aa7e____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
