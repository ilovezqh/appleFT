; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\flash\obj\cm_backtrace.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\cm_backtrace.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\User -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\User\FatFS\src -I..\..\Libraries\STM32_USB_Device_Library\Class\msc\inc -I..\..\Libraries\STM32_USB_Device_Library\Core\inc -I..\..\Libraries\STM32_USB_OTG_Driver\inc -I..\..\User\usbd_mass_storage -I..\..\User\ft_support -I..\..\User\test -I..\..\User\emenu -I..\..\User\chip_ft -I..\..\User\lwrb -I..\..\User\easylogger\inc -I..\..\User\easylogger\plugins\file -I..\..\User\LOG -I..\..\User\MultiButton-1.1.0 -I..\..\User\cm_backtrace -I..\..\User\MultiTimer -I.\RTE\_Flash -IC:\Users\qizha\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\qizha\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.17.1\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F407xx -D_RTE_ -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY --signed_chars --omf_browse=.\flash\obj\cm_backtrace.crf ..\..\User\cm_backtrace\cm_backtrace.c]
                          THUMB

                          AREA ||i.cm_backtrace_assert||, CODE, READONLY, ALIGN=2

                  cm_backtrace_assert PROC
;;;385     */
;;;386    void cm_backtrace_assert(uint32_t sp) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;387        CMB_ASSERT(init_ok);
000004  480f              LDR      r0,|L1.68|
000006  7800              LDRB     r0,[r0,#0]  ; init_ok
000008  b948              CBNZ     r0,|L1.30|
00000a  4a0f              LDR      r2,|L1.72|
00000c  a10f              ADR      r1,|L1.76|
00000e  a011              ADR      r0,|L1.84|
000010  f7fffffe          BL       print_UART1
000014  a017              ADR      r0,|L1.116|
000016  f7fffffe          BL       print_UART1
00001a  bf00              NOP      
                  |L1.28|
00001c  e7fe              B        |L1.28|
                  |L1.30|
;;;388    
;;;389    #ifdef CMB_USING_OS_PLATFORM
;;;390        uint32_t cur_stack_pointer = cmb_get_sp();
;;;391    #endif
;;;392    
;;;393        cmb_println("");
00001e  a016              ADR      r0,|L1.120|
000020  f7fffffe          BL       print_UART1
000024  a013              ADR      r0,|L1.116|
000026  f7fffffe          BL       print_UART1
;;;394        cm_backtrace_firmware_info();
00002a  f7fffffe          BL       cm_backtrace_firmware_info
;;;395    
;;;396    #ifdef CMB_USING_OS_PLATFORM
;;;397        /* OS environment */
;;;398        if (cur_stack_pointer == cmb_get_msp()) {
;;;399            cmb_println(print_info[PRINT_ASSERT_ON_HANDLER]);
;;;400    
;;;401    #ifdef CMB_USING_DUMP_STACK_INFO
;;;402            dump_stack(main_stack_start_addr, main_stack_size, (uint32_t *) sp);
;;;403    #endif /* CMB_USING_DUMP_STACK_INFO */
;;;404    
;;;405        } else if (cur_stack_pointer == cmb_get_psp()) {
;;;406            cmb_println(print_info[PRINT_ASSERT_ON_THREAD], get_cur_thread_name());
;;;407    
;;;408    #ifdef CMB_USING_DUMP_STACK_INFO
;;;409            uint32_t stack_start_addr;
;;;410            size_t stack_size;
;;;411            get_cur_thread_stack_info(sp, &stack_start_addr, &stack_size);
;;;412            dump_stack(stack_start_addr, stack_size, (uint32_t *) sp);
;;;413    #endif /* CMB_USING_DUMP_STACK_INFO */
;;;414    
;;;415        }
;;;416    
;;;417    #else
;;;418    
;;;419        /* bare metal(no OS) environment */
;;;420    #ifdef CMB_USING_DUMP_STACK_INFO
;;;421        dump_stack(main_stack_start_addr, main_stack_size, (uint32_t *) sp);
00002e  4622              MOV      r2,r4
000030  4812              LDR      r0,|L1.124|
000032  6801              LDR      r1,[r0,#0]  ; main_stack_size
000034  4812              LDR      r0,|L1.128|
000036  6800              LDR      r0,[r0,#0]  ; main_stack_start_addr
000038  f7fffffe          BL       dump_stack
;;;422    #endif /* CMB_USING_DUMP_STACK_INFO */
;;;423    
;;;424    #endif /* CMB_USING_OS_PLATFORM */
;;;425    
;;;426        print_call_stack(sp);
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       print_call_stack
;;;427    }
000042  bd10              POP      {r4,pc}
;;;428    
                          ENDP

                  |L1.68|
                          DCD      init_ok
                  |L1.72|
                          DCD      __FUNCTION__
                  |L1.76|
00004c  696e6974          DCB      "init_ok",0
000050  5f6f6b00
                  |L1.84|
000054  28257329          DCB      "(%s) has assert failed at %s.",0
000058  20686173
00005c  20617373
000060  65727420
000064  6661696c
000068  65642061
00006c  74202573
000070  2e00    
000072  00                DCB      0
000073  00                DCB      0
                  |L1.116|
000074  0d0a00            DCB      "\r\n",0
000077  00                DCB      0
                  |L1.120|
000078  00                DCB      0
000079  00                DCB      0
00007a  00                DCB      0
00007b  00                DCB      0
                  |L1.124|
                          DCD      main_stack_size
                  |L1.128|
                          DCD      main_stack_start_addr

                          AREA ||i.cm_backtrace_call_stack||, CODE, READONLY, ALIGN=2

                  cm_backtrace_call_stack PROC
;;;292     */
;;;293    size_t cm_backtrace_call_stack(uint32_t *buffer, size_t size, uint32_t sp) {
000000  e92d5ff0          PUSH     {r4-r12,lr}
000004  4607              MOV      r7,r0
000006  4689              MOV      r9,r1
000008  4616              MOV      r6,r2
;;;294        uint32_t stack_start_addr = main_stack_start_addr, pc;
00000a  4836              LDR      r0,|L2.228|
00000c  f8d08000          LDR      r8,[r0,#0]  ; main_stack_start_addr
;;;295        size_t depth = 0, stack_size = main_stack_size;
000010  2500              MOVS     r5,#0
000012  4835              LDR      r0,|L2.232|
000014  f8d0a000          LDR      r10,[r0,#0]  ; main_stack_size
;;;296        bool regs_saved_lr_is_valid = false;
000018  46ab              MOV      r11,r5
;;;297    
;;;298        if (on_fault) {
00001a  4834              LDR      r0,|L2.236|
00001c  7800              LDRB     r0,[r0,#0]  ; on_fault
00001e  b300              CBZ      r0,|L2.98|
;;;299            if (!stack_is_overflow) {
000020  4833              LDR      r0,|L2.240|
000022  7800              LDRB     r0,[r0,#0]  ; stack_is_overflow
000024  b9e8              CBNZ     r0,|L2.98|
;;;300                /* first depth is PC */
;;;301                buffer[depth++] = regs.saved.pc;
000026  4833              LDR      r0,|L2.244|
000028  6982              LDR      r2,[r0,#0x18]  ; regs
00002a  4628              MOV      r0,r5
00002c  1c6d              ADDS     r5,r5,#1
00002e  f8472020          STR      r2,[r7,r0,LSL #2]
;;;302                /* fix the LR address in thumb mode */
;;;303                pc = regs.saved.lr - 1;
000032  4830              LDR      r0,|L2.244|
000034  6940              LDR      r0,[r0,#0x14]  ; regs
000036  1e44              SUBS     r4,r0,#1
;;;304                if ((pc >= code_start_addr) && (pc <= code_start_addr + code_size) && (depth < CMB_CALL_STACK_MAX_DEPTH)
000038  482f              LDR      r0,|L2.248|
00003a  6800              LDR      r0,[r0,#0]  ; code_start_addr
00003c  4284              CMP      r4,r0
00003e  d310              BCC      |L2.98|
000040  482d              LDR      r0,|L2.248|
000042  6800              LDR      r0,[r0,#0]  ; code_start_addr
000044  492d              LDR      r1,|L2.252|
000046  6809              LDR      r1,[r1,#0]  ; code_size
000048  4408              ADD      r0,r0,r1
00004a  42a0              CMP      r0,r4
00004c  d309              BCC      |L2.98|
00004e  2d10              CMP      r5,#0x10
000050  d207              BCS      |L2.98|
;;;305                        && (depth < size)) {
000052  454d              CMP      r5,r9
000054  d205              BCS      |L2.98|
;;;306                    buffer[depth++] = pc;
000056  4628              MOV      r0,r5
000058  1c6d              ADDS     r5,r5,#1
00005a  f8474020          STR      r4,[r7,r0,LSL #2]
;;;307                    regs_saved_lr_is_valid = true;
00005e  f04f0b01          MOV      r11,#1
                  |L2.98|
;;;308                }
;;;309            }
;;;310    
;;;311    #ifdef CMB_USING_OS_PLATFORM
;;;312            /* program is running on thread before fault */
;;;313            if (on_thread_before_fault) {
;;;314                get_cur_thread_stack_info(sp, &stack_start_addr, &stack_size);
;;;315            }
;;;316        } else {
;;;317            /* OS environment */
;;;318            if (cmb_get_sp() == cmb_get_psp()) {
;;;319                get_cur_thread_stack_info(sp, &stack_start_addr, &stack_size);
;;;320            }
;;;321    #endif /* CMB_USING_OS_PLATFORM */
;;;322    
;;;323        }
;;;324    
;;;325        if (stack_is_overflow) {
000062  4823              LDR      r0,|L2.240|
000064  7800              LDRB     r0,[r0,#0]  ; stack_is_overflow
000066  b148              CBZ      r0,|L2.124|
;;;326            if (sp < stack_start_addr) {
000068  4546              CMP      r6,r8
00006a  d201              BCS      |L2.112|
;;;327                sp = stack_start_addr;
00006c  4646              MOV      r6,r8
00006e  e005              B        |L2.124|
                  |L2.112|
;;;328            } else if (sp > stack_start_addr + stack_size) {
000070  eb08000a          ADD      r0,r8,r10
000074  42b0              CMP      r0,r6
000076  d201              BCS      |L2.124|
;;;329                sp = stack_start_addr + stack_size;
000078  eb08060a          ADD      r6,r8,r10
                  |L2.124|
;;;330            }
;;;331        }
;;;332    
;;;333        /* copy called function address */
;;;334        for (; sp < stack_start_addr + stack_size; sp += sizeof(size_t)) {
00007c  e02a              B        |L2.212|
                  |L2.126|
;;;335            /* the *sp value may be LR, so need decrease a word to PC */
;;;336            pc = *((uint32_t *) sp) - sizeof(size_t);
00007e  6830              LDR      r0,[r6,#0]
000080  1f04              SUBS     r4,r0,#4
;;;337            /* the Cortex-M using thumb instruction, so the pc must be an odd number */
;;;338            if (pc % 2 == 0) {
000082  f0040001          AND      r0,r4,#1
000086  b900              CBNZ     r0,|L2.138|
;;;339                continue;
000088  e023              B        |L2.210|
                  |L2.138|
;;;340            }
;;;341            /* fix the PC address in thumb mode */
;;;342            pc = *((uint32_t *) sp) - 1;
00008a  6830              LDR      r0,[r6,#0]
00008c  1e44              SUBS     r4,r0,#1
;;;343            if ((pc >= code_start_addr + sizeof(size_t)) && (pc <= code_start_addr + code_size) && (depth < CMB_CALL_STACK_MAX_DEPTH)
00008e  481a              LDR      r0,|L2.248|
000090  6800              LDR      r0,[r0,#0]  ; code_start_addr
000092  1d00              ADDS     r0,r0,#4
000094  4284              CMP      r4,r0
000096  d31b              BCC      |L2.208|
000098  4817              LDR      r0,|L2.248|
00009a  6800              LDR      r0,[r0,#0]  ; code_start_addr
00009c  4917              LDR      r1,|L2.252|
00009e  6809              LDR      r1,[r1,#0]  ; code_size
0000a0  4408              ADD      r0,r0,r1
0000a2  42a0              CMP      r0,r4
0000a4  d314              BCC      |L2.208|
0000a6  2d10              CMP      r5,#0x10
0000a8  d212              BCS      |L2.208|
;;;344                    /* check the the instruction before PC address is 'BL' or 'BLX' */
;;;345                    && disassembly_ins_is_bl_blx(pc - sizeof(size_t)) && (depth < size)) {
0000aa  1f20              SUBS     r0,r4,#4
0000ac  f7fffffe          BL       disassembly_ins_is_bl_blx
0000b0  b170              CBZ      r0,|L2.208|
0000b2  454d              CMP      r5,r9
0000b4  d20c              BCS      |L2.208|
;;;346                /* the second depth function may be already saved, so need ignore repeat */
;;;347                if ((depth == 2) && regs_saved_lr_is_valid && (pc == buffer[1])) {
0000b6  2d02              CMP      r5,#2
0000b8  d106              BNE      |L2.200|
0000ba  f1bb0f00          CMP      r11,#0
0000be  d003              BEQ      |L2.200|
0000c0  6878              LDR      r0,[r7,#4]
0000c2  42a0              CMP      r0,r4
0000c4  d100              BNE      |L2.200|
;;;348                    continue;
0000c6  e004              B        |L2.210|
                  |L2.200|
;;;349                }
;;;350                buffer[depth++] = pc;
0000c8  4628              MOV      r0,r5
0000ca  1c6d              ADDS     r5,r5,#1
0000cc  f8474020          STR      r4,[r7,r0,LSL #2]
                  |L2.208|
0000d0  bf00              NOP                            ;339
                  |L2.210|
0000d2  1d36              ADDS     r6,r6,#4              ;334
                  |L2.212|
0000d4  eb08000a          ADD      r0,r8,r10             ;334
0000d8  42b0              CMP      r0,r6                 ;334
0000da  d8d0              BHI      |L2.126|
;;;351            }
;;;352        }
;;;353    
;;;354        return depth;
0000dc  4628              MOV      r0,r5
;;;355    }
0000de  e8bd9ff0          POP      {r4-r12,pc}
;;;356    
                          ENDP

0000e2  0000              DCW      0x0000
                  |L2.228|
                          DCD      main_stack_start_addr
                  |L2.232|
                          DCD      main_stack_size
                  |L2.236|
                          DCD      on_fault
                  |L2.240|
                          DCD      stack_is_overflow
                  |L2.244|
                          DCD      regs
                  |L2.248|
                          DCD      code_start_addr
                  |L2.252|
                          DCD      code_size

                          AREA ||i.cm_backtrace_fault||, CODE, READONLY, ALIGN=2

                  cm_backtrace_fault PROC
;;;564     */
;;;565    void cm_backtrace_fault(uint32_t fault_handler_lr, uint32_t fault_handler_sp) {
000000  e92d43f0          PUSH     {r4-r9,lr}
000004  b08d              SUB      sp,sp,#0x34
000006  4681              MOV      r9,r0
000008  460e              MOV      r6,r1
;;;566        uint32_t stack_pointer = fault_handler_sp, saved_regs_addr = stack_pointer;
00000a  4635              MOV      r5,r6
00000c  462c              MOV      r4,r5
;;;567        const char *regs_name[] = { "R0 ", "R1 ", "R2 ", "R3 ", "R12", "LR ", "PC ", "PSR" };
00000e  2220              MOVS     r2,#0x20
000010  4963              LDR      r1,|L3.416|
000012  a805              ADD      r0,sp,#0x14
000014  f7fffffe          BL       __aeabi_memcpy4
;;;568    
;;;569    #ifdef CMB_USING_DUMP_STACK_INFO
;;;570        uint32_t stack_start_addr = main_stack_start_addr;
000018  4862              LDR      r0,|L3.420|
00001a  6807              LDR      r7,[r0,#0]  ; main_stack_start_addr
;;;571        size_t stack_size = main_stack_size;
00001c  4862              LDR      r0,|L3.424|
00001e  f8d08000          LDR      r8,[r0,#0]  ; main_stack_size
;;;572    #endif
;;;573    
;;;574        CMB_ASSERT(init_ok);
000022  4862              LDR      r0,|L3.428|
000024  7800              LDRB     r0,[r0,#0]  ; init_ok
000026  b948              CBNZ     r0,|L3.60|
000028  4a61              LDR      r2,|L3.432|
00002a  a162              ADR      r1,|L3.436|
00002c  a063              ADR      r0,|L3.444|
00002e  f7fffffe          BL       print_UART1
000032  a06a              ADR      r0,|L3.476|
000034  f7fffffe          BL       print_UART1
000038  bf00              NOP      
                  |L3.58|
00003a  e7fe              B        |L3.58|
                  |L3.60|
;;;575        /* only call once */
;;;576        CMB_ASSERT(!on_fault);
00003c  4868              LDR      r0,|L3.480|
00003e  7800              LDRB     r0,[r0,#0]  ; on_fault
000040  b148              CBZ      r0,|L3.86|
000042  4a5b              LDR      r2,|L3.432|
000044  a167              ADR      r1,|L3.484|
000046  a05d              ADR      r0,|L3.444|
000048  f7fffffe          BL       print_UART1
00004c  a063              ADR      r0,|L3.476|
00004e  f7fffffe          BL       print_UART1
000052  bf00              NOP      
                  |L3.84|
000054  e7fe              B        |L3.84|
                  |L3.86|
;;;577    
;;;578        on_fault = true;
000056  2001              MOVS     r0,#1
000058  4961              LDR      r1,|L3.480|
00005a  7008              STRB     r0,[r1,#0]
;;;579    
;;;580        cmb_println("");
00005c  a064              ADR      r0,|L3.496|
00005e  f7fffffe          BL       print_UART1
000062  a05e              ADR      r0,|L3.476|
000064  f7fffffe          BL       print_UART1
;;;581        cm_backtrace_firmware_info();
000068  f7fffffe          BL       cm_backtrace_firmware_info
;;;582    
;;;583    #ifdef CMB_USING_OS_PLATFORM
;;;584        on_thread_before_fault = fault_handler_lr & (1UL << 2);
;;;585        /* check which stack was used before (MSP or PSP) */
;;;586        if (on_thread_before_fault) {
;;;587            cmb_println(print_info[PRINT_FAULT_ON_THREAD], get_cur_thread_name() != NULL ? get_cur_thread_name() : "NO_NAME");
;;;588            saved_regs_addr = stack_pointer = cmb_get_psp();
;;;589    
;;;590    #ifdef CMB_USING_DUMP_STACK_INFO
;;;591            get_cur_thread_stack_info(stack_pointer, &stack_start_addr, &stack_size);
;;;592    #endif /* CMB_USING_DUMP_STACK_INFO */
;;;593    
;;;594        } else {
;;;595            cmb_println(print_info[PRINT_FAULT_ON_HANDLER]);
;;;596        }
;;;597    #else
;;;598        /* bare metal(no OS) environment */
;;;599        cmb_println(print_info[PRINT_FAULT_ON_HANDLER]);
00006c  4961              LDR      r1,|L3.500|
00006e  6ac8              LDR      r0,[r1,#0x2c]  ; print_info
000070  f7fffffe          BL       print_UART1
000074  a059              ADR      r0,|L3.476|
000076  f7fffffe          BL       print_UART1
;;;600    #endif /* CMB_USING_OS_PLATFORM */
;;;601    
;;;602        /* delete saved R0~R3, R12, LR,PC,xPSR registers space */
;;;603        stack_pointer += sizeof(size_t) * 8;
00007a  3520              ADDS     r5,r5,#0x20
;;;604    
;;;605    #if (CMB_CPU_PLATFORM_TYPE == CMB_CPU_ARM_CORTEX_M4) || (CMB_CPU_PLATFORM_TYPE == CMB_CPU_ARM_CORTEX_M7) || \
;;;606        (CMB_CPU_PLATFORM_TYPE == CMB_CPU_ARM_CORTEX_M33)
;;;607        stack_pointer = statck_del_fpu_regs(fault_handler_lr, stack_pointer);
00007c  4629              MOV      r1,r5
00007e  4648              MOV      r0,r9
000080  f7fffffe          BL       statck_del_fpu_regs
000084  4605              MOV      r5,r0
;;;608    #endif /* (CMB_CPU_PLATFORM_TYPE == CMB_CPU_ARM_CORTEX_M4) || (CMB_CPU_PLATFORM_TYPE == CMB_CPU_ARM_CORTEX_M7) */
;;;609    
;;;610    #ifdef CMB_USING_DUMP_STACK_INFO
;;;611        /* check stack overflow */
;;;612        if (stack_pointer < stack_start_addr || stack_pointer > stack_start_addr + stack_size) {
000086  42bd              CMP      r5,r7
000088  d303              BCC      |L3.146|
00008a  eb070008          ADD      r0,r7,r8
00008e  42a8              CMP      r0,r5
000090  d202              BCS      |L3.152|
                  |L3.146|
;;;613            stack_is_overflow = true;
000092  2001              MOVS     r0,#1
000094  4958              LDR      r1,|L3.504|
000096  7008              STRB     r0,[r1,#0]
                  |L3.152|
;;;614        }
;;;615        /* dump stack information */
;;;616        dump_stack(stack_start_addr, stack_size, (uint32_t *) stack_pointer);
000098  462a              MOV      r2,r5
00009a  4641              MOV      r1,r8
00009c  4638              MOV      r0,r7
00009e  f7fffffe          BL       dump_stack
;;;617    #endif /* CMB_USING_DUMP_STACK_INFO */
;;;618    
;;;619        /* the stack frame may be get failed when it is overflow  */
;;;620        if (!stack_is_overflow) {
0000a2  4855              LDR      r0,|L3.504|
0000a4  7800              LDRB     r0,[r0,#0]  ; stack_is_overflow
0000a6  2800              CMP      r0,#0
0000a8  d14b              BNE      |L3.322|
;;;621            /* dump register */
;;;622            cmb_println(print_info[PRINT_REGS_TITLE]);
0000aa  4952              LDR      r1,|L3.500|
0000ac  6b08              LDR      r0,[r1,#0x30]  ; print_info
0000ae  f7fffffe          BL       print_UART1
0000b2  a04a              ADR      r0,|L3.476|
0000b4  f7fffffe          BL       print_UART1
;;;623    
;;;624            regs.saved.r0        = ((uint32_t *)saved_regs_addr)[0];  // Register R0
0000b8  4950              LDR      r1,|L3.508|
0000ba  6820              LDR      r0,[r4,#0]
0000bc  6008              STR      r0,[r1,#0]  ; regs
;;;625            regs.saved.r1        = ((uint32_t *)saved_regs_addr)[1];  // Register R1
0000be  6860              LDR      r0,[r4,#4]
0000c0  6048              STR      r0,[r1,#4]  ; regs
;;;626            regs.saved.r2        = ((uint32_t *)saved_regs_addr)[2];  // Register R2
0000c2  68a0              LDR      r0,[r4,#8]
0000c4  6088              STR      r0,[r1,#8]  ; regs
;;;627            regs.saved.r3        = ((uint32_t *)saved_regs_addr)[3];  // Register R3
0000c6  68e0              LDR      r0,[r4,#0xc]
0000c8  60c8              STR      r0,[r1,#0xc]  ; regs
;;;628            regs.saved.r12       = ((uint32_t *)saved_regs_addr)[4];  // Register R12
0000ca  6920              LDR      r0,[r4,#0x10]
0000cc  6108              STR      r0,[r1,#0x10]  ; regs
;;;629            regs.saved.lr        = ((uint32_t *)saved_regs_addr)[5];  // Link register LR
0000ce  6960              LDR      r0,[r4,#0x14]
0000d0  6148              STR      r0,[r1,#0x14]  ; regs
;;;630            regs.saved.pc        = ((uint32_t *)saved_regs_addr)[6];  // Program counter PC
0000d2  69a0              LDR      r0,[r4,#0x18]
0000d4  6188              STR      r0,[r1,#0x18]  ; regs
;;;631            regs.saved.psr.value = ((uint32_t *)saved_regs_addr)[7];  // Program status word PSR
0000d6  69e0              LDR      r0,[r4,#0x1c]
0000d8  61c8              STR      r0,[r1,#0x1c]  ; regs
;;;632    
;;;633            cmb_println("  %s: %08x  %s: %08x  %s: %08x  %s: %08x", regs_name[0], regs.saved.r0,
0000da  4608              MOV      r0,r1
0000dc  68c0              LDR      r0,[r0,#0xc]  ; regs
0000de  4a47              LDR      r2,|L3.508|
0000e0  9908              LDR      r1,[sp,#0x20]
0000e2  6892              LDR      r2,[r2,#8]  ; regs
0000e4  9b07              LDR      r3,[sp,#0x1c]
0000e6  e9cd3201          STRD     r3,r2,[sp,#4]
0000ea  e9cd1003          STRD     r1,r0,[sp,#0xc]
0000ee  4843              LDR      r0,|L3.508|
0000f0  6840              LDR      r0,[r0,#4]  ; regs
0000f2  9000              STR      r0,[sp,#0]
0000f4  4841              LDR      r0,|L3.508|
0000f6  9b06              LDR      r3,[sp,#0x18]
0000f8  6802              LDR      r2,[r0,#0]  ; regs
0000fa  a041              ADR      r0,|L3.512|
0000fc  9905              LDR      r1,[sp,#0x14]
0000fe  f7fffffe          BL       print_UART1
000102  a036              ADR      r0,|L3.476|
000104  f7fffffe          BL       print_UART1
;;;634                                                                    regs_name[1], regs.saved.r1,
;;;635                                                                    regs_name[2], regs.saved.r2,
;;;636                                                                    regs_name[3], regs.saved.r3);
;;;637            cmb_println("  %s: %08x  %s: %08x  %s: %08x  %s: %08x", regs_name[4], regs.saved.r12,
000108  483c              LDR      r0,|L3.508|
00010a  69c0              LDR      r0,[r0,#0x1c]  ; regs
00010c  4a3b              LDR      r2,|L3.508|
00010e  990c              LDR      r1,[sp,#0x30]
000110  6992              LDR      r2,[r2,#0x18]  ; regs
000112  9b0b              LDR      r3,[sp,#0x2c]
000114  e9cd3201          STRD     r3,r2,[sp,#4]
000118  e9cd1003          STRD     r1,r0,[sp,#0xc]
00011c  4837              LDR      r0,|L3.508|
00011e  6940              LDR      r0,[r0,#0x14]  ; regs
000120  9000              STR      r0,[sp,#0]
000122  4836              LDR      r0,|L3.508|
000124  9b0a              LDR      r3,[sp,#0x28]
000126  6902              LDR      r2,[r0,#0x10]  ; regs
000128  a035              ADR      r0,|L3.512|
00012a  9909              LDR      r1,[sp,#0x24]
00012c  f7fffffe          BL       print_UART1
000130  a02a              ADR      r0,|L3.476|
000132  f7fffffe          BL       print_UART1
;;;638                                                                    regs_name[5], regs.saved.lr,
;;;639                                                                    regs_name[6], regs.saved.pc,
;;;640                                                                    regs_name[7], regs.saved.psr.value);
;;;641            cmb_println("==============================================================");
000136  a03d              ADR      r0,|L3.556|
000138  f7fffffe          BL       print_UART1
00013c  a027              ADR      r0,|L3.476|
00013e  f7fffffe          BL       print_UART1
                  |L3.322|
;;;642        }
;;;643    
;;;644        /* the Cortex-M0 is not support fault diagnosis */
;;;645    #if (CMB_CPU_PLATFORM_TYPE != CMB_CPU_ARM_CORTEX_M0)
;;;646        regs.syshndctrl.value = CMB_SYSHND_CTRL;  // System Handler Control and State Register
000142  484a              LDR      r0,|L3.620|
000144  6800              LDR      r0,[r0,#0]
000146  492d              LDR      r1,|L3.508|
000148  6208              STR      r0,[r1,#0x20]  ; regs
;;;647        regs.mfsr.value       = CMB_NVIC_MFSR;    // Memory Fault Status Register
00014a  4848              LDR      r0,|L3.620|
00014c  1d00              ADDS     r0,r0,#4
00014e  7800              LDRB     r0,[r0,#0]
000150  f8810024          STRB     r0,[r1,#0x24]
;;;648        regs.mmar             = CMB_NVIC_MMAR;    // Memory Management Fault Address Register
000154  4845              LDR      r0,|L3.620|
000156  3010              ADDS     r0,r0,#0x10
000158  6800              LDR      r0,[r0,#0]
00015a  6288              STR      r0,[r1,#0x28]  ; regs
;;;649        regs.bfsr.value       = CMB_NVIC_BFSR;    // Bus Fault Status Register
00015c  4843              LDR      r0,|L3.620|
00015e  1d40              ADDS     r0,r0,#5
000160  7800              LDRB     r0,[r0,#0]
000162  f881002c          STRB     r0,[r1,#0x2c]
;;;650        regs.bfar             = CMB_NVIC_BFAR;    // Bus Fault Manage Address Register
000166  4841              LDR      r0,|L3.620|
000168  3014              ADDS     r0,r0,#0x14
00016a  6800              LDR      r0,[r0,#0]
00016c  6308              STR      r0,[r1,#0x30]  ; regs
;;;651        regs.ufsr.value       = CMB_NVIC_UFSR;    // Usage Fault Status Register
00016e  483f              LDR      r0,|L3.620|
000170  1d80              ADDS     r0,r0,#6
000172  8800              LDRH     r0,[r0,#0]
000174  8688              STRH     r0,[r1,#0x34]
;;;652        regs.hfsr.value       = CMB_NVIC_HFSR;    // Hard Fault Status Register
000176  483d              LDR      r0,|L3.620|
000178  3008              ADDS     r0,r0,#8
00017a  6800              LDR      r0,[r0,#0]
00017c  6388              STR      r0,[r1,#0x38]  ; regs
;;;653        regs.dfsr.value       = CMB_NVIC_DFSR;    // Debug Fault Status Register
00017e  483b              LDR      r0,|L3.620|
000180  300c              ADDS     r0,r0,#0xc
000182  8800              LDRH     r0,[r0,#0]
000184  63c8              STR      r0,[r1,#0x3c]  ; regs
;;;654        regs.afsr             = CMB_NVIC_AFSR;    // Auxiliary Fault Status Register
000186  4839              LDR      r0,|L3.620|
000188  3018              ADDS     r0,r0,#0x18
00018a  8800              LDRH     r0,[r0,#0]
00018c  6408              STR      r0,[r1,#0x40]  ; regs
;;;655    
;;;656        fault_diagnosis();
00018e  f7fffffe          BL       fault_diagnosis
;;;657    #endif
;;;658    
;;;659        print_call_stack(stack_pointer);
000192  4628              MOV      r0,r5
000194  f7fffffe          BL       print_call_stack
;;;660    }
000198  b00d              ADD      sp,sp,#0x34
00019a  e8bd83f0          POP      {r4-r9,pc}
                          ENDP

00019e  0000              DCW      0x0000
                  |L3.416|
                          DCD      ||.constdata||+0xc0
                  |L3.420|
                          DCD      main_stack_start_addr
                  |L3.424|
                          DCD      main_stack_size
                  |L3.428|
                          DCD      init_ok
                  |L3.432|
                          DCD      |symbol_number.43|
                  |L3.436|
0001b4  696e6974          DCB      "init_ok",0
0001b8  5f6f6b00
                  |L3.444|
0001bc  28257329          DCB      "(%s) has assert failed at %s.",0
0001c0  20686173
0001c4  20617373
0001c8  65727420
0001cc  6661696c
0001d0  65642061
0001d4  74202573
0001d8  2e00    
0001da  00                DCB      0
0001db  00                DCB      0
                  |L3.476|
0001dc  0d0a00            DCB      "\r\n",0
0001df  00                DCB      0
                  |L3.480|
                          DCD      on_fault
                  |L3.484|
0001e4  216f6e5f          DCB      "!on_fault",0
0001e8  6661756c
0001ec  7400    
0001ee  00                DCB      0
0001ef  00                DCB      0
                  |L3.496|
0001f0  00                DCB      0
0001f1  00                DCB      0
0001f2  00                DCB      0
0001f3  00                DCB      0
                  |L3.500|
                          DCD      print_info
                  |L3.504|
                          DCD      stack_is_overflow
                  |L3.508|
                          DCD      regs
                  |L3.512|
000200  20202573          DCB      "  %s: %08x  %s: %08x  %s: %08x  %s: %08x",0
000204  3a202530
000208  38782020
00020c  25733a20
000210  25303878
000214  20202573
000218  3a202530
00021c  38782020
000220  25733a20
000224  25303878
000228  00      
000229  00                DCB      0
00022a  00                DCB      0
00022b  00                DCB      0
                  |L3.556|
00022c  3d3d3d3d          DCB      "======================================================="
000230  3d3d3d3d
000234  3d3d3d3d
000238  3d3d3d3d
00023c  3d3d3d3d
000240  3d3d3d3d
000244  3d3d3d3d
000248  3d3d3d3d
00024c  3d3d3d3d
000250  3d3d3d3d
000254  3d3d3d3d
000258  3d3d3d3d
00025c  3d3d3d3d
000260  3d3d3d  
000263  3d3d3d3d          DCB      "=======",0
000267  3d3d3d00
00026b  00                DCB      0
                  |L3.620|
                          DCD      0xe000ed24

                          AREA ||i.cm_backtrace_firmware_info||, CODE, READONLY, ALIGN=2

                  cm_backtrace_firmware_info PROC
;;;177     */
;;;178    void cm_backtrace_firmware_info(void) {
000000  b510              PUSH     {r4,lr}
;;;179        cmb_println(print_info[PRINT_FIRMWARE_INFO], fw_name, hw_ver, sw_ver);
000002  4905              LDR      r1,|L4.24|
000004  4b05              LDR      r3,|L4.28|
000006  4a06              LDR      r2,|L4.32|
000008  6848              LDR      r0,[r1,#4]  ; print_info
00000a  4906              LDR      r1,|L4.36|
00000c  f7fffffe          BL       print_UART1
000010  a005              ADR      r0,|L4.40|
000012  f7fffffe          BL       print_UART1
;;;180    }
000016  bd10              POP      {r4,pc}
;;;181    
                          ENDP

                  |L4.24|
                          DCD      print_info
                  |L4.28|
                          DCD      sw_ver
                  |L4.32|
                          DCD      hw_ver
                  |L4.36|
                          DCD      fw_name
                  |L4.40|
000028  0d0a00            DCB      "\r\n",0
00002b  00                DCB      0

                          AREA ||i.cm_backtrace_init||, CODE, READONLY, ALIGN=2

                  cm_backtrace_init PROC
;;;142     */
;;;143    void cm_backtrace_init(const char *firmware_name, const char *hardware_ver, const char *software_ver) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;144        strncpy(fw_name, firmware_name, CMB_NAME_MAX);
000008  2220              MOVS     r2,#0x20
00000a  4621              MOV      r1,r4
00000c  4816              LDR      r0,|L5.104|
00000e  f7fffffe          BL       strncpy
;;;145        strncpy(hw_ver, hardware_ver, CMB_NAME_MAX);
000012  2220              MOVS     r2,#0x20
000014  4631              MOV      r1,r6
000016  4815              LDR      r0,|L5.108|
000018  f7fffffe          BL       strncpy
;;;146        strncpy(sw_ver, software_ver, CMB_NAME_MAX);
00001c  2220              MOVS     r2,#0x20
00001e  4629              MOV      r1,r5
000020  4813              LDR      r0,|L5.112|
000022  f7fffffe          BL       strncpy
;;;147    
;;;148    #if defined(__CC_ARM) || defined(__CLANG_ARM)
;;;149        main_stack_start_addr = (uint32_t)&CSTACK_BLOCK_START(CMB_CSTACK_BLOCK_NAME);
000026  4813              LDR      r0,|L5.116|
000028  4913              LDR      r1,|L5.120|
00002a  6008              STR      r0,[r1,#0]  ; main_stack_start_addr
;;;150        main_stack_size = (uint32_t)&CSTACK_BLOCK_END(CMB_CSTACK_BLOCK_NAME) - main_stack_start_addr;
00002c  4813              LDR      r0,|L5.124|
00002e  6809              LDR      r1,[r1,#0]  ; main_stack_start_addr
000030  1a40              SUBS     r0,r0,r1
000032  4913              LDR      r1,|L5.128|
000034  6008              STR      r0,[r1,#0]  ; main_stack_size
;;;151        code_start_addr = (uint32_t)&CODE_SECTION_START(CMB_CODE_SECTION_NAME);
000036  4813              LDR      r0,|L5.132|
000038  4913              LDR      r1,|L5.136|
00003a  6008              STR      r0,[r1,#0]  ; code_start_addr
;;;152        code_size = (uint32_t)&CODE_SECTION_END(CMB_CODE_SECTION_NAME) - code_start_addr;
00003c  4813              LDR      r0,|L5.140|
00003e  6809              LDR      r1,[r1,#0]  ; code_start_addr
000040  1a40              SUBS     r0,r0,r1
000042  4913              LDR      r1,|L5.144|
000044  6008              STR      r0,[r1,#0]  ; code_size
;;;153    #elif defined(__ICCARM__)
;;;154        main_stack_start_addr = (uint32_t)__section_begin(CMB_CSTACK_BLOCK_NAME);
;;;155        main_stack_size = (uint32_t)__section_end(CMB_CSTACK_BLOCK_NAME) - main_stack_start_addr;
;;;156        code_start_addr = (uint32_t)__section_begin(CMB_CODE_SECTION_NAME);
;;;157        code_size = (uint32_t)__section_end(CMB_CODE_SECTION_NAME) - code_start_addr;
;;;158    #elif defined(__GNUC__)
;;;159        main_stack_start_addr = (uint32_t)(&CMB_CSTACK_BLOCK_START);
;;;160        main_stack_size = (uint32_t)(&CMB_CSTACK_BLOCK_END) - main_stack_start_addr;
;;;161        code_start_addr = (uint32_t)(&CMB_CODE_SECTION_START);
;;;162        code_size = (uint32_t)(&CMB_CODE_SECTION_END) - code_start_addr;
;;;163    #else
;;;164        #error "not supported compiler"
;;;165    #endif
;;;166    
;;;167        if (main_stack_size == 0) {
000046  480e              LDR      r0,|L5.128|
000048  6800              LDR      r0,[r0,#0]  ; main_stack_size
00004a  b938              CBNZ     r0,|L5.92|
;;;168            cmb_println(print_info[PRINT_MAIN_STACK_CFG_ERROR]);
00004c  4911              LDR      r1,|L5.148|
00004e  6808              LDR      r0,[r1,#0]  ; print_info
000050  f7fffffe          BL       print_UART1
000054  a010              ADR      r0,|L5.152|
000056  f7fffffe          BL       print_UART1
                  |L5.90|
;;;169            return;
;;;170        }
;;;171    
;;;172        init_ok = true;
;;;173    }
00005a  bd70              POP      {r4-r6,pc}
                  |L5.92|
00005c  2001              MOVS     r0,#1                 ;172
00005e  490f              LDR      r1,|L5.156|
000060  7008              STRB     r0,[r1,#0]            ;172
000062  bf00              NOP      
000064  e7f9              B        |L5.90|
;;;174    
                          ENDP

000066  0000              DCW      0x0000
                  |L5.104|
                          DCD      fw_name
                  |L5.108|
                          DCD      hw_ver
                  |L5.112|
                          DCD      sw_ver
                  |L5.116|
                          DCD      ||STACK$$Base||
                  |L5.120|
                          DCD      main_stack_start_addr
                  |L5.124|
                          DCD      ||STACK$$Limit||
                  |L5.128|
                          DCD      main_stack_size
                  |L5.132|
                          DCD      ||Image$$ER_IROM1$$Base||
                  |L5.136|
                          DCD      code_start_addr
                  |L5.140|
                          DCD      ||Image$$ER_IROM1$$Limit||
                  |L5.144|
                          DCD      code_size
                  |L5.148|
                          DCD      print_info
                  |L5.152|
000098  0d0a00            DCB      "\r\n",0
00009b  00                DCB      0
                  |L5.156|
                          DCD      init_ok

                          AREA ||i.disassembly_ins_is_bl_blx||, CODE, READONLY, ALIGN=1

                  disassembly_ins_is_bl_blx PROC
;;;264    /* check the disassembly instruction is 'BL' or 'BLX' */
;;;265    static bool disassembly_ins_is_bl_blx(uint32_t addr) {
000000  4601              MOV      r1,r0
;;;266        uint16_t ins1 = *((uint16_t *)addr);
000002  880b              LDRH     r3,[r1,#0]
;;;267        uint16_t ins2 = *((uint16_t *)(addr + 2));
000004  884a              LDRH     r2,[r1,#2]
;;;268    
;;;269    #define BL_INS_MASK         0xF800
;;;270    #define BL_INS_HIGH         0xF800
;;;271    #define BL_INS_LOW          0xF000
;;;272    #define BLX_INX_MASK        0xFF00
;;;273    #define BLX_INX             0x4700
;;;274    
;;;275        if ((ins2 & BL_INS_MASK) == BL_INS_HIGH && (ins1 & BL_INS_MASK) == BL_INS_LOW) {
000006  f4024078          AND      r0,r2,#0xf800
00000a  f5b04f78          CMP      r0,#0xf800
00000e  d106              BNE      |L6.30|
000010  f4034078          AND      r0,r3,#0xf800
000014  f5b04f70          CMP      r0,#0xf000
000018  d101              BNE      |L6.30|
;;;276            return true;
00001a  2001              MOVS     r0,#1
                  |L6.28|
;;;277        } else if ((ins2 & BLX_INX_MASK) == BLX_INX) {
;;;278            return true;
;;;279        } else {
;;;280            return false;
;;;281        }
;;;282    }
00001c  4770              BX       lr
                  |L6.30|
00001e  f402407f          AND      r0,r2,#0xff00         ;277
000022  f5b04f8e          CMP      r0,#0x4700            ;277
000026  d101              BNE      |L6.44|
000028  2001              MOVS     r0,#1                 ;278
00002a  e7f7              B        |L6.28|
                  |L6.44|
00002c  2000              MOVS     r0,#0                 ;280
00002e  e7f5              B        |L6.28|
;;;283    
                          ENDP


                          AREA ||i.dump_stack||, CODE, READONLY, ALIGN=2

                  dump_stack PROC
;;;242     */
;;;243    static void dump_stack(uint32_t stack_start_addr, size_t stack_size, uint32_t *stack_pointer) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;244        if (stack_is_overflow) {
000008  481c              LDR      r0,|L7.124|
00000a  7800              LDRB     r0,[r0,#0]  ; stack_is_overflow
00000c  b1d8              CBZ      r0,|L7.70|
;;;245            if (on_thread_before_fault) {
00000e  481c              LDR      r0,|L7.128|
000010  7800              LDRB     r0,[r0,#0]  ; on_thread_before_fault
000012  b140              CBZ      r0,|L7.38|
;;;246                cmb_println(print_info[PRINT_THREAD_STACK_OVERFLOW], stack_pointer);
000014  491b              LDR      r1,|L7.132|
000016  6988              LDR      r0,[r1,#0x18]  ; print_info
000018  4621              MOV      r1,r4
00001a  f7fffffe          BL       print_UART1
00001e  a01a              ADR      r0,|L7.136|
000020  f7fffffe          BL       print_UART1
000024  e007              B        |L7.54|
                  |L7.38|
;;;247            } else {
;;;248                cmb_println(print_info[PRINT_MAIN_STACK_OVERFLOW], stack_pointer);
000026  4917              LDR      r1,|L7.132|
000028  69c8              LDR      r0,[r1,#0x1c]  ; print_info
00002a  4621              MOV      r1,r4
00002c  f7fffffe          BL       print_UART1
000030  a015              ADR      r0,|L7.136|
000032  f7fffffe          BL       print_UART1
                  |L7.54|
;;;249            }
;;;250            if ((uint32_t) stack_pointer < stack_start_addr) {
000036  42ac              CMP      r4,r5
000038  d201              BCS      |L7.62|
;;;251                stack_pointer = (uint32_t *) stack_start_addr;
00003a  462c              MOV      r4,r5
00003c  e003              B        |L7.70|
                  |L7.62|
;;;252            } else if ((uint32_t) stack_pointer > stack_start_addr + stack_size) {
00003e  19a8              ADDS     r0,r5,r6
000040  42a0              CMP      r0,r4
000042  d200              BCS      |L7.70|
;;;253                stack_pointer = (uint32_t *) (stack_start_addr + stack_size);
000044  19ac              ADDS     r4,r5,r6
                  |L7.70|
;;;254            }
;;;255        }
;;;256        cmb_println(print_info[PRINT_THREAD_STACK_INFO]);
000046  490f              LDR      r1,|L7.132|
000048  6908              LDR      r0,[r1,#0x10]  ; print_info
00004a  f7fffffe          BL       print_UART1
00004e  a00e              ADR      r0,|L7.136|
000050  f7fffffe          BL       print_UART1
;;;257        for (; (uint32_t) stack_pointer < stack_start_addr + stack_size; stack_pointer++) {
000054  e008              B        |L7.104|
                  |L7.86|
;;;258            cmb_println("  addr: %08x    data: %08x", stack_pointer, *stack_pointer);
000056  4621              MOV      r1,r4
000058  a00c              ADR      r0,|L7.140|
00005a  6822              LDR      r2,[r4,#0]
00005c  f7fffffe          BL       print_UART1
000060  a009              ADR      r0,|L7.136|
000062  f7fffffe          BL       print_UART1
000066  1d24              ADDS     r4,r4,#4              ;257
                  |L7.104|
000068  19a8              ADDS     r0,r5,r6              ;257
00006a  42a0              CMP      r0,r4                 ;257
00006c  d8f3              BHI      |L7.86|
;;;259        }
;;;260        cmb_println("====================================");
00006e  a00e              ADR      r0,|L7.168|
000070  f7fffffe          BL       print_UART1
000074  a004              ADR      r0,|L7.136|
000076  f7fffffe          BL       print_UART1
;;;261    }
00007a  bd70              POP      {r4-r6,pc}
;;;262    #endif /* CMB_USING_DUMP_STACK_INFO */
                          ENDP

                  |L7.124|
                          DCD      stack_is_overflow
                  |L7.128|
                          DCD      on_thread_before_fault
                  |L7.132|
                          DCD      print_info
                  |L7.136|
000088  0d0a00            DCB      "\r\n",0
00008b  00                DCB      0
                  |L7.140|
00008c  20206164          DCB      "  addr: %08x    data: %08x",0
000090  64723a20
000094  25303878
000098  20202020
00009c  64617461
0000a0  3a202530
0000a4  387800  
0000a7  00                DCB      0
                  |L7.168|
0000a8  3d3d3d3d          DCB      "====================================",0
0000ac  3d3d3d3d
0000b0  3d3d3d3d
0000b4  3d3d3d3d
0000b8  3d3d3d3d
0000bc  3d3d3d3d
0000c0  3d3d3d3d
0000c4  3d3d3d3d
0000c8  3d3d3d3d
0000cc  00      
0000cd  00                DCB      0
0000ce  00                DCB      0
0000cf  00                DCB      0

                          AREA ||i.fault_diagnosis||, CODE, READONLY, ALIGN=2

                  fault_diagnosis PROC
;;;432     */
;;;433    static void fault_diagnosis(void) {
000000  b510              PUSH     {r4,lr}
;;;434        if (regs.hfsr.bits.VECTBL) {
000002  48be              LDR      r0,|L8.764|
000004  f8900038          LDRB     r0,[r0,#0x38]  ; regs
000008  f3c00040          UBFX     r0,r0,#1,#1
00000c  b130              CBZ      r0,|L8.28|
;;;435            cmb_println(print_info[PRINT_HFSR_VECTBL]);
00000e  49bc              LDR      r1,|L8.768|
000010  6b48              LDR      r0,[r1,#0x34]  ; print_info
000012  f7fffffe          BL       print_UART1
000016  a0bb              ADR      r0,|L8.772|
000018  f7fffffe          BL       print_UART1
                  |L8.28|
;;;436        }
;;;437        if (regs.hfsr.bits.FORCED) {
00001c  48b7              LDR      r0,|L8.764|
00001e  6b80              LDR      r0,[r0,#0x38]  ; regs
000020  f3c07080          UBFX     r0,r0,#30,#1
000024  2800              CMP      r0,#0
000026  d07d              BEQ      |L8.292|
;;;438            /* Memory Management Fault */
;;;439            if (regs.mfsr.value) {
000028  48b4              LDR      r0,|L8.764|
00002a  f8900024          LDRB     r0,[r0,#0x24]  ; regs
00002e  2800              CMP      r0,#0
000030  d05b              BEQ      |L8.234|
;;;440                if (regs.mfsr.bits.IACCVIOL) {
000032  48b2              LDR      r0,|L8.764|
000034  f8900024          LDRB     r0,[r0,#0x24]  ; regs
000038  f0000001          AND      r0,r0,#1
00003c  b130              CBZ      r0,|L8.76|
;;;441                    cmb_println(print_info[PRINT_MFSR_IACCVIOL]);
00003e  49b0              LDR      r1,|L8.768|
000040  6b88              LDR      r0,[r1,#0x38]  ; print_info
000042  f7fffffe          BL       print_UART1
000046  a0af              ADR      r0,|L8.772|
000048  f7fffffe          BL       print_UART1
                  |L8.76|
;;;442                }
;;;443                if (regs.mfsr.bits.DACCVIOL) {
00004c  48ab              LDR      r0,|L8.764|
00004e  f8900024          LDRB     r0,[r0,#0x24]  ; regs
000052  f3c00040          UBFX     r0,r0,#1,#1
000056  b130              CBZ      r0,|L8.102|
;;;444                    cmb_println(print_info[PRINT_MFSR_DACCVIOL]);
000058  49a9              LDR      r1,|L8.768|
00005a  6bc8              LDR      r0,[r1,#0x3c]  ; print_info
00005c  f7fffffe          BL       print_UART1
000060  a0a8              ADR      r0,|L8.772|
000062  f7fffffe          BL       print_UART1
                  |L8.102|
;;;445                }
;;;446                if (regs.mfsr.bits.MUNSTKERR) {
000066  48a5              LDR      r0,|L8.764|
000068  f8900024          LDRB     r0,[r0,#0x24]  ; regs
00006c  f3c000c0          UBFX     r0,r0,#3,#1
000070  b130              CBZ      r0,|L8.128|
;;;447                    cmb_println(print_info[PRINT_MFSR_MUNSTKERR]);
000072  49a3              LDR      r1,|L8.768|
000074  6c08              LDR      r0,[r1,#0x40]  ; print_info
000076  f7fffffe          BL       print_UART1
00007a  a0a2              ADR      r0,|L8.772|
00007c  f7fffffe          BL       print_UART1
                  |L8.128|
;;;448                }
;;;449                if (regs.mfsr.bits.MSTKERR) {
000080  489e              LDR      r0,|L8.764|
000082  f8900024          LDRB     r0,[r0,#0x24]  ; regs
000086  f3c01000          UBFX     r0,r0,#4,#1
00008a  b130              CBZ      r0,|L8.154|
;;;450                    cmb_println(print_info[PRINT_MFSR_MSTKERR]);
00008c  499c              LDR      r1,|L8.768|
00008e  6c48              LDR      r0,[r1,#0x44]  ; print_info
000090  f7fffffe          BL       print_UART1
000094  a09b              ADR      r0,|L8.772|
000096  f7fffffe          BL       print_UART1
                  |L8.154|
;;;451                }
;;;452    
;;;453    #if (CMB_CPU_PLATFORM_TYPE == CMB_CPU_ARM_CORTEX_M4) || (CMB_CPU_PLATFORM_TYPE == CMB_CPU_ARM_CORTEX_M7) || \
;;;454        (CMB_CPU_PLATFORM_TYPE == CMB_CPU_ARM_CORTEX_M33)
;;;455                if (regs.mfsr.bits.MLSPERR) {
00009a  4898              LDR      r0,|L8.764|
00009c  f8900024          LDRB     r0,[r0,#0x24]  ; regs
0000a0  f3c01040          UBFX     r0,r0,#5,#1
0000a4  b130              CBZ      r0,|L8.180|
;;;456                    cmb_println(print_info[PRINT_MFSR_MLSPERR]);
0000a6  4996              LDR      r1,|L8.768|
0000a8  6c88              LDR      r0,[r1,#0x48]  ; print_info
0000aa  f7fffffe          BL       print_UART1
0000ae  a095              ADR      r0,|L8.772|
0000b0  f7fffffe          BL       print_UART1
                  |L8.180|
;;;457                }
;;;458    #endif
;;;459    
;;;460                if (regs.mfsr.bits.MMARVALID) {
0000b4  4891              LDR      r0,|L8.764|
0000b6  f8900024          LDRB     r0,[r0,#0x24]  ; regs
0000ba  09c0              LSRS     r0,r0,#7
0000bc  b1a8              CBZ      r0,|L8.234|
;;;461                    if (regs.mfsr.bits.IACCVIOL || regs.mfsr.bits.DACCVIOL) {
0000be  488f              LDR      r0,|L8.764|
0000c0  f8900024          LDRB     r0,[r0,#0x24]  ; regs
0000c4  f0000001          AND      r0,r0,#1
0000c8  b928              CBNZ     r0,|L8.214|
0000ca  488c              LDR      r0,|L8.764|
0000cc  f8900024          LDRB     r0,[r0,#0x24]  ; regs
0000d0  f3c00040          UBFX     r0,r0,#1,#1
0000d4  b148              CBZ      r0,|L8.234|
                  |L8.214|
;;;462                        cmb_println(print_info[PRINT_MMAR], regs.mmar);
0000d6  4a89              LDR      r2,|L8.764|
0000d8  6a91              LDR      r1,[r2,#0x28]  ; regs
0000da  4a89              LDR      r2,|L8.768|
0000dc  f8d20090          LDR      r0,[r2,#0x90]  ; print_info
0000e0  f7fffffe          BL       print_UART1
0000e4  a087              ADR      r0,|L8.772|
0000e6  f7fffffe          BL       print_UART1
                  |L8.234|
;;;463                    }
;;;464                }
;;;465            }
;;;466            /* Bus Fault */
;;;467            if (regs.bfsr.value) {
0000ea  4884              LDR      r0,|L8.764|
0000ec  f890002c          LDRB     r0,[r0,#0x2c]  ; regs
0000f0  2800              CMP      r0,#0
0000f2  d064              BEQ      |L8.446|
;;;468                if (regs.bfsr.bits.IBUSERR) {
0000f4  4881              LDR      r0,|L8.764|
0000f6  f890002c          LDRB     r0,[r0,#0x2c]  ; regs
0000fa  f0000001          AND      r0,r0,#1
0000fe  b130              CBZ      r0,|L8.270|
;;;469                    cmb_println(print_info[PRINT_BFSR_IBUSERR]);
000100  497f              LDR      r1,|L8.768|
000102  6cc8              LDR      r0,[r1,#0x4c]  ; print_info
000104  f7fffffe          BL       print_UART1
000108  a07e              ADR      r0,|L8.772|
00010a  f7fffffe          BL       print_UART1
                  |L8.270|
;;;470                }
;;;471                if (regs.bfsr.bits.PRECISERR) {
00010e  487b              LDR      r0,|L8.764|
000110  f890002c          LDRB     r0,[r0,#0x2c]  ; regs
000114  f3c00040          UBFX     r0,r0,#1,#1
000118  b140              CBZ      r0,|L8.300|
;;;472                    cmb_println(print_info[PRINT_BFSR_PRECISERR]);
00011a  4979              LDR      r1,|L8.768|
00011c  6d08              LDR      r0,[r1,#0x50]  ; print_info
00011e  f7fffffe          BL       print_UART1
000122  e000              B        |L8.294|
                  |L8.292|
000124  e09b              B        |L8.606|
                  |L8.294|
000126  a077              ADR      r0,|L8.772|
000128  f7fffffe          BL       print_UART1
                  |L8.300|
;;;473                }
;;;474                if (regs.bfsr.bits.IMPREISERR) {
00012c  4873              LDR      r0,|L8.764|
00012e  f890002c          LDRB     r0,[r0,#0x2c]  ; regs
000132  f3c00080          UBFX     r0,r0,#2,#1
000136  b130              CBZ      r0,|L8.326|
;;;475                    cmb_println(print_info[PRINT_BFSR_IMPREISERR]);
000138  4971              LDR      r1,|L8.768|
00013a  6d48              LDR      r0,[r1,#0x54]  ; print_info
00013c  f7fffffe          BL       print_UART1
000140  a070              ADR      r0,|L8.772|
000142  f7fffffe          BL       print_UART1
                  |L8.326|
;;;476                }
;;;477                if (regs.bfsr.bits.UNSTKERR) {
000146  486d              LDR      r0,|L8.764|
000148  f890002c          LDRB     r0,[r0,#0x2c]  ; regs
00014c  f3c000c0          UBFX     r0,r0,#3,#1
000150  b130              CBZ      r0,|L8.352|
;;;478                    cmb_println(print_info[PRINT_BFSR_UNSTKERR]);
000152  496b              LDR      r1,|L8.768|
000154  6d88              LDR      r0,[r1,#0x58]  ; print_info
000156  f7fffffe          BL       print_UART1
00015a  a06a              ADR      r0,|L8.772|
00015c  f7fffffe          BL       print_UART1
                  |L8.352|
;;;479                }
;;;480                if (regs.bfsr.bits.STKERR) {
000160  4866              LDR      r0,|L8.764|
000162  f890002c          LDRB     r0,[r0,#0x2c]  ; regs
000166  f3c01000          UBFX     r0,r0,#4,#1
00016a  b130              CBZ      r0,|L8.378|
;;;481                    cmb_println(print_info[PRINT_BFSR_STKERR]);
00016c  4964              LDR      r1,|L8.768|
00016e  6dc8              LDR      r0,[r1,#0x5c]  ; print_info
000170  f7fffffe          BL       print_UART1
000174  a063              ADR      r0,|L8.772|
000176  f7fffffe          BL       print_UART1
                  |L8.378|
;;;482                }
;;;483    
;;;484    #if (CMB_CPU_PLATFORM_TYPE == CMB_CPU_ARM_CORTEX_M4) || (CMB_CPU_PLATFORM_TYPE == CMB_CPU_ARM_CORTEX_M7) || \
;;;485        (CMB_CPU_PLATFORM_TYPE == CMB_CPU_ARM_CORTEX_M33)
;;;486                if (regs.bfsr.bits.LSPERR) {
00017a  4860              LDR      r0,|L8.764|
00017c  f890002c          LDRB     r0,[r0,#0x2c]  ; regs
000180  f3c01040          UBFX     r0,r0,#5,#1
000184  b130              CBZ      r0,|L8.404|
;;;487                    cmb_println(print_info[PRINT_BFSR_LSPERR]);
000186  495e              LDR      r1,|L8.768|
000188  6e08              LDR      r0,[r1,#0x60]  ; print_info
00018a  f7fffffe          BL       print_UART1
00018e  a05d              ADR      r0,|L8.772|
000190  f7fffffe          BL       print_UART1
                  |L8.404|
;;;488                }
;;;489    #endif
;;;490    
;;;491                if (regs.bfsr.bits.BFARVALID) {
000194  4859              LDR      r0,|L8.764|
000196  f890002c          LDRB     r0,[r0,#0x2c]  ; regs
00019a  09c0              LSRS     r0,r0,#7
00019c  b178              CBZ      r0,|L8.446|
;;;492                    if (regs.bfsr.bits.PRECISERR) {
00019e  4857              LDR      r0,|L8.764|
0001a0  f890002c          LDRB     r0,[r0,#0x2c]  ; regs
0001a4  f3c00040          UBFX     r0,r0,#1,#1
0001a8  b148              CBZ      r0,|L8.446|
;;;493                        cmb_println(print_info[PRINT_BFAR], regs.bfar);
0001aa  4a54              LDR      r2,|L8.764|
0001ac  6b11              LDR      r1,[r2,#0x30]  ; regs
0001ae  4a54              LDR      r2,|L8.768|
0001b0  f8d20094          LDR      r0,[r2,#0x94]  ; print_info
0001b4  f7fffffe          BL       print_UART1
0001b8  a052              ADR      r0,|L8.772|
0001ba  f7fffffe          BL       print_UART1
                  |L8.446|
;;;494                    }
;;;495                }
;;;496    
;;;497            }
;;;498            /* Usage Fault */
;;;499            if (regs.ufsr.value) {
0001be  484f              LDR      r0,|L8.764|
0001c0  8e80              LDRH     r0,[r0,#0x34]  ; regs
0001c2  2800              CMP      r0,#0
0001c4  d04b              BEQ      |L8.606|
;;;500                if (regs.ufsr.bits.UNDEFINSTR) {
0001c6  484d              LDR      r0,|L8.764|
0001c8  f8900034          LDRB     r0,[r0,#0x34]  ; regs
0001cc  f0000001          AND      r0,r0,#1
0001d0  b130              CBZ      r0,|L8.480|
;;;501                    cmb_println(print_info[PRINT_UFSR_UNDEFINSTR]);
0001d2  494b              LDR      r1,|L8.768|
0001d4  6e48              LDR      r0,[r1,#0x64]  ; print_info
0001d6  f7fffffe          BL       print_UART1
0001da  a04a              ADR      r0,|L8.772|
0001dc  f7fffffe          BL       print_UART1
                  |L8.480|
;;;502                }
;;;503                if (regs.ufsr.bits.INVSTATE) {
0001e0  4846              LDR      r0,|L8.764|
0001e2  f8900034          LDRB     r0,[r0,#0x34]  ; regs
0001e6  f3c00040          UBFX     r0,r0,#1,#1
0001ea  b130              CBZ      r0,|L8.506|
;;;504                    cmb_println(print_info[PRINT_UFSR_INVSTATE]);
0001ec  4944              LDR      r1,|L8.768|
0001ee  6e88              LDR      r0,[r1,#0x68]  ; print_info
0001f0  f7fffffe          BL       print_UART1
0001f4  a043              ADR      r0,|L8.772|
0001f6  f7fffffe          BL       print_UART1
                  |L8.506|
;;;505                }
;;;506                if (regs.ufsr.bits.INVPC) {
0001fa  4840              LDR      r0,|L8.764|
0001fc  f8900034          LDRB     r0,[r0,#0x34]  ; regs
000200  f3c00080          UBFX     r0,r0,#2,#1
000204  b130              CBZ      r0,|L8.532|
;;;507                    cmb_println(print_info[PRINT_UFSR_INVPC]);
000206  493e              LDR      r1,|L8.768|
000208  6ec8              LDR      r0,[r1,#0x6c]  ; print_info
00020a  f7fffffe          BL       print_UART1
00020e  a03d              ADR      r0,|L8.772|
000210  f7fffffe          BL       print_UART1
                  |L8.532|
;;;508                }
;;;509                if (regs.ufsr.bits.NOCP) {
000214  4839              LDR      r0,|L8.764|
000216  f8900034          LDRB     r0,[r0,#0x34]  ; regs
00021a  f3c000c0          UBFX     r0,r0,#3,#1
00021e  b130              CBZ      r0,|L8.558|
;;;510                    cmb_println(print_info[PRINT_UFSR_NOCP]);
000220  4937              LDR      r1,|L8.768|
000222  6f08              LDR      r0,[r1,#0x70]  ; print_info
000224  f7fffffe          BL       print_UART1
000228  a036              ADR      r0,|L8.772|
00022a  f7fffffe          BL       print_UART1
                  |L8.558|
;;;511                }
;;;512    #if (CMB_CPU_PLATFORM_TYPE == CMB_CPU_ARM_CORTEX_M33)
;;;513                if (regs.ufsr.bits.STKOF) {
;;;514                    cmb_println(print_info[PRINT_UFSR_STKOF]);
;;;515                }
;;;516    #endif
;;;517                if (regs.ufsr.bits.UNALIGNED) {
00022e  4833              LDR      r0,|L8.764|
000230  8e80              LDRH     r0,[r0,#0x34]  ; regs
000232  f3c02000          UBFX     r0,r0,#8,#1
000236  b130              CBZ      r0,|L8.582|
;;;518                    cmb_println(print_info[PRINT_UFSR_UNALIGNED]);
000238  4931              LDR      r1,|L8.768|
00023a  6f48              LDR      r0,[r1,#0x74]  ; print_info
00023c  f7fffffe          BL       print_UART1
000240  a030              ADR      r0,|L8.772|
000242  f7fffffe          BL       print_UART1
                  |L8.582|
;;;519                }
;;;520                if (regs.ufsr.bits.DIVBYZERO0) {
000246  482d              LDR      r0,|L8.764|
000248  8e80              LDRH     r0,[r0,#0x34]  ; regs
00024a  f3c02040          UBFX     r0,r0,#9,#1
00024e  b130              CBZ      r0,|L8.606|
;;;521                    cmb_println(print_info[PRINT_UFSR_DIVBYZERO0]);
000250  492b              LDR      r1,|L8.768|
000252  6f88              LDR      r0,[r1,#0x78]  ; print_info
000254  f7fffffe          BL       print_UART1
000258  a02a              ADR      r0,|L8.772|
00025a  f7fffffe          BL       print_UART1
                  |L8.606|
;;;522                }
;;;523            }
;;;524        }
;;;525        /* Debug Fault */
;;;526        if (regs.hfsr.bits.DEBUGEVT) {
00025e  4827              LDR      r0,|L8.764|
000260  6b80              LDR      r0,[r0,#0x38]  ; regs
000262  0fc0              LSRS     r0,r0,#31
000264  2800              CMP      r0,#0
000266  d048              BEQ      |L8.762|
;;;527            if (regs.dfsr.value) {
000268  4824              LDR      r0,|L8.764|
00026a  6bc0              LDR      r0,[r0,#0x3c]  ; regs
00026c  2800              CMP      r0,#0
00026e  d044              BEQ      |L8.762|
;;;528                if (regs.dfsr.bits.HALTED) {
000270  4822              LDR      r0,|L8.764|
000272  f890003c          LDRB     r0,[r0,#0x3c]  ; regs
000276  f0000001          AND      r0,r0,#1
00027a  b130              CBZ      r0,|L8.650|
;;;529                    cmb_println(print_info[PRINT_DFSR_HALTED]);
00027c  4920              LDR      r1,|L8.768|
00027e  6fc8              LDR      r0,[r1,#0x7c]  ; print_info
000280  f7fffffe          BL       print_UART1
000284  a01f              ADR      r0,|L8.772|
000286  f7fffffe          BL       print_UART1
                  |L8.650|
;;;530                }
;;;531                if (regs.dfsr.bits.BKPT) {
00028a  481c              LDR      r0,|L8.764|
00028c  f890003c          LDRB     r0,[r0,#0x3c]  ; regs
000290  f3c00040          UBFX     r0,r0,#1,#1
000294  b138              CBZ      r0,|L8.678|
;;;532                    cmb_println(print_info[PRINT_DFSR_BKPT]);
000296  491a              LDR      r1,|L8.768|
000298  f8d10080          LDR      r0,[r1,#0x80]  ; print_info
00029c  f7fffffe          BL       print_UART1
0002a0  a018              ADR      r0,|L8.772|
0002a2  f7fffffe          BL       print_UART1
                  |L8.678|
;;;533                }
;;;534                if (regs.dfsr.bits.DWTTRAP) {
0002a6  4815              LDR      r0,|L8.764|
0002a8  f890003c          LDRB     r0,[r0,#0x3c]  ; regs
0002ac  f3c00080          UBFX     r0,r0,#2,#1
0002b0  b138              CBZ      r0,|L8.706|
;;;535                    cmb_println(print_info[PRINT_DFSR_DWTTRAP]);
0002b2  4913              LDR      r1,|L8.768|
0002b4  f8d10084          LDR      r0,[r1,#0x84]  ; print_info
0002b8  f7fffffe          BL       print_UART1
0002bc  a011              ADR      r0,|L8.772|
0002be  f7fffffe          BL       print_UART1
                  |L8.706|
;;;536                }
;;;537                if (regs.dfsr.bits.VCATCH) {
0002c2  480e              LDR      r0,|L8.764|
0002c4  f890003c          LDRB     r0,[r0,#0x3c]  ; regs
0002c8  f3c000c0          UBFX     r0,r0,#3,#1
0002cc  b138              CBZ      r0,|L8.734|
;;;538                    cmb_println(print_info[PRINT_DFSR_VCATCH]);
0002ce  490c              LDR      r1,|L8.768|
0002d0  f8d10088          LDR      r0,[r1,#0x88]  ; print_info
0002d4  f7fffffe          BL       print_UART1
0002d8  a00a              ADR      r0,|L8.772|
0002da  f7fffffe          BL       print_UART1
                  |L8.734|
;;;539                }
;;;540                if (regs.dfsr.bits.EXTERNAL) {
0002de  4807              LDR      r0,|L8.764|
0002e0  f890003c          LDRB     r0,[r0,#0x3c]  ; regs
0002e4  f3c01000          UBFX     r0,r0,#4,#1
0002e8  b138              CBZ      r0,|L8.762|
;;;541                    cmb_println(print_info[PRINT_DFSR_EXTERNAL]);
0002ea  4905              LDR      r1,|L8.768|
0002ec  f8d1008c          LDR      r0,[r1,#0x8c]  ; print_info
0002f0  f7fffffe          BL       print_UART1
0002f4  a003              ADR      r0,|L8.772|
0002f6  f7fffffe          BL       print_UART1
                  |L8.762|
;;;542                }
;;;543            }
;;;544        }
;;;545    }
0002fa  bd10              POP      {r4,pc}
;;;546    #endif /* (CMB_CPU_PLATFORM_TYPE != CMB_CPU_ARM_CORTEX_M0) */
                          ENDP

                  |L8.764|
                          DCD      regs
                  |L8.768|
                          DCD      print_info
                  |L8.772|
000304  0d0a00            DCB      "\r\n",0
000307  00                DCB      0

                          AREA ||i.print_call_stack||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_sizespec
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  print_call_stack PROC
;;;361     */
;;;362    static void print_call_stack(uint32_t sp) {
000000  b570              PUSH     {r4-r6,lr}
000002  b092              SUB      sp,sp,#0x48
000004  4606              MOV      r6,r0
;;;363        size_t i, cur_depth = 0;
000006  2500              MOVS     r5,#0
;;;364        uint32_t call_stack_buf[CMB_CALL_STACK_MAX_DEPTH] = {0};
000008  2140              MOVS     r1,#0x40
00000a  a802              ADD      r0,sp,#8
00000c  f7fffffe          BL       __aeabi_memclr4
;;;365    
;;;366        cur_depth = cm_backtrace_call_stack(call_stack_buf, CMB_CALL_STACK_MAX_DEPTH, sp);
000010  4632              MOV      r2,r6
000012  2110              MOVS     r1,#0x10
000014  a802              ADD      r0,sp,#8
000016  f7fffffe          BL       cm_backtrace_call_stack
00001a  4605              MOV      r5,r0
;;;367    
;;;368        for (i = 0; i < cur_depth; i++) {
00001c  2400              MOVS     r4,#0
00001e  e010              B        |L9.66|
                  |L9.32|
;;;369            sprintf(call_stack_info + i * (8 + 1), "%08lx", (unsigned long)call_stack_buf[i]);
000020  a902              ADD      r1,sp,#8
000022  f8512024          LDR      r2,[r1,r4,LSL #2]
000026  eb0401c4          ADD      r1,r4,r4,LSL #3
00002a  4b13              LDR      r3,|L9.120|
00002c  18c8              ADDS     r0,r1,r3
00002e  a113              ADR      r1,|L9.124|
000030  f7fffffe          BL       __2sprintf
;;;370            call_stack_info[i * (8 + 1) + 8] = ' ';
000034  2120              MOVS     r1,#0x20
000036  eb0400c4          ADD      r0,r4,r4,LSL #3
00003a  3008              ADDS     r0,r0,#8
00003c  4a0e              LDR      r2,|L9.120|
00003e  5411              STRB     r1,[r2,r0]
000040  1c64              ADDS     r4,r4,#1              ;368
                  |L9.66|
000042  42ac              CMP      r4,r5                 ;368
000044  d3ec              BCC      |L9.32|
;;;371        }
;;;372    
;;;373        if (cur_depth) {
000046  b16d              CBZ      r5,|L9.100|
;;;374            cmb_println(print_info[PRINT_CALL_STACK_INFO], fw_name, CMB_ELF_FILE_EXTENSION_NAME, cur_depth * (8 + 1),
000048  480b              LDR      r0,|L9.120|
00004a  eb0503c5          ADD      r3,r5,r5,LSL #3
00004e  490d              LDR      r1,|L9.132|
000050  9000              STR      r0,[sp,#0]
000052  a20d              ADR      r2,|L9.136|
000054  6a08              LDR      r0,[r1,#0x20]  ; print_info
000056  490e              LDR      r1,|L9.144|
000058  f7fffffe          BL       print_UART1
00005c  a00d              ADR      r0,|L9.148|
00005e  f7fffffe          BL       print_UART1
000062  e006              B        |L9.114|
                  |L9.100|
;;;375                    call_stack_info);
;;;376        } else {
;;;377            cmb_println(print_info[PRINT_CALL_STACK_ERR]);
000064  4907              LDR      r1,|L9.132|
000066  6a48              LDR      r0,[r1,#0x24]  ; print_info
000068  f7fffffe          BL       print_UART1
00006c  a009              ADR      r0,|L9.148|
00006e  f7fffffe          BL       print_UART1
                  |L9.114|
;;;378        }
;;;379    }
000072  b012              ADD      sp,sp,#0x48
000074  bd70              POP      {r4-r6,pc}
;;;380    
                          ENDP

000076  0000              DCW      0x0000
                  |L9.120|
                          DCD      call_stack_info
                  |L9.124|
00007c  2530386c          DCB      "%08lx",0
000080  7800    
000082  00                DCB      0
000083  00                DCB      0
                  |L9.132|
                          DCD      print_info
                  |L9.136|
000088  2e617866          DCB      ".axf",0
00008c  00      
00008d  00                DCB      0
00008e  00                DCB      0
00008f  00                DCB      0
                  |L9.144|
                          DCD      fw_name
                  |L9.148|
000094  0d0a00            DCB      "\r\n",0
000097  00                DCB      0

                          AREA ||i.statck_del_fpu_regs||, CODE, READONLY, ALIGN=2

                  statck_del_fpu_regs PROC
;;;549        (CMB_CPU_PLATFORM_TYPE == CMB_CPU_ARM_CORTEX_M33)
;;;550    static uint32_t statck_del_fpu_regs(uint32_t fault_handler_lr, uint32_t sp) {
000000  4602              MOV      r2,r0
;;;551        statck_has_fpu_regs = (fault_handler_lr & (1UL << 4)) == 0 ? true : false;
000002  2001              MOVS     r0,#1
000004  ea201012          BIC      r0,r0,r2,LSR #4
000008  4b05              LDR      r3,|L10.32|
00000a  7018              STRB     r0,[r3,#0]
;;;552    
;;;553        /* the stack has S0~S15 and FPSCR registers when statck_has_fpu_regs is true, double word align */
;;;554        return statck_has_fpu_regs == true ? sp + sizeof(size_t) * 18 : sp;
00000c  4618              MOV      r0,r3
00000e  7800              LDRB     r0,[r0,#0]  ; statck_has_fpu_regs
000010  2801              CMP      r0,#1
000012  d102              BNE      |L10.26|
000014  f1010048          ADD      r0,r1,#0x48
                  |L10.24|
;;;555    }
000018  4770              BX       lr
                  |L10.26|
00001a  4608              MOV      r0,r1                 ;554
00001c  e7fc              B        |L10.24|
;;;556    #endif
                          ENDP

00001e  0000              DCW      0x0000
                  |L10.32|
                          DCD      statck_has_fpu_regs

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  fw_name
                          %        32
                  hw_ver
                          %        32
                  sw_ver
                          %        32
                  call_stack_info
                          %        144
                  regs
                          %        68

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  print_info
                          DCD      ||.conststring||
                          DCD      ||.conststring||+0x64
                          DCD      ||.conststring||+0xa4
                          DCD      ||.conststring||+0xb8
                          DCD      ||.conststring||+0xf0
                          DCD      ||.conststring||+0x118
                          DCD      ||.conststring||+0x140
                          DCD      ||.conststring||+0x168
                          DCD      ||.conststring||+0x190
                          DCD      ||.conststring||+0x1d0
                          DCD      ||.conststring||+0x1f0
                          DCD      ||.conststring||+0x204
                          DCD      ||.conststring||+0x238
                          DCD      ||.conststring||+0x278
                          DCD      ||.conststring||+0x2a4
                          DCD      ||.conststring||+0x2e8
                          DCD      ||.conststring||+0x324
                          DCD      ||.conststring||+0x35c
                          DCD      ||.conststring||+0x390
                          DCD      ||.conststring||+0x3dc
                          DCD      ||.conststring||+0x410
                          DCD      ||.conststring||+0x448
                          DCD      ||.conststring||+0x480
                          DCD      ||.conststring||+0x4a8
                          DCD      ||.conststring||+0x4d0
                          DCD      ||.conststring||+0x510
                          DCD      ||.conststring||+0x558
                          DCD      ||.conststring||+0x5a4
                          DCD      ||.conststring||+0x604
                          DCD      ||.conststring||+0x64c
                          DCD      ||.conststring||+0x6a0
                          DCD      ||.conststring||+0x70c
                          DCD      ||.conststring||+0x73c
                          DCD      ||.conststring||+0x770
                          DCD      ||.conststring||+0x79c
                          DCD      ||.conststring||+0x7cc
                          DCD      ||.conststring||+0x7fc
                          DCD      ||.conststring||+0x834
                  __FUNCTION__
000098  636d5f62          DCB      0x63,0x6d,0x5f,0x62
00009c  61636b74          DCB      0x61,0x63,0x6b,0x74
0000a0  72616365          DCB      0x72,0x61,0x63,0x65
0000a4  5f617373          DCB      0x5f,0x61,0x73,0x73
0000a8  65727400          DCB      0x65,0x72,0x74,0x00
                  |symbol_number.43|
0000ac  636d5f62          DCB      0x63,0x6d,0x5f,0x62
0000b0  61636b74          DCB      0x61,0x63,0x6b,0x74
0000b4  72616365          DCB      0x72,0x61,0x63,0x65
0000b8  5f666175          DCB      0x5f,0x66,0x61,0x75
0000bc  6c740000          DCB      0x6c,0x74,0x00,0x00
                          DCD      ||.conststring||+0x85c
                          DCD      ||.conststring||+0x860
                          DCD      ||.conststring||+0x864
                          DCD      ||.conststring||+0x868
                          DCD      ||.conststring||+0x86c
                          DCD      ||.conststring||+0x870
                          DCD      ||.conststring||+0x874
                          DCD      ||.conststring||+0x878

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  4552524f          DCB      "ERROR: Unable to get the main stack information, please"
000004  523a2055
000008  6e61626c
00000c  6520746f
000010  20676574
000014  20746865
000018  206d6169
00001c  6e207374
000020  61636b20
000024  696e666f
000028  726d6174
00002c  696f6e2c
000030  20706c65
000034  617365  
000037  20636865          DCB      " check the configuration of the main stack",0
00003b  636b2074
00003f  68652063
000043  6f6e6669
000047  67757261
00004b  74696f6e
00004f  206f6620
000053  74686520
000057  6d61696e
00005b  20737461
00005f  636b00  
000062  00                DCB      0
000063  00                DCB      0
000064  4669726d          DCB      "Firmware name: %s, hardware version: %s, software versi"
000068  77617265
00006c  206e616d
000070  653a2025
000074  732c2068
000078  61726477
00007c  61726520
000080  76657273
000084  696f6e3a
000088  2025732c
00008c  20736f66
000090  74776172
000094  65207665
000098  727369  
00009b  6f6e3a20          DCB      "on: %s",0
00009f  257300  
0000a2  00                DCB      0
0000a3  00                DCB      0
0000a4  41737365          DCB      "Assert on thread %s",0
0000a8  7274206f
0000ac  6e207468
0000b0  72656164
0000b4  20257300
0000b8  41737365          DCB      "Assert on interrupt or bare metal(no OS) environment",0
0000bc  7274206f
0000c0  6e20696e
0000c4  74657272
0000c8  75707420
0000cc  6f722062
0000d0  61726520
0000d4  6d657461
0000d8  6c286e6f
0000dc  204f5329
0000e0  20656e76
0000e4  69726f6e
0000e8  6d656e74
0000ec  00      
0000ed  00                DCB      0
0000ee  00                DCB      0
0000ef  00                DCB      0
0000f0  3d3d3d3d          DCB      "===== Thread stack information =====",0
0000f4  3d205468
0000f8  72656164
0000fc  20737461
000100  636b2069
000104  6e666f72
000108  6d617469
00010c  6f6e203d
000110  3d3d3d3d
000114  00      
000115  00                DCB      0
000116  00                DCB      0
000117  00                DCB      0
000118  3d3d3d3d          DCB      "====== Main stack information ======",0
00011c  3d3d204d
000120  61696e20
000124  73746163
000128  6b20696e
00012c  666f726d
000130  6174696f
000134  6e203d3d
000138  3d3d3d3d
00013c  00      
00013d  00                DCB      0
00013e  00                DCB      0
00013f  00                DCB      0
000140  4572726f          DCB      "Error: Thread stack(%08x) was overflow",0
000144  723a2054
000148  68726561
00014c  64207374
000150  61636b28
000154  25303878
000158  29207761
00015c  73206f76
000160  6572666c
000164  6f7700  
000167  00                DCB      0
000168  4572726f          DCB      "Error: Main stack(%08x) was overflow",0
00016c  723a204d
000170  61696e20
000174  73746163
000178  6b282530
00017c  38782920
000180  77617320
000184  6f766572
000188  666c6f77
00018c  00      
00018d  00                DCB      0
00018e  00                DCB      0
00018f  00                DCB      0
000190  53686f77          DCB      "Show more call stack info by run: addr2line -e %s%s -a "
000194  206d6f72
000198  65206361
00019c  6c6c2073
0001a0  7461636b
0001a4  20696e66
0001a8  6f206279
0001ac  2072756e
0001b0  3a206164
0001b4  6472326c
0001b8  696e6520
0001bc  2d652025
0001c0  73257320
0001c4  2d6120  
0001c7  2d662025          DCB      "-f %.*s",0
0001cb  2e2a7300
0001cf  00                DCB      0
0001d0  44756d70          DCB      "Dump call stack has an error",0
0001d4  2063616c
0001d8  6c207374
0001dc  61636b20
0001e0  68617320
0001e4  616e2065
0001e8  72726f72
0001ec  00      
0001ed  00                DCB      0
0001ee  00                DCB      0
0001ef  00                DCB      0
0001f0  4661756c          DCB      "Fault on thread %s",0
0001f4  74206f6e
0001f8  20746872
0001fc  65616420
000200  257300  
000203  00                DCB      0
000204  4661756c          DCB      "Fault on interrupt or bare metal(no OS) environment",0
000208  74206f6e
00020c  20696e74
000210  65727275
000214  7074206f
000218  72206261
00021c  7265206d
000220  6574616c
000224  286e6f20
000228  4f532920
00022c  656e7669
000230  726f6e6d
000234  656e7400
000238  3d3d3d3d          DCB      "=================== Registers information ============="
00023c  3d3d3d3d
000240  3d3d3d3d
000244  3d3d3d3d
000248  3d3d3d20
00024c  52656769
000250  73746572
000254  7320696e
000258  666f726d
00025c  6174696f
000260  6e203d3d
000264  3d3d3d3d
000268  3d3d3d3d
00026c  3d3d3d  
00026f  3d3d3d3d          DCB      "=======",0
000273  3d3d3d00
000277  00                DCB      0
000278  48617264          DCB      "Hard fault is caused by failed vector fetch",0
00027c  20666175
000280  6c742069
000284  73206361
000288  75736564
00028c  20627920
000290  6661696c
000294  65642076
000298  6563746f
00029c  72206665
0002a0  74636800
0002a4  4d656d6f          DCB      "Memory management fault is caused by instruction access"
0002a8  7279206d
0002ac  616e6167
0002b0  656d656e
0002b4  74206661
0002b8  756c7420
0002bc  69732063
0002c0  61757365
0002c4  64206279
0002c8  20696e73
0002cc  74727563
0002d0  74696f6e
0002d4  20616363
0002d8  657373  
0002db  2076696f          DCB      " violation",0
0002df  6c617469
0002e3  6f6e00  
0002e6  00                DCB      0
0002e7  00                DCB      0
0002e8  4d656d6f          DCB      "Memory management fault is caused by data access violat"
0002ec  7279206d
0002f0  616e6167
0002f4  656d656e
0002f8  74206661
0002fc  756c7420
000300  69732063
000304  61757365
000308  64206279
00030c  20646174
000310  61206163
000314  63657373
000318  2076696f
00031c  6c6174  
00031f  696f6e00          DCB      "ion",0
000323  00                DCB      0
000324  4d656d6f          DCB      "Memory management fault is caused by unstacking error",0
000328  7279206d
00032c  616e6167
000330  656d656e
000334  74206661
000338  756c7420
00033c  69732063
000340  61757365
000344  64206279
000348  20756e73
00034c  7461636b
000350  696e6720
000354  6572726f
000358  7200    
00035a  00                DCB      0
00035b  00                DCB      0
00035c  4d656d6f          DCB      "Memory management fault is caused by stacking error",0
000360  7279206d
000364  616e6167
000368  656d656e
00036c  74206661
000370  756c7420
000374  69732063
000378  61757365
00037c  64206279
000380  20737461
000384  636b696e
000388  67206572
00038c  726f7200
000390  4d656d6f          DCB      "Memory management fault is caused by floating-point laz"
000394  7279206d
000398  616e6167
00039c  656d656e
0003a0  74206661
0003a4  756c7420
0003a8  69732063
0003ac  61757365
0003b0  64206279
0003b4  20666c6f
0003b8  6174696e
0003bc  672d706f
0003c0  696e7420
0003c4  6c617a  
0003c7  79207374          DCB      "y state preservation",0
0003cb  61746520
0003cf  70726573
0003d3  65727661
0003d7  74696f6e
0003db  00      
0003dc  42757320          DCB      "Bus fault is caused by instruction access violation",0
0003e0  6661756c
0003e4  74206973
0003e8  20636175
0003ec  73656420
0003f0  62792069
0003f4  6e737472
0003f8  75637469
0003fc  6f6e2061
000400  63636573
000404  73207669
000408  6f6c6174
00040c  696f6e00
000410  42757320          DCB      "Bus fault is caused by precise data access violation",0
000414  6661756c
000418  74206973
00041c  20636175
000420  73656420
000424  62792070
000428  72656369
00042c  73652064
000430  61746120
000434  61636365
000438  73732076
00043c  696f6c61
000440  74696f6e
000444  00      
000445  00                DCB      0
000446  00                DCB      0
000447  00                DCB      0
000448  42757320          DCB      "Bus fault is caused by imprecise data access violation",0
00044c  6661756c
000450  74206973
000454  20636175
000458  73656420
00045c  62792069
000460  6d707265
000464  63697365
000468  20646174
00046c  61206163
000470  63657373
000474  2076696f
000478  6c617469
00047c  6f6e00  
00047f  00                DCB      0
000480  42757320          DCB      "Bus fault is caused by unstacking error",0
000484  6661756c
000488  74206973
00048c  20636175
000490  73656420
000494  62792075
000498  6e737461
00049c  636b696e
0004a0  67206572
0004a4  726f7200
0004a8  42757320          DCB      "Bus fault is caused by stacking error",0
0004ac  6661756c
0004b0  74206973
0004b4  20636175
0004b8  73656420
0004bc  62792073
0004c0  7461636b
0004c4  696e6720
0004c8  6572726f
0004cc  7200    
0004ce  00                DCB      0
0004cf  00                DCB      0
0004d0  42757320          DCB      "Bus fault is caused by floating-point lazy state preser"
0004d4  6661756c
0004d8  74206973
0004dc  20636175
0004e0  73656420
0004e4  62792066
0004e8  6c6f6174
0004ec  696e672d
0004f0  706f696e
0004f4  74206c61
0004f8  7a792073
0004fc  74617465
000500  20707265
000504  736572  
000507  76617469          DCB      "vation",0
00050b  6f6e00  
00050e  00                DCB      0
00050f  00                DCB      0
000510  55736167          DCB      "Usage fault is caused by attempts to execute an undefin"
000514  65206661
000518  756c7420
00051c  69732063
000520  61757365
000524  64206279
000528  20617474
00052c  656d7074
000530  7320746f
000534  20657865
000538  63757465
00053c  20616e20
000540  756e6465
000544  66696e  
000547  65642069          DCB      "ed instruction",0
00054b  6e737472
00054f  75637469
000553  6f6e00  
000556  00                DCB      0
000557  00                DCB      0
000558  55736167          DCB      "Usage fault is caused by attempts to switch to an inval"
00055c  65206661
000560  756c7420
000564  69732063
000568  61757365
00056c  64206279
000570  20617474
000574  656d7074
000578  7320746f
00057c  20737769
000580  74636820
000584  746f2061
000588  6e20696e
00058c  76616c  
00058f  69642073          DCB      "id state (e.g., ARM)",0
000593  74617465
000597  2028652e
00059b  672e2c20
00059f  41524d29
0005a3  00      
0005a4  55736167          DCB      "Usage fault is caused by attempts to do an exception wi"
0005a8  65206661
0005ac  756c7420
0005b0  69732063
0005b4  61757365
0005b8  64206279
0005bc  20617474
0005c0  656d7074
0005c4  7320746f
0005c8  20646f20
0005cc  616e2065
0005d0  78636570
0005d4  74696f6e
0005d8  207769  
0005db  74682061          DCB      "th a bad value in the EXC_RETURN number",0
0005df  20626164
0005e3  2076616c
0005e7  75652069
0005eb  6e207468
0005ef  65204558
0005f3  435f5245
0005f7  5455524e
0005fb  206e756d
0005ff  62657200
000603  00                DCB      0
000604  55736167          DCB      "Usage fault is caused by attempts to execute a coproces"
000608  65206661
00060c  756c7420
000610  69732063
000614  61757365
000618  64206279
00061c  20617474
000620  656d7074
000624  7320746f
000628  20657865
00062c  63757465
000630  20612063
000634  6f70726f
000638  636573  
00063b  736f7220          DCB      "sor instruction",0
00063f  696e7374
000643  72756374
000647  696f6e00
00064b  00                DCB      0
00064c  55736167          DCB      "Usage fault is caused by indicates that an unaligned ac"
000650  65206661
000654  756c7420
000658  69732063
00065c  61757365
000660  64206279
000664  20696e64
000668  69636174
00066c  65732074
000670  68617420
000674  616e2075
000678  6e616c69
00067c  676e6564
000680  206163  
000683  63657373          DCB      "cess fault has taken place",0
000687  20666175
00068b  6c742068
00068f  61732074
000693  616b656e
000697  20706c61
00069b  636500  
00069e  00                DCB      0
00069f  00                DCB      0
0006a0  55736167          DCB      "Usage fault is caused by Indicates a divide by zero has"
0006a4  65206661
0006a8  756c7420
0006ac  69732063
0006b0  61757365
0006b4  64206279
0006b8  20496e64
0006bc  69636174
0006c0  65732061
0006c4  20646976
0006c8  69646520
0006cc  6279207a
0006d0  65726f20
0006d4  686173  
0006d7  2074616b          DCB      " taken place (can be set only if DIV_0_TRP is set)",0
0006db  656e2070
0006df  6c616365
0006e3  20286361
0006e7  6e206265
0006eb  20736574
0006ef  206f6e6c
0006f3  79206966
0006f7  20444956
0006fb  5f305f54
0006ff  52502069
000703  73207365
000707  742900  
00070a  00                DCB      0
00070b  00                DCB      0
00070c  44656275          DCB      "Debug fault is caused by halt requested in NVIC",0
000710  67206661
000714  756c7420
000718  69732063
00071c  61757365
000720  64206279
000724  2068616c
000728  74207265
00072c  71756573
000730  74656420
000734  696e204e
000738  56494300
00073c  44656275          DCB      "Debug fault is caused by BKPT instruction executed",0
000740  67206661
000744  756c7420
000748  69732063
00074c  61757365
000750  64206279
000754  20424b50
000758  5420696e
00075c  73747275
000760  6374696f
000764  6e206578
000768  65637574
00076c  656400  
00076f  00                DCB      0
000770  44656275          DCB      "Debug fault is caused by DWT match occurred",0
000774  67206661
000778  756c7420
00077c  69732063
000780  61757365
000784  64206279
000788  20445754
00078c  206d6174
000790  6368206f
000794  63637572
000798  72656400
00079c  44656275          DCB      "Debug fault is caused by Vector fetch occurred",0
0007a0  67206661
0007a4  756c7420
0007a8  69732063
0007ac  61757365
0007b0  64206279
0007b4  20566563
0007b8  746f7220
0007bc  66657463
0007c0  68206f63
0007c4  63757272
0007c8  656400  
0007cb  00                DCB      0
0007cc  44656275          DCB      "Debug fault is caused by EDBGRQ signal asserted",0
0007d0  67206661
0007d4  756c7420
0007d8  69732063
0007dc  61757365
0007e0  64206279
0007e4  20454442
0007e8  47525120
0007ec  7369676e
0007f0  616c2061
0007f4  73736572
0007f8  74656400
0007fc  54686520          DCB      "The memory management fault occurred address is %08x",0
000800  6d656d6f
000804  7279206d
000808  616e6167
00080c  656d656e
000810  74206661
000814  756c7420
000818  6f636375
00081c  72726564
000820  20616464
000824  72657373
000828  20697320
00082c  25303878
000830  00      
000831  00                DCB      0
000832  00                DCB      0
000833  00                DCB      0
000834  54686520          DCB      "The bus fault occurred address is %08x",0
000838  62757320
00083c  6661756c
000840  74206f63
000844  63757272
000848  65642061
00084c  64647265
000850  73732069
000854  73202530
000858  387800  
00085b  00                DCB      0
00085c  52302000          DCB      "R0 ",0
000860  52312000          DCB      "R1 ",0
000864  52322000          DCB      "R2 ",0
000868  52332000          DCB      "R3 ",0
00086c  52313200          DCB      "R12",0
000870  4c522000          DCB      "LR ",0
000874  50432000          DCB      "PC ",0
000878  50535200          DCB      "PSR",0

                          AREA ||.data||, DATA, ALIGN=2

                  main_stack_start_addr
                          DCD      0x00000000
                  main_stack_size
                          DCD      0x00000000
                  code_start_addr
                          DCD      0x00000000
                  code_size
                          DCD      0x00000000
                  init_ok
000010  00                DCB      0x00
                  on_fault
000011  00                DCB      0x00
                  stack_is_overflow
000012  00                DCB      0x00
                  statck_has_fpu_regs
000013  00                DCB      0x00
                  on_thread_before_fault
000014  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\cm_backtrace\\cm_backtrace.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___14_cm_backtrace_c_13c737ea__cmb_get_msp|
#line 346 "..\\..\\User\\cm_backtrace\\cmb_def.h"
|__asm___14_cm_backtrace_c_13c737ea__cmb_get_msp| PROC
#line 346

 mrs r0, msp
 bx lr
  
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___14_cm_backtrace_c_13c737ea__cmb_get_psp|
#line 350
|__asm___14_cm_backtrace_c_13c737ea__cmb_get_psp| PROC
#line 350

 mrs r0, psp
 bx lr
  
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___14_cm_backtrace_c_13c737ea__cmb_get_sp|
#line 354
|__asm___14_cm_backtrace_c_13c737ea__cmb_get_sp| PROC
#line 354

 mov r0, sp
 bx lr
  
	ENDP

;*** End   embedded assembler ***
