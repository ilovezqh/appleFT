; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\flash\obj\usb_core.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\usb_core.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\User -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\User\FatFS\src -I..\..\Libraries\STM32_USB_Device_Library\Class\msc\inc -I..\..\Libraries\STM32_USB_Device_Library\Core\inc -I..\..\Libraries\STM32_USB_OTG_Driver\inc -I..\..\User\usbd_mass_storage -I..\..\User\ft_support -I..\..\User\test -I..\..\User\emenu -I..\..\User\chip_ft -I..\..\User\lwrb -I..\..\User\easylogger\inc -I..\..\User\easylogger\plugins\file -I..\..\User\LOG -I..\..\User\MultiButton-1.1.0 -I..\..\User\cm_backtrace -I..\..\User\MultiTimer -I.\RTE\_Flash -IC:\Users\qizha\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\qizha\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.17.1\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F407xx -D_RTE_ -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY --signed_chars --omf_browse=.\flash\obj\usb_core.crf ..\..\Libraries\STM32_USB_OTG_Driver\src\usb_core.c]
                          THUMB

                          AREA ||i.USB_OTG_ActiveRemoteWakeup||, CODE, READONLY, ALIGN=1

                  USB_OTG_ActiveRemoteWakeup PROC
;;;1948   */
;;;1949   void USB_OTG_ActiveRemoteWakeup(USB_OTG_CORE_HANDLE *pdev)
000000  b53e              PUSH     {r1-r5,lr}
;;;1950   {
000002  4604              MOV      r4,r0
;;;1951     
;;;1952     USB_OTG_DCTL_TypeDef     dctl;
;;;1953     USB_OTG_DSTS_TypeDef     dsts;
;;;1954     USB_OTG_PCGCCTL_TypeDef  power;  
;;;1955     
;;;1956     if (pdev->dev.DevRemoteWakeup) 
000004  f44f708c          MOV      r0,#0x118
000008  5900              LDR      r0,[r0,r4]
00000a  b368              CBZ      r0,|L1.104|
;;;1957     {
;;;1958       dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
00000c  6920              LDR      r0,[r4,#0x10]
00000e  6880              LDR      r0,[r0,#8]
000010  9001              STR      r0,[sp,#4]
;;;1959       if(dsts.b.suspsts == 1)
000012  9801              LDR      r0,[sp,#4]
000014  f0000001          AND      r0,r0,#1
000018  b330              CBZ      r0,|L1.104|
;;;1960       {
;;;1961         if(pdev->cfg.low_power)
00001a  7aa0              LDRB     r0,[r4,#0xa]
00001c  b170              CBZ      r0,|L1.60|
;;;1962         {
;;;1963           /* un-gate USB Core clock */
;;;1964           power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
00001e  f8d4010c          LDR      r0,[r4,#0x10c]
000022  9000              STR      r0,[sp,#0]
;;;1965           power.b.gatehclk = 0;
000024  9800              LDR      r0,[sp,#0]
000026  f0200002          BIC      r0,r0,#2
00002a  9000              STR      r0,[sp,#0]
;;;1966           power.b.stoppclk = 0;
00002c  9800              LDR      r0,[sp,#0]
00002e  f0200001          BIC      r0,r0,#1
000032  9000              STR      r0,[sp,#0]
;;;1967           USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
000034  9900              LDR      r1,[sp,#0]
000036  f8d4010c          LDR      r0,[r4,#0x10c]
00003a  6001              STR      r1,[r0,#0]
                  |L1.60|
;;;1968         }   
;;;1969         /* active Remote wakeup signaling */
;;;1970         dctl.d32 = 0;
00003c  2000              MOVS     r0,#0
00003e  9002              STR      r0,[sp,#8]
;;;1971         dctl.b.rmtwkupsig = 1;
000040  9802              LDR      r0,[sp,#8]
000042  f0200001          BIC      r0,r0,#1
000046  1c40              ADDS     r0,r0,#1
000048  9002              STR      r0,[sp,#8]
;;;1972         USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, 0, dctl.d32);
00004a  6920              LDR      r0,[r4,#0x10]
00004c  6840              LDR      r0,[r0,#4]
00004e  9902              LDR      r1,[sp,#8]
000050  4308              ORRS     r0,r0,r1
000052  6921              LDR      r1,[r4,#0x10]
000054  6048              STR      r0,[r1,#4]
;;;1973         USB_OTG_BSP_mDelay(5);
000056  2005              MOVS     r0,#5
000058  f7fffffe          BL       USB_OTG_BSP_mDelay
;;;1974         USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, 0 );
00005c  6920              LDR      r0,[r4,#0x10]
00005e  6840              LDR      r0,[r0,#4]
000060  9902              LDR      r1,[sp,#8]
000062  4388              BICS     r0,r0,r1
000064  6921              LDR      r1,[r4,#0x10]
000066  6048              STR      r0,[r1,#4]
                  |L1.104|
;;;1975       }
;;;1976     }
;;;1977   }
000068  bd3e              POP      {r1-r5,pc}
;;;1978   
                          ENDP


                          AREA ||i.USB_OTG_CoreInit||, CODE, READONLY, ALIGN=1

                  USB_OTG_CoreInit PROC
;;;322    */
;;;323    USB_OTG_STS USB_OTG_CoreInit(USB_OTG_CORE_HANDLE *pdev)
000000  b53e              PUSH     {r1-r5,lr}
;;;324    {
000002  4604              MOV      r4,r0
;;;325      USB_OTG_STS status = USB_OTG_OK;
000004  2500              MOVS     r5,#0
;;;326      USB_OTG_GUSBCFG_TypeDef  usbcfg;
;;;327      USB_OTG_GCCFG_TypeDef    gccfg;
;;;328      USB_OTG_GAHBCFG_TypeDef  ahbcfg;
;;;329      
;;;330      usbcfg.d32 = 0;
000006  2000              MOVS     r0,#0
000008  9002              STR      r0,[sp,#8]
;;;331      gccfg.d32 = 0;
00000a  9001              STR      r0,[sp,#4]
;;;332      ahbcfg.d32 = 0;
00000c  9000              STR      r0,[sp,#0]
;;;333      
;;;334      
;;;335      
;;;336      if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
00000e  7a20              LDRB     r0,[r4,#8]
000010  2801              CMP      r0,#1
000012  d13d              BNE      |L2.144|
;;;337      {
;;;338        gccfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GCCFG);
000014  68e0              LDR      r0,[r4,#0xc]
000016  6b80              LDR      r0,[r0,#0x38]
000018  9001              STR      r0,[sp,#4]
;;;339        gccfg.b.pwdn = 0;
00001a  9801              LDR      r0,[sp,#4]
00001c  f4203080          BIC      r0,r0,#0x10000
000020  9001              STR      r0,[sp,#4]
;;;340        
;;;341        if (pdev->cfg.Sof_output)
000022  7a60              LDRB     r0,[r4,#9]
000024  b128              CBZ      r0,|L2.50|
;;;342        {
;;;343          gccfg.b.sofouten = 1;   
000026  9801              LDR      r0,[sp,#4]
000028  f4201080          BIC      r0,r0,#0x100000
00002c  f5001080          ADD      r0,r0,#0x100000
000030  9001              STR      r0,[sp,#4]
                  |L2.50|
;;;344        }
;;;345        USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
000032  9801              LDR      r0,[sp,#4]
000034  68e1              LDR      r1,[r4,#0xc]
000036  6388              STR      r0,[r1,#0x38]
;;;346        
;;;347        /* Init The ULPI Interface */
;;;348        usbcfg.d32 = 0;
000038  2000              MOVS     r0,#0
00003a  9002              STR      r0,[sp,#8]
;;;349        usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
00003c  68e0              LDR      r0,[r4,#0xc]
00003e  68c0              LDR      r0,[r0,#0xc]
000040  9002              STR      r0,[sp,#8]
;;;350        
;;;351        usbcfg.b.physel            = 0; /* HS Interface */
000042  9802              LDR      r0,[sp,#8]
000044  f0200040          BIC      r0,r0,#0x40
000048  9002              STR      r0,[sp,#8]
;;;352    #ifdef USB_OTG_INTERNAL_VBUS_ENABLED
;;;353        usbcfg.b.ulpi_ext_vbus_drv = 0; /* Use internal VBUS */
;;;354    #else
;;;355    #ifdef USB_OTG_EXTERNAL_VBUS_ENABLED    
;;;356        usbcfg.b.ulpi_ext_vbus_drv = 1; /* Use external VBUS */
;;;357    #endif
;;;358    #endif 
;;;359        usbcfg.b.term_sel_dl_pulse = 0; /* Data line pulsing using utmi_txvalid */    
00004a  9802              LDR      r0,[sp,#8]
00004c  f4200080          BIC      r0,r0,#0x400000
000050  9002              STR      r0,[sp,#8]
;;;360        
;;;361        usbcfg.b.ulpi_fsls = 0;
000052  9802              LDR      r0,[sp,#8]
000054  f4203000          BIC      r0,r0,#0x20000
000058  9002              STR      r0,[sp,#8]
;;;362        usbcfg.b.ulpi_clk_sus_m = 0;
00005a  9802              LDR      r0,[sp,#8]
00005c  f4202000          BIC      r0,r0,#0x80000
000060  9002              STR      r0,[sp,#8]
;;;363        USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
000062  9802              LDR      r0,[sp,#8]
000064  68e1              LDR      r1,[r4,#0xc]
000066  60c8              STR      r0,[r1,#0xc]
;;;364        
;;;365        /* Reset after a PHY select  */
;;;366        USB_OTG_CoreReset(pdev);
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       USB_OTG_CoreReset
;;;367        
;;;368        if(pdev->cfg.dma_enable == 1)
00006e  78e0              LDRB     r0,[r4,#3]
000070  2801              CMP      r0,#1
000072  d143              BNE      |L2.252|
;;;369        {
;;;370          
;;;371          ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
000074  9800              LDR      r0,[sp,#0]
000076  f020001e          BIC      r0,r0,#0x1e
00007a  300a              ADDS     r0,r0,#0xa
00007c  9000              STR      r0,[sp,#0]
;;;372          ahbcfg.b.dmaenable = 1;
00007e  9800              LDR      r0,[sp,#0]
000080  f0200020          BIC      r0,r0,#0x20
000084  3020              ADDS     r0,r0,#0x20
000086  9000              STR      r0,[sp,#0]
;;;373          USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
000088  9800              LDR      r0,[sp,#0]
00008a  68e1              LDR      r1,[r4,#0xc]
00008c  6088              STR      r0,[r1,#8]
00008e  e035              B        |L2.252|
                  |L2.144|
;;;374          
;;;375        }    
;;;376      }
;;;377      else /* FS interface (embedded Phy) */
;;;378      {
;;;379        
;;;380        usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);;
000090  68e0              LDR      r0,[r4,#0xc]
000092  68c0              LDR      r0,[r0,#0xc]
000094  9002              STR      r0,[sp,#8]
;;;381        usbcfg.b.physel  = 1; /* FS Interface */
000096  9802              LDR      r0,[sp,#8]
000098  f0200040          BIC      r0,r0,#0x40
00009c  3040              ADDS     r0,r0,#0x40
00009e  9002              STR      r0,[sp,#8]
;;;382        USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
0000a0  9802              LDR      r0,[sp,#8]
0000a2  68e1              LDR      r1,[r4,#0xc]
0000a4  60c8              STR      r0,[r1,#0xc]
;;;383        /* Reset after a PHY select and set Host mode */
;;;384        USB_OTG_CoreReset(pdev);
0000a6  4620              MOV      r0,r4
0000a8  f7fffffe          BL       USB_OTG_CoreReset
;;;385        /* Deactivate the power down*/
;;;386        gccfg.d32 = 0;
0000ac  2000              MOVS     r0,#0
0000ae  9001              STR      r0,[sp,#4]
;;;387        gccfg.b.pwdn = 1;
0000b0  9801              LDR      r0,[sp,#4]
0000b2  f4203080          BIC      r0,r0,#0x10000
0000b6  f5003080          ADD      r0,r0,#0x10000
0000ba  9001              STR      r0,[sp,#4]
;;;388        
;;;389        gccfg.b.vbussensingA = 1 ;
0000bc  9801              LDR      r0,[sp,#4]
0000be  f4202080          BIC      r0,r0,#0x40000
0000c2  f5002080          ADD      r0,r0,#0x40000
0000c6  9001              STR      r0,[sp,#4]
;;;390        gccfg.b.vbussensingB = 1 ;     
0000c8  9801              LDR      r0,[sp,#4]
0000ca  f4202000          BIC      r0,r0,#0x80000
0000ce  f5002000          ADD      r0,r0,#0x80000
0000d2  9001              STR      r0,[sp,#4]
;;;391    #ifndef VBUS_SENSING_ENABLED
;;;392        gccfg.b.disablevbussensing = 1; 
0000d4  9801              LDR      r0,[sp,#4]
0000d6  f4201000          BIC      r0,r0,#0x200000
0000da  f5001000          ADD      r0,r0,#0x200000
0000de  9001              STR      r0,[sp,#4]
;;;393    #endif    
;;;394        
;;;395        if(pdev->cfg.Sof_output)
0000e0  7a60              LDRB     r0,[r4,#9]
0000e2  b128              CBZ      r0,|L2.240|
;;;396        {
;;;397          gccfg.b.sofouten = 1;  
0000e4  9801              LDR      r0,[sp,#4]
0000e6  f4201080          BIC      r0,r0,#0x100000
0000ea  f5001080          ADD      r0,r0,#0x100000
0000ee  9001              STR      r0,[sp,#4]
                  |L2.240|
;;;398        }
;;;399        
;;;400        USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
0000f0  9801              LDR      r0,[sp,#4]
0000f2  68e1              LDR      r1,[r4,#0xc]
0000f4  6388              STR      r0,[r1,#0x38]
;;;401        USB_OTG_BSP_mDelay(20);
0000f6  2014              MOVS     r0,#0x14
0000f8  f7fffffe          BL       USB_OTG_BSP_mDelay
                  |L2.252|
;;;402      }
;;;403      /* case the HS core is working in FS mode */
;;;404      if(pdev->cfg.dma_enable == 1)
0000fc  78e0              LDRB     r0,[r4,#3]
0000fe  2801              CMP      r0,#1
000100  d10f              BNE      |L2.290|
;;;405      {
;;;406        
;;;407        ahbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GAHBCFG);
000102  68e0              LDR      r0,[r4,#0xc]
000104  6880              LDR      r0,[r0,#8]
000106  9000              STR      r0,[sp,#0]
;;;408        ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
000108  9800              LDR      r0,[sp,#0]
00010a  f020001e          BIC      r0,r0,#0x1e
00010e  300a              ADDS     r0,r0,#0xa
000110  9000              STR      r0,[sp,#0]
;;;409        ahbcfg.b.dmaenable = 1;
000112  9800              LDR      r0,[sp,#0]
000114  f0200020          BIC      r0,r0,#0x20
000118  3020              ADDS     r0,r0,#0x20
00011a  9000              STR      r0,[sp,#0]
;;;410        USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
00011c  9800              LDR      r0,[sp,#0]
00011e  68e1              LDR      r1,[r4,#0xc]
000120  6088              STR      r0,[r1,#8]
                  |L2.290|
;;;411        
;;;412      }
;;;413      /* initialize OTG features */
;;;414    #ifdef  USE_OTG_MODE
;;;415      usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
;;;416      usbcfg.b.hnpcap = 1;
;;;417      usbcfg.b.srpcap = 1;
;;;418      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
;;;419      USB_OTG_EnableCommonInt(pdev);
;;;420    #endif
;;;421      return status;
000122  4628              MOV      r0,r5
;;;422    }
000124  bd3e              POP      {r1-r5,pc}
;;;423    /**
                          ENDP


                          AREA ||i.USB_OTG_CoreInitDev||, CODE, READONLY, ALIGN=1

                  USB_OTG_CoreInitDev PROC
;;;1193   */
;;;1194   USB_OTG_STS USB_OTG_CoreInitDev (USB_OTG_CORE_HANDLE *pdev)
000000  b570              PUSH     {r4-r6,lr}
;;;1195   {
000002  b088              SUB      sp,sp,#0x20
000004  4604              MOV      r4,r0
;;;1196     USB_OTG_STS             status       = USB_OTG_OK;
000006  2600              MOVS     r6,#0
;;;1197     USB_OTG_DEPCTL_TypeDef  depctl;
;;;1198     uint32_t i;
;;;1199     USB_OTG_DCFG_TypeDef    dcfg;
;;;1200     USB_OTG_FSIZ_TypeDef    nptxfifosize;
;;;1201     USB_OTG_FSIZ_TypeDef    txfifosize;
;;;1202     USB_OTG_DIEPMSK_TypeDef msk;
;;;1203     USB_OTG_DTHRCTL_TypeDef dthrctl;  
;;;1204     
;;;1205     depctl.d32 = 0;
000008  2000              MOVS     r0,#0
00000a  9007              STR      r0,[sp,#0x1c]
;;;1206     dcfg.d32 = 0;
00000c  9006              STR      r0,[sp,#0x18]
;;;1207     nptxfifosize.d32 = 0;
00000e  9005              STR      r0,[sp,#0x14]
;;;1208     txfifosize.d32 = 0;
000010  9004              STR      r0,[sp,#0x10]
;;;1209     msk.d32 = 0;
000012  9003              STR      r0,[sp,#0xc]
;;;1210     
;;;1211     /* Restart the Phy Clock */
;;;1212     USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, 0);
000014  2100              MOVS     r1,#0
000016  f8d4010c          LDR      r0,[r4,#0x10c]
00001a  6001              STR      r1,[r0,#0]
;;;1213     /* Device configuration register */
;;;1214     dcfg.d32 = USB_OTG_READ_REG32( &pdev->regs.DREGS->DCFG);
00001c  6920              LDR      r0,[r4,#0x10]
00001e  6800              LDR      r0,[r0,#0]
000020  9006              STR      r0,[sp,#0x18]
;;;1215     dcfg.b.perfrint = DCFG_FRAME_INTERVAL_80;
000022  9806              LDR      r0,[sp,#0x18]
000024  f42050c0          BIC      r0,r0,#0x1800
000028  9006              STR      r0,[sp,#0x18]
;;;1216     USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DCFG, dcfg.d32 );
00002a  9906              LDR      r1,[sp,#0x18]
00002c  6920              LDR      r0,[r4,#0x10]
00002e  6001              STR      r1,[r0,#0]
;;;1217     
;;;1218   #ifdef USB_OTG_FS_CORE
;;;1219     if(pdev->cfg.coreID == USB_OTG_FS_CORE_ID  )
000030  7ae0              LDRB     r0,[r4,#0xb]
000032  2801              CMP      r0,#1
000034  d13d              BNE      |L3.178|
;;;1220     {  
;;;1221       
;;;1222       /* Set Full speed phy */
;;;1223       USB_OTG_InitDevSpeed (pdev , USB_OTG_SPEED_PARAM_FULL);
000036  2103              MOVS     r1,#3
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       USB_OTG_InitDevSpeed
;;;1224       
;;;1225       /* set Rx FIFO size */
;;;1226       USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
00003e  2080              MOVS     r0,#0x80
000040  68e1              LDR      r1,[r4,#0xc]
000042  6248              STR      r0,[r1,#0x24]
;;;1227       
;;;1228       /* EP0 TX*/
;;;1229       nptxfifosize.b.depth     = TX0_FIFO_FS_SIZE;
000044  9805              LDR      r0,[sp,#0x14]
000046  b280              UXTH     r0,r0
000048  f5000080          ADD      r0,r0,#0x400000
00004c  9005              STR      r0,[sp,#0x14]
;;;1230       nptxfifosize.b.startaddr = RX_FIFO_FS_SIZE;
00004e  9805              LDR      r0,[sp,#0x14]
000050  f36f000f          BFC      r0,#0,#16
000054  3080              ADDS     r0,r0,#0x80
000056  9005              STR      r0,[sp,#0x14]
;;;1231       USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32 );
000058  9805              LDR      r0,[sp,#0x14]
00005a  68e1              LDR      r1,[r4,#0xc]
00005c  6288              STR      r0,[r1,#0x28]
;;;1232       
;;;1233       
;;;1234       /* EP1 TX*/
;;;1235       txfifosize.b.startaddr = nptxfifosize.b.startaddr + nptxfifosize.b.depth;
00005e  9805              LDR      r0,[sp,#0x14]
000060  eb004110          ADD      r1,r0,r0,LSR #16
000064  9804              LDR      r0,[sp,#0x10]
000066  f361000f          BFI      r0,r1,#0,#16
00006a  9004              STR      r0,[sp,#0x10]
;;;1236       txfifosize.b.depth = TX1_FIFO_FS_SIZE;
00006c  9804              LDR      r0,[sp,#0x10]
00006e  b280              UXTH     r0,r0
000070  f5000000          ADD      r0,r0,#0x800000
000074  9004              STR      r0,[sp,#0x10]
;;;1237       USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[0], txfifosize.d32 );
000076  9804              LDR      r0,[sp,#0x10]
000078  68e1              LDR      r1,[r4,#0xc]
00007a  f8c10104          STR      r0,[r1,#0x104]
;;;1238       
;;;1239       
;;;1240       /* EP2 TX*/
;;;1241       txfifosize.b.startaddr += txfifosize.b.depth;
00007e  9804              LDR      r0,[sp,#0x10]
000080  eb004110          ADD      r1,r0,r0,LSR #16
000084  f361000f          BFI      r0,r1,#0,#16
000088  9004              STR      r0,[sp,#0x10]
;;;1242       txfifosize.b.depth = TX2_FIFO_FS_SIZE;
00008a  9804              LDR      r0,[sp,#0x10]
00008c  b280              UXTH     r0,r0
00008e  9004              STR      r0,[sp,#0x10]
;;;1243       USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[1], txfifosize.d32 );
000090  9904              LDR      r1,[sp,#0x10]
000092  68e0              LDR      r0,[r4,#0xc]
000094  f8c01108          STR      r1,[r0,#0x108]
;;;1244       
;;;1245       
;;;1246       /* EP3 TX*/  
;;;1247       txfifosize.b.startaddr += txfifosize.b.depth;
000098  9804              LDR      r0,[sp,#0x10]
00009a  eb004110          ADD      r1,r0,r0,LSR #16
00009e  f361000f          BFI      r0,r1,#0,#16
0000a2  9004              STR      r0,[sp,#0x10]
;;;1248       txfifosize.b.depth = TX3_FIFO_FS_SIZE;
0000a4  9804              LDR      r0,[sp,#0x10]
0000a6  b280              UXTH     r0,r0
0000a8  9004              STR      r0,[sp,#0x10]
;;;1249       USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[2], txfifosize.d32 );
0000aa  9904              LDR      r1,[sp,#0x10]
0000ac  68e0              LDR      r0,[r4,#0xc]
0000ae  f8c0110c          STR      r1,[r0,#0x10c]
                  |L3.178|
;;;1250     }
;;;1251   #endif
;;;1252   #ifdef USB_OTG_HS_CORE
;;;1253     if(pdev->cfg.coreID == USB_OTG_HS_CORE_ID  )
;;;1254     {
;;;1255       
;;;1256       /* Set High speed phy */
;;;1257       
;;;1258       if(pdev->cfg.phy_itface  == USB_OTG_ULPI_PHY)
;;;1259       {
;;;1260         USB_OTG_InitDevSpeed (pdev , USB_OTG_SPEED_PARAM_HIGH);
;;;1261       }
;;;1262       else /* set High speed phy in Full speed mode */
;;;1263       {
;;;1264         USB_OTG_InitDevSpeed (pdev , USB_OTG_SPEED_PARAM_HIGH_IN_FULL);
;;;1265       }
;;;1266       
;;;1267       /* set Rx FIFO size */
;;;1268       USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_HS_SIZE);
;;;1269       
;;;1270       /* EP0 TX*/
;;;1271       nptxfifosize.b.depth     = TX0_FIFO_HS_SIZE;
;;;1272       nptxfifosize.b.startaddr = RX_FIFO_HS_SIZE;
;;;1273       USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32 );
;;;1274       
;;;1275       
;;;1276       /* EP1 TX*/
;;;1277       txfifosize.b.startaddr = nptxfifosize.b.startaddr + nptxfifosize.b.depth;
;;;1278       txfifosize.b.depth = TX1_FIFO_HS_SIZE;
;;;1279       USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[0], txfifosize.d32 );
;;;1280       
;;;1281       
;;;1282       /* EP2 TX*/
;;;1283       txfifosize.b.startaddr += txfifosize.b.depth;
;;;1284       txfifosize.b.depth = TX2_FIFO_HS_SIZE;
;;;1285       USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[1], txfifosize.d32 );
;;;1286       
;;;1287       
;;;1288       /* EP3 TX*/  
;;;1289       txfifosize.b.startaddr += txfifosize.b.depth;
;;;1290       txfifosize.b.depth = TX3_FIFO_HS_SIZE;
;;;1291       USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[2], txfifosize.d32 );
;;;1292       
;;;1293       /* EP4 TX*/
;;;1294       txfifosize.b.startaddr += txfifosize.b.depth;
;;;1295       txfifosize.b.depth = TX4_FIFO_HS_SIZE;
;;;1296       USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[3], txfifosize.d32 );
;;;1297       
;;;1298       
;;;1299       /* EP5 TX*/  
;;;1300       txfifosize.b.startaddr += txfifosize.b.depth;
;;;1301       txfifosize.b.depth = TX5_FIFO_HS_SIZE;
;;;1302       USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[4], txfifosize.d32 );
;;;1303     }
;;;1304   #endif  
;;;1305     /* Flush the FIFOs */
;;;1306     USB_OTG_FlushTxFifo(pdev , 0x10); /* all Tx FIFOs */
0000b2  2110              MOVS     r1,#0x10
0000b4  4620              MOV      r0,r4
0000b6  f7fffffe          BL       USB_OTG_FlushTxFifo
;;;1307     USB_OTG_FlushRxFifo(pdev);
0000ba  4620              MOV      r0,r4
0000bc  f7fffffe          BL       USB_OTG_FlushRxFifo
;;;1308     /* Clear all pending Device Interrupts */
;;;1309     USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
0000c0  2100              MOVS     r1,#0
0000c2  6920              LDR      r0,[r4,#0x10]
0000c4  6101              STR      r1,[r0,#0x10]
;;;1310     USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
0000c6  6920              LDR      r0,[r4,#0x10]
0000c8  6141              STR      r1,[r0,#0x14]
;;;1311     USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
0000ca  1e49              SUBS     r1,r1,#1
0000cc  6920              LDR      r0,[r4,#0x10]
0000ce  6181              STR      r1,[r0,#0x18]
;;;1312     USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
0000d0  2100              MOVS     r1,#0
0000d2  6920              LDR      r0,[r4,#0x10]
0000d4  61c1              STR      r1,[r0,#0x1c]
;;;1313     
;;;1314     for (i = 0; i < pdev->cfg.dev_endpoints; i++)
0000d6  2500              MOVS     r5,#0
0000d8  e02c              B        |L3.308|
                  |L3.218|
;;;1315     {
;;;1316       depctl.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[i]->DIEPCTL);
0000da  f1040018          ADD      r0,r4,#0x18
0000de  f8500025          LDR      r0,[r0,r5,LSL #2]
0000e2  6800              LDR      r0,[r0,#0]
0000e4  9007              STR      r0,[sp,#0x1c]
;;;1317       if (depctl.b.epena)
0000e6  9807              LDR      r0,[sp,#0x1c]
0000e8  0fc0              LSRS     r0,r0,#31
0000ea  b170              CBZ      r0,|L3.266|
;;;1318       {
;;;1319         depctl.d32 = 0;
0000ec  2000              MOVS     r0,#0
0000ee  9007              STR      r0,[sp,#0x1c]
;;;1320         depctl.b.epdis = 1;
0000f0  9807              LDR      r0,[sp,#0x1c]
0000f2  f0204080          BIC      r0,r0,#0x40000000
0000f6  f1004080          ADD      r0,r0,#0x40000000
0000fa  9007              STR      r0,[sp,#0x1c]
;;;1321         depctl.b.snak = 1;
0000fc  9807              LDR      r0,[sp,#0x1c]
0000fe  f0206000          BIC      r0,r0,#0x8000000
000102  f1006000          ADD      r0,r0,#0x8000000
000106  9007              STR      r0,[sp,#0x1c]
000108  e001              B        |L3.270|
                  |L3.266|
;;;1322       }
;;;1323       else
;;;1324       {
;;;1325         depctl.d32 = 0;
00010a  2000              MOVS     r0,#0
00010c  9007              STR      r0,[sp,#0x1c]
                  |L3.270|
;;;1326       }
;;;1327       USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPCTL, depctl.d32);
00010e  f1040018          ADD      r0,r4,#0x18
000112  f8500025          LDR      r0,[r0,r5,LSL #2]
000116  9907              LDR      r1,[sp,#0x1c]
000118  6001              STR      r1,[r0,#0]
;;;1328       USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPTSIZ, 0);
00011a  2100              MOVS     r1,#0
00011c  f1040018          ADD      r0,r4,#0x18
000120  f8500025          LDR      r0,[r0,r5,LSL #2]
000124  6101              STR      r1,[r0,#0x10]
;;;1329       USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
000126  21ff              MOVS     r1,#0xff
000128  f1040018          ADD      r0,r4,#0x18
00012c  f8500025          LDR      r0,[r0,r5,LSL #2]
000130  6081              STR      r1,[r0,#8]
000132  1c6d              ADDS     r5,r5,#1              ;1314
                  |L3.308|
000134  7860              LDRB     r0,[r4,#1]            ;1314
000136  42a8              CMP      r0,r5                 ;1314
000138  d8cf              BHI      |L3.218|
;;;1330     }
;;;1331     for (i = 0; i <  pdev->cfg.dev_endpoints; i++)
00013a  2500              MOVS     r5,#0
00013c  e02c              B        |L3.408|
                  |L3.318|
;;;1332     {
;;;1333       USB_OTG_DEPCTL_TypeDef  depctl;
;;;1334       depctl.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[i]->DOEPCTL);
00013e  f1040054          ADD      r0,r4,#0x54
000142  f8500025          LDR      r0,[r0,r5,LSL #2]
000146  6800              LDR      r0,[r0,#0]
000148  9001              STR      r0,[sp,#4]
;;;1335       if (depctl.b.epena)
00014a  9801              LDR      r0,[sp,#4]
00014c  0fc0              LSRS     r0,r0,#31
00014e  b170              CBZ      r0,|L3.366|
;;;1336       {
;;;1337         depctl.d32 = 0;
000150  2000              MOVS     r0,#0
000152  9001              STR      r0,[sp,#4]
;;;1338         depctl.b.epdis = 1;
000154  9801              LDR      r0,[sp,#4]
000156  f0204080          BIC      r0,r0,#0x40000000
00015a  f1004080          ADD      r0,r0,#0x40000000
00015e  9001              STR      r0,[sp,#4]
;;;1339         depctl.b.snak = 1;
000160  9801              LDR      r0,[sp,#4]
000162  f0206000          BIC      r0,r0,#0x8000000
000166  f1006000          ADD      r0,r0,#0x8000000
00016a  9001              STR      r0,[sp,#4]
00016c  e001              B        |L3.370|
                  |L3.366|
;;;1340       }
;;;1341       else
;;;1342       {
;;;1343         depctl.d32 = 0;
00016e  2000              MOVS     r0,#0
000170  9001              STR      r0,[sp,#4]
                  |L3.370|
;;;1344       }
;;;1345       USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPCTL, depctl.d32);
000172  f1040054          ADD      r0,r4,#0x54
000176  f8500025          LDR      r0,[r0,r5,LSL #2]
00017a  9901              LDR      r1,[sp,#4]
00017c  6001              STR      r1,[r0,#0]
;;;1346       USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPTSIZ, 0);
00017e  2100              MOVS     r1,#0
000180  f1040054          ADD      r0,r4,#0x54
000184  f8500025          LDR      r0,[r0,r5,LSL #2]
000188  6101              STR      r1,[r0,#0x10]
;;;1347       USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
00018a  21ff              MOVS     r1,#0xff
00018c  f1040054          ADD      r0,r4,#0x54
000190  f8500025          LDR      r0,[r0,r5,LSL #2]
000194  6081              STR      r1,[r0,#8]
000196  1c6d              ADDS     r5,r5,#1              ;1331
                  |L3.408|
000198  7860              LDRB     r0,[r4,#1]            ;1331
00019a  42a8              CMP      r0,r5                 ;1331
00019c  d8cf              BHI      |L3.318|
;;;1348     }
;;;1349     msk.d32 = 0;
00019e  2000              MOVS     r0,#0
0001a0  9003              STR      r0,[sp,#0xc]
;;;1350     msk.b.txfifoundrn = 1;
0001a2  9803              LDR      r0,[sp,#0xc]
0001a4  f4207080          BIC      r0,r0,#0x100
0001a8  f5007080          ADD      r0,r0,#0x100
0001ac  9003              STR      r0,[sp,#0xc]
;;;1351     USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPMSK, msk.d32, msk.d32);
0001ae  6920              LDR      r0,[r4,#0x10]
0001b0  6900              LDR      r0,[r0,#0x10]
0001b2  9903              LDR      r1,[sp,#0xc]
0001b4  4388              BICS     r0,r0,r1
0001b6  4308              ORRS     r0,r0,r1
0001b8  6921              LDR      r1,[r4,#0x10]
0001ba  6108              STR      r0,[r1,#0x10]
;;;1352     
;;;1353     if (pdev->cfg.dma_enable == 1)
0001bc  78e0              LDRB     r0,[r4,#3]
0001be  2801              CMP      r0,#1
0001c0  d11d              BNE      |L3.510|
;;;1354     {
;;;1355       dthrctl.d32 = 0;
0001c2  2000              MOVS     r0,#0
0001c4  9002              STR      r0,[sp,#8]
;;;1356       dthrctl.b.non_iso_thr_en = 1;
0001c6  9802              LDR      r0,[sp,#8]
0001c8  f0200001          BIC      r0,r0,#1
0001cc  1c40              ADDS     r0,r0,#1
0001ce  9002              STR      r0,[sp,#8]
;;;1357       dthrctl.b.iso_thr_en = 1;
0001d0  9802              LDR      r0,[sp,#8]
0001d2  f0200002          BIC      r0,r0,#2
0001d6  1c80              ADDS     r0,r0,#2
0001d8  9002              STR      r0,[sp,#8]
;;;1358       dthrctl.b.tx_thr_len = 64;
0001da  2140              MOVS     r1,#0x40
0001dc  9802              LDR      r0,[sp,#8]
0001de  f361008a          BFI      r0,r1,#2,#9
0001e2  9002              STR      r0,[sp,#8]
;;;1359       dthrctl.b.rx_thr_en = 1;
0001e4  9802              LDR      r0,[sp,#8]
0001e6  f4203080          BIC      r0,r0,#0x10000
0001ea  f5003080          ADD      r0,r0,#0x10000
0001ee  9002              STR      r0,[sp,#8]
;;;1360       dthrctl.b.rx_thr_len = 64;
0001f0  9802              LDR      r0,[sp,#8]
0001f2  f3614059          BFI      r0,r1,#17,#9
0001f6  9002              STR      r0,[sp,#8]
;;;1361       USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DTHRCTL, dthrctl.d32);  
0001f8  9902              LDR      r1,[sp,#8]
0001fa  6920              LDR      r0,[r4,#0x10]
0001fc  6301              STR      r1,[r0,#0x30]
                  |L3.510|
;;;1362     }
;;;1363     USB_OTG_EnableDevInt(pdev);
0001fe  4620              MOV      r0,r4
000200  f7fffffe          BL       USB_OTG_EnableDevInt
;;;1364     return status;
000204  4630              MOV      r0,r6
;;;1365   }
000206  b008              ADD      sp,sp,#0x20
000208  bd70              POP      {r4-r6,pc}
;;;1366   
                          ENDP


                          AREA ||i.USB_OTG_CoreReset||, CODE, READONLY, ALIGN=2

                  USB_OTG_CoreReset PROC
;;;122    */
;;;123    static USB_OTG_STS USB_OTG_CoreReset(USB_OTG_CORE_HANDLE *pdev)
000000  b5f8              PUSH     {r3-r7,lr}
;;;124    {
000002  4604              MOV      r4,r0
;;;125      USB_OTG_STS status = USB_OTG_OK;
000004  2600              MOVS     r6,#0
;;;126      __IO USB_OTG_GRSTCTL_TypeDef  greset;
;;;127      uint32_t count = 0;
000006  2500              MOVS     r5,#0
;;;128      
;;;129      greset.d32 = 0;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;130      /* Wait for AHB master IDLE state. */
;;;131      do
00000c  bf00              NOP      
                  |L4.14|
;;;132      {
;;;133        USB_OTG_BSP_uDelay(3);
00000e  2003              MOVS     r0,#3
000010  f7fffffe          BL       USB_OTG_BSP_uDelay
;;;134        greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
000014  68e0              LDR      r0,[r4,#0xc]
000016  6900              LDR      r0,[r0,#0x10]
000018  9000              STR      r0,[sp,#0]
;;;135        if (++count > 200000)
00001a  1c68              ADDS     r0,r5,#1
00001c  4605              MOV      r5,r0
00001e  4913              LDR      r1,|L4.108|
000020  4288              CMP      r0,r1
000022  d901              BLS      |L4.40|
;;;136        {
;;;137          return USB_OTG_OK;
000024  2000              MOVS     r0,#0
                  |L4.38|
;;;138        }
;;;139      }
;;;140      while (greset.b.ahbidle == 0);
;;;141      /* Core Soft Reset */
;;;142      count = 0;
;;;143      greset.b.csftrst = 1;
;;;144      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
;;;145      do
;;;146      {
;;;147        greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
;;;148        if (++count > 200000)
;;;149        {
;;;150          break;
;;;151        }
;;;152      }
;;;153      while (greset.b.csftrst == 1);
;;;154      /* Wait for 3 PHY Clocks*/
;;;155      USB_OTG_BSP_uDelay(3);
;;;156      return status;
;;;157    }
000026  bdf8              POP      {r3-r7,pc}
                  |L4.40|
000028  9800              LDR      r0,[sp,#0]            ;140
00002a  0fc0              LSRS     r0,r0,#31             ;140
00002c  2800              CMP      r0,#0                 ;140
00002e  d0ee              BEQ      |L4.14|
000030  2500              MOVS     r5,#0                 ;142
000032  9800              LDR      r0,[sp,#0]            ;143
000034  f0200001          BIC      r0,r0,#1              ;143
000038  1c40              ADDS     r0,r0,#1              ;143
00003a  9000              STR      r0,[sp,#0]            ;143
00003c  9800              LDR      r0,[sp,#0]            ;144
00003e  68e1              LDR      r1,[r4,#0xc]          ;144
000040  6108              STR      r0,[r1,#0x10]         ;144
000042  bf00              NOP                            ;145
                  |L4.68|
000044  68e0              LDR      r0,[r4,#0xc]          ;147
000046  6900              LDR      r0,[r0,#0x10]         ;147
000048  9000              STR      r0,[sp,#0]            ;147
00004a  1c68              ADDS     r0,r5,#1              ;148
00004c  4605              MOV      r5,r0                 ;148
00004e  4907              LDR      r1,|L4.108|
000050  4288              CMP      r0,r1                 ;148
000052  d900              BLS      |L4.86|
000054  e004              B        |L4.96|
                  |L4.86|
000056  9800              LDR      r0,[sp,#0]            ;153
000058  f0000001          AND      r0,r0,#1              ;153
00005c  2800              CMP      r0,#0                 ;153
00005e  d1f1              BNE      |L4.68|
                  |L4.96|
000060  bf00              NOP                            ;150
000062  2003              MOVS     r0,#3                 ;155
000064  f7fffffe          BL       USB_OTG_BSP_uDelay
000068  4630              MOV      r0,r6                 ;156
00006a  e7dc              B        |L4.38|
;;;158    
                          ENDP

                  |L4.108|
                          DCD      0x00030d40

                          AREA ||i.USB_OTG_DisableGlobalInt||, CODE, READONLY, ALIGN=1

                  USB_OTG_DisableGlobalInt PROC
;;;446    */
;;;447    USB_OTG_STS USB_OTG_DisableGlobalInt(USB_OTG_CORE_HANDLE *pdev)
000000  b508              PUSH     {r3,lr}
;;;448    {
000002  4601              MOV      r1,r0
;;;449      USB_OTG_STS status = USB_OTG_OK;
000004  2000              MOVS     r0,#0
;;;450      USB_OTG_GAHBCFG_TypeDef  ahbcfg;
;;;451      ahbcfg.d32 = 0;
000006  2200              MOVS     r2,#0
000008  9200              STR      r2,[sp,#0]
;;;452      ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
00000a  9a00              LDR      r2,[sp,#0]
00000c  f0220201          BIC      r2,r2,#1
000010  1c52              ADDS     r2,r2,#1
000012  9200              STR      r2,[sp,#0]
;;;453      USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32, 0);
000014  68ca              LDR      r2,[r1,#0xc]
000016  6892              LDR      r2,[r2,#8]
000018  9b00              LDR      r3,[sp,#0]
00001a  439a              BICS     r2,r2,r3
00001c  68cb              LDR      r3,[r1,#0xc]
00001e  609a              STR      r2,[r3,#8]
;;;454      return status;
;;;455    }
000020  bd08              POP      {r3,pc}
;;;456    
                          ENDP


                          AREA ||i.USB_OTG_EP0Activate||, CODE, READONLY, ALIGN=1

                  USB_OTG_EP0Activate PROC
;;;1447   */
;;;1448   USB_OTG_STS  USB_OTG_EP0Activate(USB_OTG_CORE_HANDLE *pdev)
000000  b50e              PUSH     {r1-r3,lr}
;;;1449   {
000002  4601              MOV      r1,r0
;;;1450     USB_OTG_STS             status = USB_OTG_OK;
000004  2000              MOVS     r0,#0
;;;1451     USB_OTG_DSTS_TypeDef    dsts;
;;;1452     USB_OTG_DEPCTL_TypeDef  diepctl;
;;;1453     USB_OTG_DCTL_TypeDef    dctl;
;;;1454     
;;;1455     dctl.d32 = 0;
000006  2200              MOVS     r2,#0
000008  9200              STR      r2,[sp,#0]
;;;1456     /* Read the Device Status and Endpoint 0 Control registers */
;;;1457     dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
00000a  690a              LDR      r2,[r1,#0x10]
00000c  6892              LDR      r2,[r2,#8]
00000e  9202              STR      r2,[sp,#8]
;;;1458     diepctl.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[0]->DIEPCTL);
000010  698a              LDR      r2,[r1,#0x18]
000012  6812              LDR      r2,[r2,#0]
000014  9201              STR      r2,[sp,#4]
;;;1459     /* Set the MPS of the IN EP based on the enumeration speed */
;;;1460     switch (dsts.b.enumspd)
000016  9a02              LDR      r2,[sp,#8]
000018  f3c20241          UBFX     r2,r2,#1,#2
00001c  b132              CBZ      r2,|L6.44|
00001e  2a01              CMP      r2,#1
000020  d005              BEQ      |L6.46|
000022  2a02              CMP      r2,#2
000024  d009              BEQ      |L6.58|
000026  2a03              CMP      r2,#3
000028  d10d              BNE      |L6.70|
00002a  e001              B        |L6.48|
                  |L6.44|
;;;1461     {
;;;1462     case DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ:
;;;1463     case DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ:
00002c  bf00              NOP      
                  |L6.46|
;;;1464     case DSTS_ENUMSPD_FS_PHY_48MHZ:
00002e  bf00              NOP      
                  |L6.48|
;;;1465       diepctl.b.mps = DEP0CTL_MPS_64;
000030  9a01              LDR      r2,[sp,#4]
000032  f36f020a          BFC      r2,#0,#11
000036  9201              STR      r2,[sp,#4]
;;;1466       break;
000038  e005              B        |L6.70|
                  |L6.58|
;;;1467     case DSTS_ENUMSPD_LS_PHY_6MHZ:
;;;1468       diepctl.b.mps = DEP0CTL_MPS_8;
00003a  9a01              LDR      r2,[sp,#4]
00003c  f36f020a          BFC      r2,#0,#11
000040  1cd2              ADDS     r2,r2,#3
000042  9201              STR      r2,[sp,#4]
;;;1469       break;
000044  bf00              NOP      
                  |L6.70|
000046  bf00              NOP                            ;1466
;;;1470     }
;;;1471     USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[0]->DIEPCTL, diepctl.d32);
000048  9b01              LDR      r3,[sp,#4]
00004a  698a              LDR      r2,[r1,#0x18]
00004c  6013              STR      r3,[r2,#0]
;;;1472     dctl.b.cgnpinnak = 1;
00004e  9a00              LDR      r2,[sp,#0]
000050  f4227280          BIC      r2,r2,#0x100
000054  f5027280          ADD      r2,r2,#0x100
000058  9200              STR      r2,[sp,#0]
;;;1473     USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, dctl.d32);
00005a  690a              LDR      r2,[r1,#0x10]
00005c  6852              LDR      r2,[r2,#4]
00005e  9b00              LDR      r3,[sp,#0]
000060  439a              BICS     r2,r2,r3
000062  431a              ORRS     r2,r2,r3
000064  690b              LDR      r3,[r1,#0x10]
000066  605a              STR      r2,[r3,#4]
;;;1474     return status;
;;;1475   }
000068  bd0e              POP      {r1-r3,pc}
;;;1476   
                          ENDP


                          AREA ||i.USB_OTG_EP0StartXfer||, CODE, READONLY, ALIGN=1

                  USB_OTG_EP0StartXfer PROC
;;;1707   */
;;;1708   USB_OTG_STS USB_OTG_EP0StartXfer(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
000000  b5fe              PUSH     {r1-r7,lr}
;;;1709   {
000002  4602              MOV      r2,r0
;;;1710     USB_OTG_STS                 status = USB_OTG_OK;
000004  2000              MOVS     r0,#0
;;;1711     USB_OTG_DEPCTL_TypeDef      depctl;
;;;1712     USB_OTG_DEP0XFRSIZ_TypeDef  deptsiz;
;;;1713     USB_OTG_INEPREGS          *in_regs;
;;;1714     uint32_t fifoemptymsk = 0;
000006  2400              MOVS     r4,#0
;;;1715     
;;;1716     depctl.d32   = 0;
000008  2500              MOVS     r5,#0
00000a  9502              STR      r5,[sp,#8]
;;;1717     deptsiz.d32  = 0;
00000c  9500              STR      r5,[sp,#0]
;;;1718     /* IN endpoint */
;;;1719     if (ep->is_in == 1)
00000e  784d              LDRB     r5,[r1,#1]
000010  2d01              CMP      r5,#1
000012  d152              BNE      |L7.186|
;;;1720     {
;;;1721       in_regs = pdev->regs.INEP_REGS[0];
000014  6993              LDR      r3,[r2,#0x18]
;;;1722       depctl.d32  = USB_OTG_READ_REG32(&in_regs->DIEPCTL);
000016  681d              LDR      r5,[r3,#0]
000018  9502              STR      r5,[sp,#8]
;;;1723       deptsiz.d32 = USB_OTG_READ_REG32(&in_regs->DIEPTSIZ);
00001a  691d              LDR      r5,[r3,#0x10]
00001c  9500              STR      r5,[sp,#0]
;;;1724       /* Zero Length Packet? */
;;;1725       if (ep->xfer_len == 0)
00001e  694d              LDR      r5,[r1,#0x14]
000020  b955              CBNZ     r5,|L7.56|
;;;1726       {
;;;1727         deptsiz.b.xfersize = 0;
000022  9d00              LDR      r5,[sp,#0]
000024  f025057f          BIC      r5,r5,#0x7f
000028  9500              STR      r5,[sp,#0]
;;;1728         deptsiz.b.pktcnt = 1;
00002a  9d00              LDR      r5,[sp,#0]
00002c  f42515c0          BIC      r5,r5,#0x180000
000030  f5052500          ADD      r5,r5,#0x80000
000034  9500              STR      r5,[sp,#0]
000036  e016              B        |L7.102|
                  |L7.56|
;;;1729         
;;;1730       }
;;;1731       else
;;;1732       {
;;;1733         if (ep->xfer_len > ep->maxpacket)
000038  688e              LDR      r6,[r1,#8]
00003a  694d              LDR      r5,[r1,#0x14]
00003c  42b5              CMP      r5,r6
00003e  d907              BLS      |L7.80|
;;;1734         {
;;;1735           ep->xfer_len = ep->maxpacket;
000040  688d              LDR      r5,[r1,#8]
000042  614d              STR      r5,[r1,#0x14]
;;;1736           deptsiz.b.xfersize = ep->maxpacket;
000044  7a0e              LDRB     r6,[r1,#8]
000046  9d00              LDR      r5,[sp,#0]
000048  f3660506          BFI      r5,r6,#0,#7
00004c  9500              STR      r5,[sp,#0]
00004e  e004              B        |L7.90|
                  |L7.80|
;;;1737         }
;;;1738         else
;;;1739         {
;;;1740           deptsiz.b.xfersize = ep->xfer_len;
000050  7d0e              LDRB     r6,[r1,#0x14]
000052  9d00              LDR      r5,[sp,#0]
000054  f3660506          BFI      r5,r6,#0,#7
000058  9500              STR      r5,[sp,#0]
                  |L7.90|
;;;1741         }
;;;1742         deptsiz.b.pktcnt = 1;
00005a  9d00              LDR      r5,[sp,#0]
00005c  f42515c0          BIC      r5,r5,#0x180000
000060  f5052500          ADD      r5,r5,#0x80000
000064  9500              STR      r5,[sp,#0]
                  |L7.102|
;;;1743       }
;;;1744       USB_OTG_WRITE_REG32(&in_regs->DIEPTSIZ, deptsiz.d32);
000066  9d00              LDR      r5,[sp,#0]
000068  611d              STR      r5,[r3,#0x10]
;;;1745       
;;;1746       if (pdev->cfg.dma_enable == 1)
00006a  78d5              LDRB     r5,[r2,#3]
00006c  2d01              CMP      r5,#1
00006e  d106              BNE      |L7.126|
;;;1747       {
;;;1748         USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPDMA, ep->dma_addr);  
000070  780f              LDRB     r7,[r1,#0]
000072  f1020518          ADD      r5,r2,#0x18
000076  f8555027          LDR      r5,[r5,r7,LSL #2]
00007a  690e              LDR      r6,[r1,#0x10]
00007c  616e              STR      r6,[r5,#0x14]
                  |L7.126|
;;;1749       }
;;;1750       
;;;1751       /* EP enable, IN data in FIFO */
;;;1752       depctl.b.cnak = 1;
00007e  9d02              LDR      r5,[sp,#8]
000080  f0256580          BIC      r5,r5,#0x4000000
000084  f1056580          ADD      r5,r5,#0x4000000
000088  9502              STR      r5,[sp,#8]
;;;1753       depctl.b.epena = 1;
00008a  9d02              LDR      r5,[sp,#8]
00008c  f0254500          BIC      r5,r5,#0x80000000
000090  f1054500          ADD      r5,r5,#0x80000000
000094  9502              STR      r5,[sp,#8]
;;;1754       USB_OTG_WRITE_REG32(&in_regs->DIEPCTL, depctl.d32);
000096  9d02              LDR      r5,[sp,#8]
000098  601d              STR      r5,[r3,#0]
;;;1755       
;;;1756       
;;;1757       
;;;1758       if (pdev->cfg.dma_enable == 0)
00009a  78d5              LDRB     r5,[r2,#3]
00009c  2d00              CMP      r5,#0
00009e  d159              BNE      |L7.340|
;;;1759       {
;;;1760         /* Enable the Tx FIFO Empty Interrupt for this EP */
;;;1761         if (ep->xfer_len > 0)
0000a0  694d              LDR      r5,[r1,#0x14]
0000a2  2d00              CMP      r5,#0
0000a4  d056              BEQ      |L7.340|
;;;1762         {
;;;1763           {
;;;1764             fifoemptymsk |= 1 << ep->num;
0000a6  780e              LDRB     r6,[r1,#0]
0000a8  2501              MOVS     r5,#1
0000aa  40b5              LSLS     r5,r5,r6
0000ac  432c              ORRS     r4,r4,r5
;;;1765             USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
0000ae  6915              LDR      r5,[r2,#0x10]
0000b0  6b6d              LDR      r5,[r5,#0x34]
0000b2  4325              ORRS     r5,r5,r4
0000b4  6916              LDR      r6,[r2,#0x10]
0000b6  6375              STR      r5,[r6,#0x34]
0000b8  e04c              B        |L7.340|
                  |L7.186|
;;;1766           }
;;;1767         }
;;;1768       }
;;;1769     }
;;;1770     else
;;;1771     {
;;;1772       /* OUT endpoint */
;;;1773       depctl.d32  = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
0000ba  780e              LDRB     r6,[r1,#0]
0000bc  f1020554          ADD      r5,r2,#0x54
0000c0  f8555026          LDR      r5,[r5,r6,LSL #2]
0000c4  682d              LDR      r5,[r5,#0]
0000c6  9502              STR      r5,[sp,#8]
;;;1774       deptsiz.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ);
0000c8  780e              LDRB     r6,[r1,#0]
0000ca  f1020554          ADD      r5,r2,#0x54
0000ce  f8555026          LDR      r5,[r5,r6,LSL #2]
0000d2  692d              LDR      r5,[r5,#0x10]
0000d4  9500              STR      r5,[sp,#0]
;;;1775       /* Program the transfer size and packet count as follows:
;;;1776       * xfersize = N * (maxpacket + 4 - (maxpacket % 4))
;;;1777       * pktcnt = N           */
;;;1778       if (ep->xfer_len == 0)
0000d6  694d              LDR      r5,[r1,#0x14]
0000d8  b95d              CBNZ     r5,|L7.242|
;;;1779       {
;;;1780         deptsiz.b.xfersize = ep->maxpacket;
0000da  7a0e              LDRB     r6,[r1,#8]
0000dc  9d00              LDR      r5,[sp,#0]
0000de  f3660506          BFI      r5,r6,#0,#7
0000e2  9500              STR      r5,[sp,#0]
;;;1781         deptsiz.b.pktcnt = 1;
0000e4  9d00              LDR      r5,[sp,#0]
0000e6  f42515c0          BIC      r5,r5,#0x180000
0000ea  f5052500          ADD      r5,r5,#0x80000
0000ee  9500              STR      r5,[sp,#0]
0000f0  e00c              B        |L7.268|
                  |L7.242|
;;;1782       }
;;;1783       else
;;;1784       {
;;;1785         ep->xfer_len = ep->maxpacket;
0000f2  688d              LDR      r5,[r1,#8]
0000f4  614d              STR      r5,[r1,#0x14]
;;;1786         deptsiz.b.xfersize = ep->maxpacket;
0000f6  7a0e              LDRB     r6,[r1,#8]
0000f8  9d00              LDR      r5,[sp,#0]
0000fa  f3660506          BFI      r5,r6,#0,#7
0000fe  9500              STR      r5,[sp,#0]
;;;1787         deptsiz.b.pktcnt = 1;
000100  9d00              LDR      r5,[sp,#0]
000102  f42515c0          BIC      r5,r5,#0x180000
000106  f5052500          ADD      r5,r5,#0x80000
00010a  9500              STR      r5,[sp,#0]
                  |L7.268|
;;;1788       }
;;;1789       USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ, deptsiz.d32);
00010c  780f              LDRB     r7,[r1,#0]
00010e  f1020554          ADD      r5,r2,#0x54
000112  f8555027          LDR      r5,[r5,r7,LSL #2]
000116  9e00              LDR      r6,[sp,#0]
000118  612e              STR      r6,[r5,#0x10]
;;;1790       if (pdev->cfg.dma_enable == 1)
00011a  78d5              LDRB     r5,[r2,#3]
00011c  2d01              CMP      r5,#1
00011e  d106              BNE      |L7.302|
;;;1791       {
;;;1792         USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPDMA, ep->dma_addr);
000120  780f              LDRB     r7,[r1,#0]
000122  f1020554          ADD      r5,r2,#0x54
000126  f8555027          LDR      r5,[r5,r7,LSL #2]
00012a  690e              LDR      r6,[r1,#0x10]
00012c  616e              STR      r6,[r5,#0x14]
                  |L7.302|
;;;1793       }
;;;1794       /* EP enable */
;;;1795       depctl.b.cnak = 1;
00012e  9d02              LDR      r5,[sp,#8]
000130  f0256580          BIC      r5,r5,#0x4000000
000134  f1056580          ADD      r5,r5,#0x4000000
000138  9502              STR      r5,[sp,#8]
;;;1796       depctl.b.epena = 1;
00013a  9d02              LDR      r5,[sp,#8]
00013c  f0254500          BIC      r5,r5,#0x80000000
000140  f1054500          ADD      r5,r5,#0x80000000
000144  9502              STR      r5,[sp,#8]
;;;1797       USB_OTG_WRITE_REG32 (&(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL), depctl.d32);
000146  780f              LDRB     r7,[r1,#0]
000148  f1020554          ADD      r5,r2,#0x54
00014c  f8555027          LDR      r5,[r5,r7,LSL #2]
000150  9e02              LDR      r6,[sp,#8]
000152  602e              STR      r6,[r5,#0]
                  |L7.340|
;;;1798       
;;;1799     }
;;;1800     return status;
;;;1801   }
000154  bdfe              POP      {r1-r7,pc}
;;;1802   
                          ENDP


                          AREA ||i.USB_OTG_EP0_OutStart||, CODE, READONLY, ALIGN=1

                  USB_OTG_EP0_OutStart PROC
;;;1919   */
;;;1920   void USB_OTG_EP0_OutStart(USB_OTG_CORE_HANDLE *pdev)
000000  b50e              PUSH     {r1-r3,lr}
;;;1921   {
;;;1922     USB_OTG_DEP0XFRSIZ_TypeDef  doeptsize0;
;;;1923     doeptsize0.d32 = 0;
000002  2100              MOVS     r1,#0
000004  9101              STR      r1,[sp,#4]
;;;1924     doeptsize0.b.supcnt = 3;
000006  9901              LDR      r1,[sp,#4]
000008  f0214140          BIC      r1,r1,#0xc0000000
00000c  f1a14180          SUB      r1,r1,#0x40000000
000010  9101              STR      r1,[sp,#4]
;;;1925     doeptsize0.b.pktcnt = 1;
000012  9901              LDR      r1,[sp,#4]
000014  f42111c0          BIC      r1,r1,#0x180000
000018  f5012100          ADD      r1,r1,#0x80000
00001c  9101              STR      r1,[sp,#4]
;;;1926     doeptsize0.b.xfersize = 8 * 3;
00001e  9901              LDR      r1,[sp,#4]
000020  f021017f          BIC      r1,r1,#0x7f
000024  3118              ADDS     r1,r1,#0x18
000026  9101              STR      r1,[sp,#4]
;;;1927     USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPTSIZ, doeptsize0.d32 );
000028  9a01              LDR      r2,[sp,#4]
00002a  6d41              LDR      r1,[r0,#0x54]
00002c  610a              STR      r2,[r1,#0x10]
;;;1928     
;;;1929     if (pdev->cfg.dma_enable == 1)
00002e  78c1              LDRB     r1,[r0,#3]
000030  2901              CMP      r1,#1
000032  d115              BNE      |L8.96|
;;;1930     {
;;;1931       USB_OTG_DEPCTL_TypeDef  doepctl;
;;;1932       doepctl.d32 = 0;
000034  2100              MOVS     r1,#0
000036  9100              STR      r1,[sp,#0]
;;;1933       USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPDMA, 
000038  f20051cc          ADD      r1,r0,#0x5cc
00003c  6d42              LDR      r2,[r0,#0x54]
00003e  6151              STR      r1,[r2,#0x14]
;;;1934                           (uint32_t)&pdev->dev.setup_packet);
;;;1935       
;;;1936       /* EP enable */
;;;1937       doepctl.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[0]->DOEPCTL);
000040  6d41              LDR      r1,[r0,#0x54]
000042  6809              LDR      r1,[r1,#0]
000044  9100              STR      r1,[sp,#0]
;;;1938       doepctl.b.epena = 1;
000046  9900              LDR      r1,[sp,#0]
000048  f0214100          BIC      r1,r1,#0x80000000
00004c  f1014100          ADD      r1,r1,#0x80000000
000050  9100              STR      r1,[sp,#0]
;;;1939       doepctl.d32 = 0x80008000;
000052  f04f2180          MOV      r1,#0x80008000
000056  9100              STR      r1,[sp,#0]
;;;1940       USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPCTL, doepctl.d32);
000058  9a00              LDR      r2,[sp,#0]
00005a  6d41              LDR      r1,[r0,#0x54]
00005c  600a              STR      r2,[r1,#0]
;;;1941     }
00005e  bf00              NOP      
                  |L8.96|
;;;1942   }
000060  bd0e              POP      {r1-r3,pc}
;;;1943   
                          ENDP


                          AREA ||i.USB_OTG_EPActivate||, CODE, READONLY, ALIGN=1

                  USB_OTG_EPActivate PROC
;;;1482   */
;;;1483   USB_OTG_STS USB_OTG_EPActivate(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
000000  b53c              PUSH     {r2-r5,lr}
;;;1484   {
000002  4602              MOV      r2,r0
;;;1485     USB_OTG_STS status = USB_OTG_OK;
000004  2000              MOVS     r0,#0
;;;1486     USB_OTG_DEPCTL_TypeDef  depctl;
;;;1487     USB_OTG_DAINT_TypeDef  daintmsk;
;;;1488     __IO uint32_t *addr;
;;;1489     
;;;1490     
;;;1491     depctl.d32 = 0;
000006  2400              MOVS     r4,#0
000008  9401              STR      r4,[sp,#4]
;;;1492     daintmsk.d32 = 0;
00000a  9400              STR      r4,[sp,#0]
;;;1493     /* Read DEPCTLn register */
;;;1494     if (ep->is_in == 1)
00000c  784c              LDRB     r4,[r1,#1]
00000e  2c01              CMP      r4,#1
000010  d10c              BNE      |L9.44|
;;;1495     {
;;;1496       addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
000012  780d              LDRB     r5,[r1,#0]
000014  f1020418          ADD      r4,r2,#0x18
000018  f8543025          LDR      r3,[r4,r5,LSL #2]
;;;1497       daintmsk.ep.in = 1 << ep->num;
00001c  780d              LDRB     r5,[r1,#0]
00001e  2401              MOVS     r4,#1
000020  40ac              LSLS     r4,r4,r5
000022  9d00              LDR      r5,[sp,#0]
000024  f364050f          BFI      r5,r4,#0,#16
000028  9500              STR      r5,[sp,#0]
00002a  e00b              B        |L9.68|
                  |L9.44|
;;;1498     }
;;;1499     else
;;;1500     {
;;;1501       addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
00002c  780d              LDRB     r5,[r1,#0]
00002e  f1020454          ADD      r4,r2,#0x54
000032  f8543025          LDR      r3,[r4,r5,LSL #2]
;;;1502       daintmsk.ep.out = 1 << ep->num;
000036  780d              LDRB     r5,[r1,#0]
000038  2401              MOVS     r4,#1
00003a  40ac              LSLS     r4,r4,r5
00003c  9d00              LDR      r5,[sp,#0]
00003e  f364451f          BFI      r5,r4,#16,#16
000042  9500              STR      r5,[sp,#0]
                  |L9.68|
;;;1503     }
;;;1504     /* If the EP is already active don't change the EP Control
;;;1505     * register. */
;;;1506     depctl.d32 = USB_OTG_READ_REG32(addr);
000044  681c              LDR      r4,[r3,#0]
000046  9401              STR      r4,[sp,#4]
;;;1507     if (!depctl.b.usbactep)
000048  9c01              LDR      r4,[sp,#4]
00004a  f3c434c0          UBFX     r4,r4,#15,#1
00004e  b9e4              CBNZ     r4,|L9.138|
;;;1508     {
;;;1509       depctl.b.mps    = ep->maxpacket;
000050  890d              LDRH     r5,[r1,#8]
000052  9c01              LDR      r4,[sp,#4]
000054  f365040a          BFI      r4,r5,#0,#11
000058  9401              STR      r4,[sp,#4]
;;;1510       depctl.b.eptype = ep->type;
00005a  78cd              LDRB     r5,[r1,#3]
00005c  9c01              LDR      r4,[sp,#4]
00005e  f3654493          BFI      r4,r5,#18,#2
000062  9401              STR      r4,[sp,#4]
;;;1511       depctl.b.txfnum = ep->tx_fifo_num;
000064  798d              LDRB     r5,[r1,#6]
000066  9c01              LDR      r4,[sp,#4]
000068  f3655499          BFI      r4,r5,#22,#4
00006c  9401              STR      r4,[sp,#4]
;;;1512       depctl.b.setd0pid = 1;
00006e  9c01              LDR      r4,[sp,#4]
000070  f0245480          BIC      r4,r4,#0x10000000
000074  f1045480          ADD      r4,r4,#0x10000000
000078  9401              STR      r4,[sp,#4]
;;;1513       depctl.b.usbactep = 1;
00007a  9c01              LDR      r4,[sp,#4]
00007c  f4244400          BIC      r4,r4,#0x8000
000080  f5044400          ADD      r4,r4,#0x8000
000084  9401              STR      r4,[sp,#4]
;;;1514       USB_OTG_WRITE_REG32(addr, depctl.d32);
000086  9c01              LDR      r4,[sp,#4]
000088  601c              STR      r4,[r3,#0]
                  |L9.138|
;;;1515     }
;;;1516     /* Enable the Interrupt for this EP */
;;;1517   #ifdef USB_OTG_HS_DEDICATED_EP1_ENABLED
;;;1518     if((ep->num == 1)&&(pdev->cfg.coreID == USB_OTG_HS_CORE_ID))
;;;1519     {
;;;1520       USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DEACHMSK, 0, daintmsk.d32);
;;;1521     }
;;;1522     else
;;;1523   #endif   
;;;1524       USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DAINTMSK, 0, daintmsk.d32);
00008a  6914              LDR      r4,[r2,#0x10]
00008c  69e4              LDR      r4,[r4,#0x1c]
00008e  9d00              LDR      r5,[sp,#0]
000090  432c              ORRS     r4,r4,r5
000092  6915              LDR      r5,[r2,#0x10]
000094  61ec              STR      r4,[r5,#0x1c]
;;;1525     return status;
;;;1526   }
000096  bd3c              POP      {r2-r5,pc}
;;;1527   
                          ENDP


                          AREA ||i.USB_OTG_EPClearStall||, CODE, READONLY, ALIGN=1

                  USB_OTG_EPClearStall PROC
;;;1844   */
;;;1845   USB_OTG_STS USB_OTG_EPClearStall(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
000000  b538              PUSH     {r3-r5,lr}
;;;1846   {
000002  4603              MOV      r3,r0
;;;1847     USB_OTG_STS status = USB_OTG_OK;
000004  2000              MOVS     r0,#0
;;;1848     USB_OTG_DEPCTL_TypeDef  depctl;
;;;1849     __IO uint32_t *depctl_addr;
;;;1850     
;;;1851     depctl.d32 = 0;
000006  2400              MOVS     r4,#0
000008  9400              STR      r4,[sp,#0]
;;;1852     
;;;1853     if (ep->is_in == 1)
00000a  784c              LDRB     r4,[r1,#1]
00000c  2c01              CMP      r4,#1
00000e  d105              BNE      |L10.28|
;;;1854     {
;;;1855       depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
000010  780d              LDRB     r5,[r1,#0]
000012  f1030418          ADD      r4,r3,#0x18
000016  f8542025          LDR      r2,[r4,r5,LSL #2]
00001a  e004              B        |L10.38|
                  |L10.28|
;;;1856     }
;;;1857     else
;;;1858     {
;;;1859       depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
00001c  780d              LDRB     r5,[r1,#0]
00001e  f1030454          ADD      r4,r3,#0x54
000022  f8542025          LDR      r2,[r4,r5,LSL #2]
                  |L10.38|
;;;1860     }
;;;1861     depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
000026  6814              LDR      r4,[r2,#0]
000028  9400              STR      r4,[sp,#0]
;;;1862     /* clear the stall bits */
;;;1863     depctl.b.stall = 0;
00002a  9c00              LDR      r4,[sp,#0]
00002c  f4241400          BIC      r4,r4,#0x200000
000030  9400              STR      r4,[sp,#0]
;;;1864     if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
000032  78cc              LDRB     r4,[r1,#3]
000034  2c03              CMP      r4,#3
000036  d002              BEQ      |L10.62|
000038  78cc              LDRB     r4,[r1,#3]
00003a  2c02              CMP      r4,#2
00003c  d105              BNE      |L10.74|
                  |L10.62|
;;;1865     {
;;;1866       depctl.b.setd0pid = 1; /* DATA0 */
00003e  9c00              LDR      r4,[sp,#0]
000040  f0245480          BIC      r4,r4,#0x10000000
000044  f1045480          ADD      r4,r4,#0x10000000
000048  9400              STR      r4,[sp,#0]
                  |L10.74|
;;;1867     }
;;;1868     USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
00004a  9c00              LDR      r4,[sp,#0]
00004c  6014              STR      r4,[r2,#0]
;;;1869     return status;
;;;1870   }
00004e  bd38              POP      {r3-r5,pc}
;;;1871   
                          ENDP


                          AREA ||i.USB_OTG_EPDeactivate||, CODE, READONLY, ALIGN=1

                  USB_OTG_EPDeactivate PROC
;;;1533   */
;;;1534   USB_OTG_STS USB_OTG_EPDeactivate(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
000000  b53c              PUSH     {r2-r5,lr}
;;;1535   {
000002  4602              MOV      r2,r0
;;;1536     USB_OTG_STS status = USB_OTG_OK;
000004  2000              MOVS     r0,#0
;;;1537     USB_OTG_DEPCTL_TypeDef  depctl;
;;;1538     USB_OTG_DAINT_TypeDef  daintmsk;
;;;1539     __IO uint32_t *addr;
;;;1540     
;;;1541     depctl.d32 = 0;
000006  2400              MOVS     r4,#0
000008  9401              STR      r4,[sp,#4]
;;;1542     daintmsk.d32 = 0;  
00000a  9400              STR      r4,[sp,#0]
;;;1543     /* Read DEPCTLn register */
;;;1544     if (ep->is_in == 1)
00000c  784c              LDRB     r4,[r1,#1]
00000e  2c01              CMP      r4,#1
000010  d10c              BNE      |L11.44|
;;;1545     {
;;;1546       addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
000012  780d              LDRB     r5,[r1,#0]
000014  f1020418          ADD      r4,r2,#0x18
000018  f8543025          LDR      r3,[r4,r5,LSL #2]
;;;1547       daintmsk.ep.in = 1 << ep->num;
00001c  780d              LDRB     r5,[r1,#0]
00001e  2401              MOVS     r4,#1
000020  40ac              LSLS     r4,r4,r5
000022  9d00              LDR      r5,[sp,#0]
000024  f364050f          BFI      r5,r4,#0,#16
000028  9500              STR      r5,[sp,#0]
00002a  e00b              B        |L11.68|
                  |L11.44|
;;;1548     }
;;;1549     else
;;;1550     {
;;;1551       addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
00002c  780d              LDRB     r5,[r1,#0]
00002e  f1020454          ADD      r4,r2,#0x54
000032  f8543025          LDR      r3,[r4,r5,LSL #2]
;;;1552       daintmsk.ep.out = 1 << ep->num;
000036  780d              LDRB     r5,[r1,#0]
000038  2401              MOVS     r4,#1
00003a  40ac              LSLS     r4,r4,r5
00003c  9d00              LDR      r5,[sp,#0]
00003e  f364451f          BFI      r5,r4,#16,#16
000042  9500              STR      r5,[sp,#0]
                  |L11.68|
;;;1553     }
;;;1554     depctl.b.usbactep = 0;
000044  9c01              LDR      r4,[sp,#4]
000046  f4244400          BIC      r4,r4,#0x8000
00004a  9401              STR      r4,[sp,#4]
;;;1555     USB_OTG_WRITE_REG32(addr, depctl.d32);
00004c  9c01              LDR      r4,[sp,#4]
00004e  601c              STR      r4,[r3,#0]
;;;1556     /* Disable the Interrupt for this EP */
;;;1557     
;;;1558   #ifdef USB_OTG_HS_DEDICATED_EP1_ENABLED
;;;1559     if((ep->num == 1)&&(pdev->cfg.coreID == USB_OTG_HS_CORE_ID))
;;;1560     {
;;;1561       USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DEACHMSK, daintmsk.d32, 0);
;;;1562     }
;;;1563     else
;;;1564   #endif    
;;;1565       USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DAINTMSK, daintmsk.d32, 0);
000050  6914              LDR      r4,[r2,#0x10]
000052  69e4              LDR      r4,[r4,#0x1c]
000054  9d00              LDR      r5,[sp,#0]
000056  43ac              BICS     r4,r4,r5
000058  6915              LDR      r5,[r2,#0x10]
00005a  61ec              STR      r4,[r5,#0x1c]
;;;1566     return status;
;;;1567   }
00005c  bd3c              POP      {r2-r5,pc}
;;;1568   
                          ENDP


                          AREA ||i.USB_OTG_EPSetStall||, CODE, READONLY, ALIGN=1

                  USB_OTG_EPSetStall PROC
;;;1808   */
;;;1809   USB_OTG_STS USB_OTG_EPSetStall(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
000000  b538              PUSH     {r3-r5,lr}
;;;1810   {
000002  4603              MOV      r3,r0
000004  460a              MOV      r2,r1
;;;1811     USB_OTG_STS status = USB_OTG_OK;
000006  2000              MOVS     r0,#0
;;;1812     USB_OTG_DEPCTL_TypeDef  depctl;
;;;1813     __IO uint32_t *depctl_addr;
;;;1814     
;;;1815     depctl.d32 = 0;
000008  2400              MOVS     r4,#0
00000a  9400              STR      r4,[sp,#0]
;;;1816     if (ep->is_in == 1)
00000c  7854              LDRB     r4,[r2,#1]
00000e  2c01              CMP      r4,#1
000010  d118              BNE      |L12.68|
;;;1817     {
;;;1818       depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
000012  7815              LDRB     r5,[r2,#0]
000014  f1030418          ADD      r4,r3,#0x18
000018  f8541025          LDR      r1,[r4,r5,LSL #2]
;;;1819       depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
00001c  680c              LDR      r4,[r1,#0]
00001e  9400              STR      r4,[sp,#0]
;;;1820       /* set the disable and stall bits */
;;;1821       if (depctl.b.epena)
000020  9c00              LDR      r4,[sp,#0]
000022  0fe4              LSRS     r4,r4,#31
000024  b12c              CBZ      r4,|L12.50|
;;;1822       {
;;;1823         depctl.b.epdis = 1;
000026  9c00              LDR      r4,[sp,#0]
000028  f0244480          BIC      r4,r4,#0x40000000
00002c  f1044480          ADD      r4,r4,#0x40000000
000030  9400              STR      r4,[sp,#0]
                  |L12.50|
;;;1824       }
;;;1825       depctl.b.stall = 1;
000032  9c00              LDR      r4,[sp,#0]
000034  f4241400          BIC      r4,r4,#0x200000
000038  f5041400          ADD      r4,r4,#0x200000
00003c  9400              STR      r4,[sp,#0]
;;;1826       USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
00003e  9c00              LDR      r4,[sp,#0]
000040  600c              STR      r4,[r1,#0]
000042  e00e              B        |L12.98|
                  |L12.68|
;;;1827     }
;;;1828     else
;;;1829     {
;;;1830       depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
000044  7815              LDRB     r5,[r2,#0]
000046  f1030454          ADD      r4,r3,#0x54
00004a  f8541025          LDR      r1,[r4,r5,LSL #2]
;;;1831       depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
00004e  680c              LDR      r4,[r1,#0]
000050  9400              STR      r4,[sp,#0]
;;;1832       /* set the stall bit */
;;;1833       depctl.b.stall = 1;
000052  9c00              LDR      r4,[sp,#0]
000054  f4241400          BIC      r4,r4,#0x200000
000058  f5041400          ADD      r4,r4,#0x200000
00005c  9400              STR      r4,[sp,#0]
;;;1834       USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
00005e  9c00              LDR      r4,[sp,#0]
000060  600c              STR      r4,[r1,#0]
                  |L12.98|
;;;1835     }
;;;1836     return status;
;;;1837   }
000062  bd38              POP      {r3-r5,pc}
;;;1838   
                          ENDP


                          AREA ||i.USB_OTG_EPStartXfer||, CODE, READONLY, ALIGN=1

                  USB_OTG_EPStartXfer PROC
;;;1575   */
;;;1576   USB_OTG_STS USB_OTG_EPStartXfer(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
000000  b5fe              PUSH     {r1-r7,lr}
;;;1577   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1578     USB_OTG_STS status = USB_OTG_OK;
000006  2600              MOVS     r6,#0
;;;1579     USB_OTG_DEPCTL_TypeDef     depctl;
;;;1580     USB_OTG_DEPXFRSIZ_TypeDef  deptsiz;
;;;1581     USB_OTG_DSTS_TypeDef       dsts;    
;;;1582     uint32_t fifoemptymsk = 0;  
000008  2700              MOVS     r7,#0
;;;1583     
;;;1584     depctl.d32 = 0;
00000a  2000              MOVS     r0,#0
00000c  9002              STR      r0,[sp,#8]
;;;1585     deptsiz.d32 = 0;
00000e  9001              STR      r0,[sp,#4]
;;;1586     /* IN endpoint */
;;;1587     if (ep->is_in == 1)
000010  7860              LDRB     r0,[r4,#1]
000012  2801              CMP      r0,#1
000014  d17e              BNE      |L13.276|
;;;1588     {
;;;1589       depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPCTL));
000016  7821              LDRB     r1,[r4,#0]
000018  f1050018          ADD      r0,r5,#0x18
00001c  f8500021          LDR      r0,[r0,r1,LSL #2]
000020  6800              LDR      r0,[r0,#0]
000022  9002              STR      r0,[sp,#8]
;;;1590       deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPTSIZ));
000024  7821              LDRB     r1,[r4,#0]
000026  f1050018          ADD      r0,r5,#0x18
00002a  f8500021          LDR      r0,[r0,r1,LSL #2]
00002e  6900              LDR      r0,[r0,#0x10]
000030  9001              STR      r0,[sp,#4]
;;;1591       /* Zero Length Packet? */
;;;1592       if (ep->xfer_len == 0)
000032  6960              LDR      r0,[r4,#0x14]
000034  b948              CBNZ     r0,|L13.74|
;;;1593       {
;;;1594         deptsiz.b.xfersize = 0;
000036  9801              LDR      r0,[sp,#4]
000038  f36f0012          BFC      r0,#0,#19
00003c  9001              STR      r0,[sp,#4]
;;;1595         deptsiz.b.pktcnt = 1;
00003e  2101              MOVS     r1,#1
000040  9801              LDR      r0,[sp,#4]
000042  f36140dc          BFI      r0,r1,#19,#10
000046  9001              STR      r0,[sp,#4]
000048  e017              B        |L13.122|
                  |L13.74|
;;;1596       }
;;;1597       else
;;;1598       {
;;;1599         /* Program the transfer size and packet count
;;;1600         * as follows: xfersize = N * maxpacket +
;;;1601         * short_packet pktcnt = N + (short_packet
;;;1602         * exist ? 1 : 0)
;;;1603         */
;;;1604         deptsiz.b.xfersize = ep->xfer_len;
00004a  6961              LDR      r1,[r4,#0x14]
00004c  9801              LDR      r0,[sp,#4]
00004e  f3610012          BFI      r0,r1,#0,#19
000052  9001              STR      r0,[sp,#4]
;;;1605         deptsiz.b.pktcnt = (ep->xfer_len - 1 + ep->maxpacket) / ep->maxpacket;
000054  6960              LDR      r0,[r4,#0x14]
000056  1e40              SUBS     r0,r0,#1
000058  68a1              LDR      r1,[r4,#8]
00005a  4408              ADD      r0,r0,r1
00005c  fbb0f1f1          UDIV     r1,r0,r1
000060  9801              LDR      r0,[sp,#4]
000062  f36140dc          BFI      r0,r1,#19,#10
000066  9001              STR      r0,[sp,#4]
;;;1606         
;;;1607         if (ep->type == EP_TYPE_ISOC)
000068  78e0              LDRB     r0,[r4,#3]
00006a  2801              CMP      r0,#1
00006c  d105              BNE      |L13.122|
;;;1608         {
;;;1609           deptsiz.b.mc = 1;
00006e  9801              LDR      r0,[sp,#4]
000070  f02040c0          BIC      r0,r0,#0x60000000
000074  f1005000          ADD      r0,r0,#0x20000000
000078  9001              STR      r0,[sp,#4]
                  |L13.122|
;;;1610         }       
;;;1611       }
;;;1612       USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPTSIZ, deptsiz.d32);
00007a  7822              LDRB     r2,[r4,#0]
00007c  f1050018          ADD      r0,r5,#0x18
000080  f8500022          LDR      r0,[r0,r2,LSL #2]
000084  9901              LDR      r1,[sp,#4]
000086  6101              STR      r1,[r0,#0x10]
;;;1613       
;;;1614       if (pdev->cfg.dma_enable == 1)
000088  78e8              LDRB     r0,[r5,#3]
00008a  2801              CMP      r0,#1
00008c  d107              BNE      |L13.158|
;;;1615       {
;;;1616         USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPDMA, ep->dma_addr);
00008e  7822              LDRB     r2,[r4,#0]
000090  f1050018          ADD      r0,r5,#0x18
000094  f8500022          LDR      r0,[r0,r2,LSL #2]
000098  6921              LDR      r1,[r4,#0x10]
00009a  6141              STR      r1,[r0,#0x14]
00009c  e00d              B        |L13.186|
                  |L13.158|
;;;1617       }
;;;1618       else
;;;1619       {
;;;1620         if (ep->type != EP_TYPE_ISOC)
00009e  78e0              LDRB     r0,[r4,#3]
0000a0  2801              CMP      r0,#1
0000a2  d00a              BEQ      |L13.186|
;;;1621         {
;;;1622           /* Enable the Tx FIFO Empty Interrupt for this EP */
;;;1623           if (ep->xfer_len > 0)
0000a4  6960              LDR      r0,[r4,#0x14]
0000a6  b140              CBZ      r0,|L13.186|
;;;1624           {
;;;1625             fifoemptymsk = 1 << ep->num;
0000a8  7821              LDRB     r1,[r4,#0]
0000aa  2001              MOVS     r0,#1
0000ac  fa00f701          LSL      r7,r0,r1
;;;1626             USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
0000b0  6928              LDR      r0,[r5,#0x10]
0000b2  6b40              LDR      r0,[r0,#0x34]
0000b4  4338              ORRS     r0,r0,r7
0000b6  6929              LDR      r1,[r5,#0x10]
0000b8  6348              STR      r0,[r1,#0x34]
                  |L13.186|
;;;1627           }
;;;1628         }
;;;1629       }
;;;1630       
;;;1631       
;;;1632       if (ep->type == EP_TYPE_ISOC)
0000ba  78e0              LDRB     r0,[r4,#3]
0000bc  2801              CMP      r0,#1
0000be  d113              BNE      |L13.232|
;;;1633       {
;;;1634         dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
0000c0  6928              LDR      r0,[r5,#0x10]
0000c2  6880              LDR      r0,[r0,#8]
0000c4  9000              STR      r0,[sp,#0]
;;;1635         
;;;1636         if (((dsts.b.soffn)&0x1) == 0)
0000c6  9800              LDR      r0,[sp,#0]
0000c8  f3c02000          UBFX     r0,r0,#8,#1
0000cc  b930              CBNZ     r0,|L13.220|
;;;1637         {
;;;1638           depctl.b.setd1pid = 1;
0000ce  9802              LDR      r0,[sp,#8]
0000d0  f0205000          BIC      r0,r0,#0x20000000
0000d4  f1005000          ADD      r0,r0,#0x20000000
0000d8  9002              STR      r0,[sp,#8]
0000da  e005              B        |L13.232|
                  |L13.220|
;;;1639         }
;;;1640         else
;;;1641         {
;;;1642           depctl.b.setd0pid = 1;
0000dc  9802              LDR      r0,[sp,#8]
0000de  f0205080          BIC      r0,r0,#0x10000000
0000e2  f1005080          ADD      r0,r0,#0x10000000
0000e6  9002              STR      r0,[sp,#8]
                  |L13.232|
;;;1643         }
;;;1644       } 
;;;1645       
;;;1646       /* EP enable, IN data in FIFO */
;;;1647       depctl.b.cnak = 1;
0000e8  9802              LDR      r0,[sp,#8]
0000ea  f0206080          BIC      r0,r0,#0x4000000
0000ee  f1006080          ADD      r0,r0,#0x4000000
0000f2  9002              STR      r0,[sp,#8]
;;;1648       depctl.b.epena = 1;
0000f4  9802              LDR      r0,[sp,#8]
0000f6  f0204000          BIC      r0,r0,#0x80000000
0000fa  f1004000          ADD      r0,r0,#0x80000000
0000fe  9002              STR      r0,[sp,#8]
;;;1649       USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPCTL, depctl.d32);
000100  7822              LDRB     r2,[r4,#0]
000102  f1050018          ADD      r0,r5,#0x18
000106  f8500022          LDR      r0,[r0,r2,LSL #2]
00010a  9902              LDR      r1,[sp,#8]
00010c  6001              STR      r1,[r0,#0]
;;;1650       
;;;1651       if (ep->type == EP_TYPE_ISOC)
00010e  78e0              LDRB     r0,[r4,#3]
000110  2801              CMP      r0,#1
000112  e000              B        |L13.278|
                  |L13.276|
000114  e008              B        |L13.296|
                  |L13.278|
000116  d16c              BNE      |L13.498|
;;;1652       {
;;;1653         USB_OTG_WritePacket(pdev, ep->xfer_buff, ep->num, ep->xfer_len);   
000118  8aa0              LDRH     r0,[r4,#0x14]
00011a  b283              UXTH     r3,r0
00011c  7822              LDRB     r2,[r4,#0]
00011e  4628              MOV      r0,r5
000120  68e1              LDR      r1,[r4,#0xc]
000122  f7fffffe          BL       USB_OTG_WritePacket
000126  e064              B        |L13.498|
                  |L13.296|
;;;1654       }    
;;;1655     }
;;;1656     else
;;;1657     {
;;;1658       /* OUT endpoint */
;;;1659       depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL));
000128  7821              LDRB     r1,[r4,#0]
00012a  f1050054          ADD      r0,r5,#0x54
00012e  f8500021          LDR      r0,[r0,r1,LSL #2]
000132  6800              LDR      r0,[r0,#0]
000134  9002              STR      r0,[sp,#8]
;;;1660       deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ));
000136  7821              LDRB     r1,[r4,#0]
000138  f1050054          ADD      r0,r5,#0x54
00013c  f8500021          LDR      r0,[r0,r1,LSL #2]
000140  6900              LDR      r0,[r0,#0x10]
000142  9001              STR      r0,[sp,#4]
;;;1661       /* Program the transfer size and packet count as follows:
;;;1662       * pktcnt = N
;;;1663       * xfersize = N * maxpacket
;;;1664       */
;;;1665       if (ep->xfer_len == 0)
000144  6960              LDR      r0,[r4,#0x14]
000146  b950              CBNZ     r0,|L13.350|
;;;1666       {
;;;1667         deptsiz.b.xfersize = ep->maxpacket;
000148  68a1              LDR      r1,[r4,#8]
00014a  9801              LDR      r0,[sp,#4]
00014c  f3610012          BFI      r0,r1,#0,#19
000150  9001              STR      r0,[sp,#4]
;;;1668         deptsiz.b.pktcnt = 1;
000152  2101              MOVS     r1,#1
000154  9801              LDR      r0,[sp,#4]
000156  f36140dc          BFI      r0,r1,#19,#10
00015a  9001              STR      r0,[sp,#4]
00015c  e013              B        |L13.390|
                  |L13.350|
;;;1669       }
;;;1670       else
;;;1671       {
;;;1672         deptsiz.b.pktcnt = (ep->xfer_len + (ep->maxpacket - 1)) / ep->maxpacket;
00015e  68a0              LDR      r0,[r4,#8]
000160  1e40              SUBS     r0,r0,#1
000162  6961              LDR      r1,[r4,#0x14]
000164  4408              ADD      r0,r0,r1
000166  68a1              LDR      r1,[r4,#8]
000168  fbb0f1f1          UDIV     r1,r0,r1
00016c  9801              LDR      r0,[sp,#4]
00016e  f36140dc          BFI      r0,r1,#19,#10
000172  9001              STR      r0,[sp,#4]
;;;1673         deptsiz.b.xfersize = deptsiz.b.pktcnt * ep->maxpacket;
000174  9801              LDR      r0,[sp,#4]
000176  f3c040c9          UBFX     r0,r0,#19,#10
00017a  68a1              LDR      r1,[r4,#8]
00017c  4348              MULS     r0,r1,r0
00017e  9901              LDR      r1,[sp,#4]
000180  f3600112          BFI      r1,r0,#0,#19
000184  9101              STR      r1,[sp,#4]
                  |L13.390|
;;;1674       }
;;;1675       USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ, deptsiz.d32);
000186  7822              LDRB     r2,[r4,#0]
000188  f1050054          ADD      r0,r5,#0x54
00018c  f8500022          LDR      r0,[r0,r2,LSL #2]
000190  9901              LDR      r1,[sp,#4]
000192  6101              STR      r1,[r0,#0x10]
;;;1676       
;;;1677       if (pdev->cfg.dma_enable == 1)
000194  78e8              LDRB     r0,[r5,#3]
000196  2801              CMP      r0,#1
000198  d106              BNE      |L13.424|
;;;1678       {
;;;1679         USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPDMA, ep->dma_addr);
00019a  7822              LDRB     r2,[r4,#0]
00019c  f1050054          ADD      r0,r5,#0x54
0001a0  f8500022          LDR      r0,[r0,r2,LSL #2]
0001a4  6921              LDR      r1,[r4,#0x10]
0001a6  6141              STR      r1,[r0,#0x14]
                  |L13.424|
;;;1680       }
;;;1681       
;;;1682       if (ep->type == EP_TYPE_ISOC)
0001a8  78e0              LDRB     r0,[r4,#3]
0001aa  2801              CMP      r0,#1
0001ac  d10e              BNE      |L13.460|
;;;1683       {
;;;1684         if (ep->even_odd_frame)
0001ae  7960              LDRB     r0,[r4,#5]
0001b0  b130              CBZ      r0,|L13.448|
;;;1685         {
;;;1686           depctl.b.setd1pid = 1;
0001b2  9802              LDR      r0,[sp,#8]
0001b4  f0205000          BIC      r0,r0,#0x20000000
0001b8  f1005000          ADD      r0,r0,#0x20000000
0001bc  9002              STR      r0,[sp,#8]
0001be  e005              B        |L13.460|
                  |L13.448|
;;;1687         }
;;;1688         else
;;;1689         {
;;;1690           depctl.b.setd0pid = 1;
0001c0  9802              LDR      r0,[sp,#8]
0001c2  f0205080          BIC      r0,r0,#0x10000000
0001c6  f1005080          ADD      r0,r0,#0x10000000
0001ca  9002              STR      r0,[sp,#8]
                  |L13.460|
;;;1691         }
;;;1692       }
;;;1693       /* EP enable */
;;;1694       depctl.b.cnak = 1;
0001cc  9802              LDR      r0,[sp,#8]
0001ce  f0206080          BIC      r0,r0,#0x4000000
0001d2  f1006080          ADD      r0,r0,#0x4000000
0001d6  9002              STR      r0,[sp,#8]
;;;1695       depctl.b.epena = 1;
0001d8  9802              LDR      r0,[sp,#8]
0001da  f0204000          BIC      r0,r0,#0x80000000
0001de  f1004000          ADD      r0,r0,#0x80000000
0001e2  9002              STR      r0,[sp,#8]
;;;1696       USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL, depctl.d32);
0001e4  7822              LDRB     r2,[r4,#0]
0001e6  f1050054          ADD      r0,r5,#0x54
0001ea  f8500022          LDR      r0,[r0,r2,LSL #2]
0001ee  9902              LDR      r1,[sp,#8]
0001f0  6001              STR      r1,[r0,#0]
                  |L13.498|
;;;1697     }
;;;1698     return status;
0001f2  4630              MOV      r0,r6
;;;1699   }
0001f4  bdfe              POP      {r1-r7,pc}
;;;1700   
                          ENDP


                          AREA ||i.USB_OTG_EnableCommonInt||, CODE, READONLY, ALIGN=1

                  USB_OTG_EnableCommonInt PROC
;;;94     */
;;;95     static void USB_OTG_EnableCommonInt(USB_OTG_CORE_HANDLE *pdev)
000000  b508              PUSH     {r3,lr}
;;;96     {
;;;97       USB_OTG_GINTMSK_TypeDef  int_mask;
;;;98       
;;;99       int_mask.d32 = 0;
000002  2100              MOVS     r1,#0
000004  9100              STR      r1,[sp,#0]
;;;100      /* Clear any pending USB_OTG Interrupts */
;;;101    #ifndef USE_OTG_MODE
;;;102      USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GOTGINT, 0xFFFFFFFF);
000006  1e49              SUBS     r1,r1,#1
000008  68c2              LDR      r2,[r0,#0xc]
00000a  6051              STR      r1,[r2,#4]
;;;103    #endif
;;;104      /* Clear any pending interrupts */
;;;105      USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xBFFFFFFF);
00000c  f06f4180          MVN      r1,#0x40000000
000010  68c2              LDR      r2,[r0,#0xc]
000012  6151              STR      r1,[r2,#0x14]
;;;106      /* Enable the interrupts in the INTMSK */
;;;107      int_mask.b.wkupintr = 1;
000014  9900              LDR      r1,[sp,#0]
000016  f0214100          BIC      r1,r1,#0x80000000
00001a  f1014100          ADD      r1,r1,#0x80000000
00001e  9100              STR      r1,[sp,#0]
;;;108      int_mask.b.usbsuspend = 1; 
000020  9900              LDR      r1,[sp,#0]
000022  f4216100          BIC      r1,r1,#0x800
000026  f5016100          ADD      r1,r1,#0x800
00002a  9100              STR      r1,[sp,#0]
;;;109      
;;;110    #ifdef USE_OTG_MODE
;;;111      int_mask.b.otgintr = 1;
;;;112      int_mask.b.sessreqintr = 1;
;;;113      int_mask.b.conidstschng = 1;
;;;114    #endif
;;;115      USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, int_mask.d32);
00002c  9900              LDR      r1,[sp,#0]
00002e  68c2              LDR      r2,[r0,#0xc]
000030  6191              STR      r1,[r2,#0x18]
;;;116    }
000032  bd08              POP      {r3,pc}
;;;117    
                          ENDP


                          AREA ||i.USB_OTG_EnableDevInt||, CODE, READONLY, ALIGN=1

                  USB_OTG_EnableDevInt PROC
;;;1372   */
;;;1373   USB_OTG_STS USB_OTG_EnableDevInt(USB_OTG_CORE_HANDLE *pdev)
000000  b538              PUSH     {r3-r5,lr}
;;;1374   {
000002  4604              MOV      r4,r0
;;;1375     USB_OTG_STS status = USB_OTG_OK;
000004  2500              MOVS     r5,#0
;;;1376     USB_OTG_GINTMSK_TypeDef  intmsk;
;;;1377     
;;;1378     intmsk.d32 = 0;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
;;;1379     
;;;1380     /* Disable all interrupts. */
;;;1381     USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, 0);
00000a  68e1              LDR      r1,[r4,#0xc]
00000c  6188              STR      r0,[r1,#0x18]
;;;1382     /* Clear any pending interrupts */
;;;1383     USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xBFFFFFFF);
00000e  f06f4080          MVN      r0,#0x40000000
000012  68e1              LDR      r1,[r4,#0xc]
000014  6148              STR      r0,[r1,#0x14]
;;;1384     /* Enable the common interrupts */
;;;1385     USB_OTG_EnableCommonInt(pdev);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       USB_OTG_EnableCommonInt
;;;1386     
;;;1387     if (pdev->cfg.dma_enable == 0)
00001c  78e0              LDRB     r0,[r4,#3]
00001e  b920              CBNZ     r0,|L15.42|
;;;1388     {
;;;1389       intmsk.b.rxstsqlvl = 1;
000020  9800              LDR      r0,[sp,#0]
000022  f0200010          BIC      r0,r0,#0x10
000026  3010              ADDS     r0,r0,#0x10
000028  9000              STR      r0,[sp,#0]
                  |L15.42|
;;;1390     }
;;;1391     
;;;1392     /* Enable interrupts matching to the Device mode ONLY */
;;;1393     intmsk.b.usbsuspend = 1;
00002a  9800              LDR      r0,[sp,#0]
00002c  f4206000          BIC      r0,r0,#0x800
000030  f5006000          ADD      r0,r0,#0x800
000034  9000              STR      r0,[sp,#0]
;;;1394     intmsk.b.usbreset   = 1;
000036  9800              LDR      r0,[sp,#0]
000038  f4205080          BIC      r0,r0,#0x1000
00003c  f5005080          ADD      r0,r0,#0x1000
000040  9000              STR      r0,[sp,#0]
;;;1395     intmsk.b.enumdone   = 1;
000042  9800              LDR      r0,[sp,#0]
000044  f4205000          BIC      r0,r0,#0x2000
000048  f5005000          ADD      r0,r0,#0x2000
00004c  9000              STR      r0,[sp,#0]
;;;1396     intmsk.b.inepintr   = 1;
00004e  9800              LDR      r0,[sp,#0]
000050  f4202080          BIC      r0,r0,#0x40000
000054  f5002080          ADD      r0,r0,#0x40000
000058  9000              STR      r0,[sp,#0]
;;;1397     intmsk.b.outepintr  = 1;
00005a  9800              LDR      r0,[sp,#0]
00005c  f4202000          BIC      r0,r0,#0x80000
000060  f5002000          ADD      r0,r0,#0x80000
000064  9000              STR      r0,[sp,#0]
;;;1398     intmsk.b.sofintr    = 1; 
000066  9800              LDR      r0,[sp,#0]
000068  f0200008          BIC      r0,r0,#8
00006c  3008              ADDS     r0,r0,#8
00006e  9000              STR      r0,[sp,#0]
;;;1399     
;;;1400     intmsk.b.incomplisoin    = 1; 
000070  9800              LDR      r0,[sp,#0]
000072  f4201080          BIC      r0,r0,#0x100000
000076  f5001080          ADD      r0,r0,#0x100000
00007a  9000              STR      r0,[sp,#0]
;;;1401     intmsk.b.incomplisoout    = 1;   
00007c  9800              LDR      r0,[sp,#0]
00007e  f4201000          BIC      r0,r0,#0x200000
000082  f5001000          ADD      r0,r0,#0x200000
000086  9000              STR      r0,[sp,#0]
;;;1402   #ifdef VBUS_SENSING_ENABLED
;;;1403     intmsk.b.sessreqintr    = 1; 
;;;1404     intmsk.b.otgintr    = 1;    
;;;1405   #endif  
;;;1406     USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, intmsk.d32, intmsk.d32);
000088  68e0              LDR      r0,[r4,#0xc]
00008a  6980              LDR      r0,[r0,#0x18]
00008c  9900              LDR      r1,[sp,#0]
00008e  4388              BICS     r0,r0,r1
000090  4308              ORRS     r0,r0,r1
000092  68e1              LDR      r1,[r4,#0xc]
000094  6188              STR      r0,[r1,#0x18]
;;;1407     return status;
000096  4628              MOV      r0,r5
;;;1408   }
000098  bd38              POP      {r3-r5,pc}
;;;1409   
                          ENDP


                          AREA ||i.USB_OTG_EnableGlobalInt||, CODE, READONLY, ALIGN=1

                  USB_OTG_EnableGlobalInt PROC
;;;428    */
;;;429    USB_OTG_STS USB_OTG_EnableGlobalInt(USB_OTG_CORE_HANDLE *pdev)
000000  b508              PUSH     {r3,lr}
;;;430    {
000002  4601              MOV      r1,r0
;;;431      USB_OTG_STS status = USB_OTG_OK;
000004  2000              MOVS     r0,#0
;;;432      USB_OTG_GAHBCFG_TypeDef  ahbcfg;
;;;433      
;;;434      ahbcfg.d32 = 0;
000006  2200              MOVS     r2,#0
000008  9200              STR      r2,[sp,#0]
;;;435      ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
00000a  9a00              LDR      r2,[sp,#0]
00000c  f0220201          BIC      r2,r2,#1
000010  1c52              ADDS     r2,r2,#1
000012  9200              STR      r2,[sp,#0]
;;;436      USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, 0, ahbcfg.d32);
000014  68ca              LDR      r2,[r1,#0xc]
000016  6892              LDR      r2,[r2,#8]
000018  9b00              LDR      r3,[sp,#0]
00001a  431a              ORRS     r2,r2,r3
00001c  68cb              LDR      r3,[r1,#0xc]
00001e  609a              STR      r2,[r3,#8]
;;;437      return status;
;;;438    }
000020  bd08              POP      {r3,pc}
;;;439    
                          ENDP


                          AREA ||i.USB_OTG_FlushRxFifo||, CODE, READONLY, ALIGN=2

                  USB_OTG_FlushRxFifo PROC
;;;493    */
;;;494    USB_OTG_STS USB_OTG_FlushRxFifo( USB_OTG_CORE_HANDLE *pdev )
000000  b5f8              PUSH     {r3-r7,lr}
;;;495    {
000002  4604              MOV      r4,r0
;;;496      USB_OTG_STS status = USB_OTG_OK;
000004  2500              MOVS     r5,#0
;;;497      __IO USB_OTG_GRSTCTL_TypeDef  greset;
;;;498      uint32_t count = 0;
000006  2600              MOVS     r6,#0
;;;499      
;;;500      greset.d32 = 0;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;501      greset.b.rxfflsh = 1;
00000c  9800              LDR      r0,[sp,#0]
00000e  f0200010          BIC      r0,r0,#0x10
000012  3010              ADDS     r0,r0,#0x10
000014  9000              STR      r0,[sp,#0]
;;;502      USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
000016  9800              LDR      r0,[sp,#0]
000018  68e1              LDR      r1,[r4,#0xc]
00001a  6108              STR      r0,[r1,#0x10]
;;;503      do
00001c  bf00              NOP      
                  |L17.30|
;;;504      {
;;;505        greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
00001e  68e0              LDR      r0,[r4,#0xc]
000020  6900              LDR      r0,[r0,#0x10]
000022  9000              STR      r0,[sp,#0]
;;;506        if (++count > 200000)
000024  1c70              ADDS     r0,r6,#1
000026  4606              MOV      r6,r0
000028  4907              LDR      r1,|L17.72|
00002a  4288              CMP      r0,r1
00002c  d900              BLS      |L17.48|
;;;507        {
;;;508          break;
00002e  e004              B        |L17.58|
                  |L17.48|
;;;509        }
;;;510      }
;;;511      while (greset.b.rxfflsh == 1);
000030  9800              LDR      r0,[sp,#0]
000032  f3c01000          UBFX     r0,r0,#4,#1
000036  2800              CMP      r0,#0
000038  d1f1              BNE      |L17.30|
                  |L17.58|
00003a  bf00              NOP                            ;508
;;;512      /* Wait for 3 PHY Clocks*/
;;;513      USB_OTG_BSP_uDelay(3);
00003c  2003              MOVS     r0,#3
00003e  f7fffffe          BL       USB_OTG_BSP_uDelay
;;;514      return status;
000042  4628              MOV      r0,r5
;;;515    }
000044  bdf8              POP      {r3-r7,pc}
;;;516    
                          ENDP

000046  0000              DCW      0x0000
                  |L17.72|
                          DCD      0x00030d40

                          AREA ||i.USB_OTG_FlushTxFifo||, CODE, READONLY, ALIGN=2

                  USB_OTG_FlushTxFifo PROC
;;;463    */
;;;464    USB_OTG_STS USB_OTG_FlushTxFifo (USB_OTG_CORE_HANDLE *pdev , uint32_t num )
000000  b5f8              PUSH     {r3-r7,lr}
;;;465    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;466      USB_OTG_STS status = USB_OTG_OK;
000006  2600              MOVS     r6,#0
;;;467      __IO USB_OTG_GRSTCTL_TypeDef  greset;
;;;468      
;;;469      uint32_t count = 0;
000008  2700              MOVS     r7,#0
;;;470      greset.d32 = 0;
00000a  2000              MOVS     r0,#0
00000c  9000              STR      r0,[sp,#0]
;;;471      greset.b.txfflsh = 1;
00000e  9800              LDR      r0,[sp,#0]
000010  f0200020          BIC      r0,r0,#0x20
000014  3020              ADDS     r0,r0,#0x20
000016  9000              STR      r0,[sp,#0]
;;;472      greset.b.txfnum  = num;
000018  9800              LDR      r0,[sp,#0]
00001a  f365108a          BFI      r0,r5,#6,#5
00001e  9000              STR      r0,[sp,#0]
;;;473      USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
000020  9800              LDR      r0,[sp,#0]
000022  68e1              LDR      r1,[r4,#0xc]
000024  6108              STR      r0,[r1,#0x10]
;;;474      do
000026  bf00              NOP      
                  |L18.40|
;;;475      {
;;;476        greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
000028  68e0              LDR      r0,[r4,#0xc]
00002a  6900              LDR      r0,[r0,#0x10]
00002c  9000              STR      r0,[sp,#0]
;;;477        if (++count > 200000)
00002e  1c78              ADDS     r0,r7,#1
000030  4607              MOV      r7,r0
000032  4907              LDR      r1,|L18.80|
000034  4288              CMP      r0,r1
000036  d900              BLS      |L18.58|
;;;478        {
;;;479          break;
000038  e004              B        |L18.68|
                  |L18.58|
;;;480        }
;;;481      }
;;;482      while (greset.b.txfflsh == 1);
00003a  9800              LDR      r0,[sp,#0]
00003c  f3c01040          UBFX     r0,r0,#5,#1
000040  2800              CMP      r0,#0
000042  d1f1              BNE      |L18.40|
                  |L18.68|
000044  bf00              NOP                            ;479
;;;483      /* Wait for 3 PHY Clocks*/
;;;484      USB_OTG_BSP_uDelay(3);
000046  2003              MOVS     r0,#3
000048  f7fffffe          BL       USB_OTG_BSP_uDelay
;;;485      return status;
00004c  4630              MOV      r0,r6
;;;486    }
00004e  bdf8              POP      {r3-r7,pc}
;;;487    
                          ENDP

                  |L18.80|
                          DCD      0x00030d40

                          AREA ||i.USB_OTG_GetDeviceSpeed||, CODE, READONLY, ALIGN=1

                  USB_OTG_GetDeviceSpeed PROC
;;;1416   */
;;;1417   enum USB_OTG_SPEED USB_OTG_GetDeviceSpeed (USB_OTG_CORE_HANDLE *pdev)
000000  b508              PUSH     {r3,lr}
;;;1418   {
000002  4601              MOV      r1,r0
;;;1419     USB_OTG_DSTS_TypeDef  dsts;
;;;1420     enum USB_OTG_SPEED speed = USB_SPEED_UNKNOWN;
000004  2000              MOVS     r0,#0
;;;1421     
;;;1422     
;;;1423     dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
000006  690a              LDR      r2,[r1,#0x10]
000008  6892              LDR      r2,[r2,#8]
00000a  9200              STR      r2,[sp,#0]
;;;1424     
;;;1425     switch (dsts.b.enumspd)
00000c  9a00              LDR      r2,[sp,#0]
00000e  f3c20241          UBFX     r2,r2,#1,#2
000012  b132              CBZ      r2,|L19.34|
000014  2a01              CMP      r2,#1
000016  d006              BEQ      |L19.38|
000018  2a02              CMP      r2,#2
00001a  d007              BEQ      |L19.44|
00001c  2a03              CMP      r2,#3
00001e  d107              BNE      |L19.48|
000020  e002              B        |L19.40|
                  |L19.34|
;;;1426     {
;;;1427     case DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ:
;;;1428       speed = USB_SPEED_HIGH;
000022  2003              MOVS     r0,#3
;;;1429       break;
000024  e004              B        |L19.48|
                  |L19.38|
;;;1430     case DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ:
;;;1431     case DSTS_ENUMSPD_FS_PHY_48MHZ:
000026  bf00              NOP      
                  |L19.40|
;;;1432       speed = USB_SPEED_FULL;
000028  2002              MOVS     r0,#2
;;;1433       break;
00002a  e001              B        |L19.48|
                  |L19.44|
;;;1434       
;;;1435     case DSTS_ENUMSPD_LS_PHY_6MHZ:
;;;1436       speed = USB_SPEED_LOW;
00002c  2001              MOVS     r0,#1
;;;1437       break;
00002e  bf00              NOP      
                  |L19.48|
000030  bf00              NOP                            ;1429
;;;1438     }
;;;1439     
;;;1440     return speed;
;;;1441   }
000032  bd08              POP      {r3,pc}
;;;1442   /**
                          ENDP


                          AREA ||i.USB_OTG_GetEPStatus||, CODE, READONLY, ALIGN=1

                  USB_OTG_GetEPStatus PROC
;;;2040   
;;;2041   uint32_t USB_OTG_GetEPStatus(USB_OTG_CORE_HANDLE *pdev ,USB_OTG_EP *ep)
000000  b538              PUSH     {r3-r5,lr}
;;;2042   {
000002  4603              MOV      r3,r0
;;;2043     USB_OTG_DEPCTL_TypeDef  depctl;
;;;2044     __IO uint32_t *depctl_addr;
;;;2045     uint32_t Status = 0;  
000004  2000              MOVS     r0,#0
;;;2046     
;;;2047     depctl.d32 = 0;
000006  2400              MOVS     r4,#0
000008  9400              STR      r4,[sp,#0]
;;;2048     if (ep->is_in == 1)
00000a  784c              LDRB     r4,[r1,#1]
00000c  2c01              CMP      r4,#1
00000e  d114              BNE      |L20.58|
;;;2049     {
;;;2050       depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
000010  780d              LDRB     r5,[r1,#0]
000012  f1030418          ADD      r4,r3,#0x18
000016  f8542025          LDR      r2,[r4,r5,LSL #2]
;;;2051       depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
00001a  6814              LDR      r4,[r2,#0]
00001c  9400              STR      r4,[sp,#0]
;;;2052       
;;;2053       if (depctl.b.stall == 1)  
00001e  9c00              LDR      r4,[sp,#0]
000020  f3c45440          UBFX     r4,r4,#21,#1
000024  b10c              CBZ      r4,|L20.42|
;;;2054         Status = USB_OTG_EP_TX_STALL;
000026  2010              MOVS     r0,#0x10
000028  e01e              B        |L20.104|
                  |L20.42|
;;;2055       else if (depctl.b.naksts == 1)
00002a  9c00              LDR      r4,[sp,#0]
00002c  f3c44440          UBFX     r4,r4,#17,#1
000030  b10c              CBZ      r4,|L20.54|
;;;2056         Status = USB_OTG_EP_TX_NAK;
000032  2020              MOVS     r0,#0x20
000034  e018              B        |L20.104|
                  |L20.54|
;;;2057       else 
;;;2058         Status = USB_OTG_EP_TX_VALID;     
000036  2030              MOVS     r0,#0x30
000038  e016              B        |L20.104|
                  |L20.58|
;;;2059       
;;;2060     }
;;;2061     else
;;;2062     {
;;;2063       depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
00003a  780d              LDRB     r5,[r1,#0]
00003c  f1030454          ADD      r4,r3,#0x54
000040  f8542025          LDR      r2,[r4,r5,LSL #2]
;;;2064       depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
000044  6814              LDR      r4,[r2,#0]
000046  9400              STR      r4,[sp,#0]
;;;2065       if (depctl.b.stall == 1)  
000048  9c00              LDR      r4,[sp,#0]
00004a  f3c45440          UBFX     r4,r4,#21,#1
00004e  b114              CBZ      r4,|L20.86|
;;;2066         Status = USB_OTG_EP_RX_STALL;
000050  f44f5080          MOV      r0,#0x1000
000054  e008              B        |L20.104|
                  |L20.86|
;;;2067       else if (depctl.b.naksts == 1)
000056  9c00              LDR      r4,[sp,#0]
000058  f3c44440          UBFX     r4,r4,#17,#1
00005c  b114              CBZ      r4,|L20.100|
;;;2068         Status = USB_OTG_EP_RX_NAK;
00005e  f44f5000          MOV      r0,#0x2000
000062  e001              B        |L20.104|
                  |L20.100|
;;;2069       else 
;;;2070         Status = USB_OTG_EP_RX_VALID; 
000064  f44f5040          MOV      r0,#0x3000
                  |L20.104|
;;;2071     } 
;;;2072     
;;;2073     /* Return the current status */
;;;2074     return Status;
;;;2075   }
000068  bd38              POP      {r3-r5,pc}
;;;2076   
                          ENDP


                          AREA ||i.USB_OTG_GetMode||, CODE, READONLY, ALIGN=1

                  USB_OTG_GetMode PROC
;;;553    */
;;;554    uint32_t USB_OTG_GetMode(USB_OTG_CORE_HANDLE *pdev)
000000  4601              MOV      r1,r0
;;;555    {
;;;556      return (USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS ) & 0x1);
000002  68c8              LDR      r0,[r1,#0xc]
000004  6940              LDR      r0,[r0,#0x14]
000006  f0000001          AND      r0,r0,#1
;;;557    }
00000a  4770              BX       lr
;;;558    
                          ENDP


                          AREA ||i.USB_OTG_InitDevSpeed||, CODE, READONLY, ALIGN=1

                  USB_OTG_InitDevSpeed PROC
;;;1177   */
;;;1178   void USB_OTG_InitDevSpeed(USB_OTG_CORE_HANDLE *pdev , uint8_t speed)
000000  b508              PUSH     {r3,lr}
;;;1179   {
;;;1180     USB_OTG_DCFG_TypeDef   dcfg;
;;;1181     
;;;1182     dcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCFG);
000002  6902              LDR      r2,[r0,#0x10]
000004  6812              LDR      r2,[r2,#0]
000006  9200              STR      r2,[sp,#0]
;;;1183     dcfg.b.devspd = speed;
000008  9a00              LDR      r2,[sp,#0]
00000a  f3610201          BFI      r2,r1,#0,#2
00000e  9200              STR      r2,[sp,#0]
;;;1184     USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCFG, dcfg.d32);
000010  9b00              LDR      r3,[sp,#0]
000012  6902              LDR      r2,[r0,#0x10]
000014  6013              STR      r3,[r2,#0]
;;;1185   }
000016  bd08              POP      {r3,pc}
;;;1186   
                          ENDP


                          AREA ||i.USB_OTG_IsDeviceMode||, CODE, READONLY, ALIGN=1

                  USB_OTG_IsDeviceMode PROC
;;;564    */
;;;565    uint8_t USB_OTG_IsDeviceMode(USB_OTG_CORE_HANDLE *pdev)
000000  b500              PUSH     {lr}
;;;566    {
000002  4602              MOV      r2,r0
;;;567      return (USB_OTG_GetMode(pdev) != HOST_MODE);
000004  4610              MOV      r0,r2
000006  f7fffffe          BL       USB_OTG_GetMode
00000a  2801              CMP      r0,#1
00000c  d001              BEQ      |L23.18|
00000e  2001              MOVS     r0,#1
                  |L23.16|
;;;568    }
000010  bd00              POP      {pc}
                  |L23.18|
000012  2000              MOVS     r0,#0                 ;567
000014  e7fc              B        |L23.16|
;;;569    
                          ENDP


                          AREA ||i.USB_OTG_IsHostMode||, CODE, READONLY, ALIGN=1

                  USB_OTG_IsHostMode PROC
;;;575    */
;;;576    uint8_t USB_OTG_IsHostMode(USB_OTG_CORE_HANDLE *pdev)
000000  b500              PUSH     {lr}
;;;577    {
000002  4602              MOV      r2,r0
;;;578      return (USB_OTG_GetMode(pdev) == HOST_MODE);
000004  4610              MOV      r0,r2
000006  f7fffffe          BL       USB_OTG_GetMode
00000a  2801              CMP      r0,#1
00000c  d100              BNE      |L24.16|
                  |L24.14|
;;;579    }
00000e  bd00              POP      {pc}
                  |L24.16|
000010  2000              MOVS     r0,#0                 ;578
000012  e7fc              B        |L24.14|
;;;580    
                          ENDP


                          AREA ||i.USB_OTG_ReadCoreItr||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadCoreItr PROC
;;;586    */
;;;587    uint32_t USB_OTG_ReadCoreItr(USB_OTG_CORE_HANDLE *pdev)
000000  4601              MOV      r1,r0
;;;588    {
;;;589      uint32_t v = 0;
000002  2000              MOVS     r0,#0
;;;590      v = USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS);
000004  68ca              LDR      r2,[r1,#0xc]
000006  6950              LDR      r0,[r2,#0x14]
;;;591      v &= USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTMSK);
000008  68ca              LDR      r2,[r1,#0xc]
00000a  6992              LDR      r2,[r2,#0x18]
00000c  4010              ANDS     r0,r0,r2
;;;592      return v;
;;;593    }
00000e  4770              BX       lr
;;;594    
                          ENDP


                          AREA ||i.USB_OTG_ReadDevAllInEPItr||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadDevAllInEPItr PROC
;;;1906   */
;;;1907   uint32_t USB_OTG_ReadDevAllInEPItr(USB_OTG_CORE_HANDLE *pdev)
000000  4601              MOV      r1,r0
;;;1908   {
;;;1909     uint32_t v;
;;;1910     v = USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINT);
000002  6908              LDR      r0,[r1,#0x10]
000004  6982              LDR      r2,[r0,#0x18]
;;;1911     v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINTMSK);
000006  6908              LDR      r0,[r1,#0x10]
000008  69c0              LDR      r0,[r0,#0x1c]
00000a  4002              ANDS     r2,r2,r0
;;;1912     return (v & 0xffff);
00000c  b290              UXTH     r0,r2
;;;1913   }
00000e  4770              BX       lr
;;;1914   
                          ENDP


                          AREA ||i.USB_OTG_ReadDevAllOutEp_itr||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadDevAllOutEp_itr PROC
;;;1877   */
;;;1878   uint32_t USB_OTG_ReadDevAllOutEp_itr(USB_OTG_CORE_HANDLE *pdev)
000000  4601              MOV      r1,r0
;;;1879   {
;;;1880     uint32_t v;
;;;1881     v  = USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINT);
000002  6908              LDR      r0,[r1,#0x10]
000004  6982              LDR      r2,[r0,#0x18]
;;;1882     v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINTMSK);
000006  6908              LDR      r0,[r1,#0x10]
000008  69c0              LDR      r0,[r0,#0x1c]
00000a  4002              ANDS     r2,r2,r0
;;;1883     return ((v & 0xffff0000) >> 16);
00000c  0c10              LSRS     r0,r2,#16
;;;1884   }
00000e  4770              BX       lr
;;;1885   
                          ENDP


                          AREA ||i.USB_OTG_ReadDevOutEP_itr||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadDevOutEP_itr PROC
;;;1892   */
;;;1893   uint32_t USB_OTG_ReadDevOutEP_itr(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
000000  4602              MOV      r2,r0
;;;1894   {
;;;1895     uint32_t v;
;;;1896     v  = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[epnum]->DOEPINT);
000002  f1020354          ADD      r3,r2,#0x54
000006  f8533021          LDR      r3,[r3,r1,LSL #2]
00000a  6898              LDR      r0,[r3,#8]
;;;1897     v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DOEPMSK);
00000c  6913              LDR      r3,[r2,#0x10]
00000e  695b              LDR      r3,[r3,#0x14]
000010  4018              ANDS     r0,r0,r3
;;;1898     return v;
;;;1899   }
000012  4770              BX       lr
;;;1900   
                          ENDP


                          AREA ||i.USB_OTG_ReadOtgItr||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadOtgItr PROC
;;;600    */
;;;601    uint32_t USB_OTG_ReadOtgItr (USB_OTG_CORE_HANDLE *pdev)
000000  4601              MOV      r1,r0
;;;602    {
;;;603      return (USB_OTG_READ_REG32 (&pdev->regs.GREGS->GOTGINT));
000002  68c8              LDR      r0,[r1,#0xc]
000004  6840              LDR      r0,[r0,#4]
;;;604    }
000006  4770              BX       lr
;;;605    
                          ENDP


                          AREA ||i.USB_OTG_ReadPacket||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadPacket PROC
;;;196    */
;;;197    void *USB_OTG_ReadPacket(USB_OTG_CORE_HANDLE *pdev, 
000000  b5f0              PUSH     {r4-r7,lr}
;;;198                             uint8_t *dest, 
;;;199                             uint16_t len)
;;;200    {
000002  4603              MOV      r3,r0
;;;201      uint32_t i=0;
000004  2400              MOVS     r4,#0
;;;202      uint32_t count32b = (len + 3) / 4;
000006  1cd0              ADDS     r0,r2,#3
000008  17c7              ASRS     r7,r0,#31
00000a  eb007797          ADD      r7,r0,r7,LSR #30
00000e  10bd              ASRS     r5,r7,#2
;;;203      
;;;204      __IO uint32_t *fifo = pdev->regs.DFIFO[0];
000010  f8d360d0          LDR      r6,[r3,#0xd0]
;;;205      
;;;206      for ( i = 0; i < count32b; i++, dest += 4 )
000014  bf00              NOP      
000016  e003              B        |L30.32|
                  |L30.24|
;;;207      {
;;;208        *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
000018  6830              LDR      r0,[r6,#0]
00001a  6008              STR      r0,[r1,#0]
00001c  1c64              ADDS     r4,r4,#1              ;206
00001e  1d09              ADDS     r1,r1,#4              ;206
                  |L30.32|
000020  42ac              CMP      r4,r5                 ;206
000022  d3f9              BCC      |L30.24|
;;;209        
;;;210      }
;;;211      return ((void *)dest);
000024  4608              MOV      r0,r1
;;;212    }
000026  bdf0              POP      {r4-r7,pc}
;;;213    
                          ENDP


                          AREA ||i.USB_OTG_SelectCore||, CODE, READONLY, ALIGN=2

                  USB_OTG_SelectCore PROC
;;;220    */
;;;221    USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
000000  b570              PUSH     {r4-r6,lr}
;;;222                                   USB_OTG_CORE_ID_TypeDef coreID)
;;;223    {
000002  4602              MOV      r2,r0
000004  460c              MOV      r4,r1
;;;224      uint32_t i , baseAddress = 0;
000006  2300              MOVS     r3,#0
;;;225      USB_OTG_STS status = USB_OTG_OK;
000008  2000              MOVS     r0,#0
;;;226      
;;;227      pdev->cfg.dma_enable       = 0;
00000a  2500              MOVS     r5,#0
00000c  70d5              STRB     r5,[r2,#3]
;;;228      
;;;229      /* at startup the core is in FS mode */
;;;230      pdev->cfg.speed            = USB_OTG_SPEED_FULL;
00000e  2501              MOVS     r5,#1
000010  7095              STRB     r5,[r2,#2]
;;;231      pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;    
000012  2540              MOVS     r5,#0x40
000014  8095              STRH     r5,[r2,#4]
;;;232      
;;;233      /* initialize device cfg following its address */
;;;234      if (coreID == USB_OTG_FS_CORE_ID)
000016  2c01              CMP      r4,#1
000018  d10c              BNE      |L31.52|
;;;235      {
;;;236        baseAddress                = USB_OTG_FS_BASE_ADDR;
00001a  f04f43a0          MOV      r3,#0x50000000
;;;237        pdev->cfg.coreID           = USB_OTG_FS_CORE_ID;
00001e  2501              MOVS     r5,#1
000020  72d5              STRB     r5,[r2,#0xb]
;;;238        pdev->cfg.host_channels    = 8 ;
000022  2508              MOVS     r5,#8
000024  7015              STRB     r5,[r2,#0]
;;;239        pdev->cfg.dev_endpoints    = 4 ;
000026  2504              MOVS     r5,#4
000028  7055              STRB     r5,[r2,#1]
;;;240        pdev->cfg.TotalFifoSize    = 320; /* in 32-bits */
00002a  159d              ASRS     r5,r3,#22
00002c  80d5              STRH     r5,[r2,#6]
;;;241        pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;     
00002e  2502              MOVS     r5,#2
000030  7215              STRB     r5,[r2,#8]
000032  e00a              B        |L31.74|
                  |L31.52|
;;;242        
;;;243    #ifdef USB_OTG_FS_SOF_OUTPUT_ENABLED    
;;;244        pdev->cfg.Sof_output       = 1;    
;;;245    #endif 
;;;246        
;;;247    #ifdef USB_OTG_FS_LOW_PWR_MGMT_SUPPORT    
;;;248        pdev->cfg.low_power        = 1;    
;;;249    #endif     
;;;250      }
;;;251      else if (coreID == USB_OTG_HS_CORE_ID)
000034  b94c              CBNZ     r4,|L31.74|
;;;252      {
;;;253        baseAddress                = USB_OTG_HS_BASE_ADDR;
000036  4b25              LDR      r3,|L31.204|
;;;254        pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
000038  2500              MOVS     r5,#0
00003a  72d5              STRB     r5,[r2,#0xb]
;;;255        pdev->cfg.host_channels    = 12 ;
00003c  250c              MOVS     r5,#0xc
00003e  7015              STRB     r5,[r2,#0]
;;;256        pdev->cfg.dev_endpoints    = 6 ;
000040  2506              MOVS     r5,#6
000042  7055              STRB     r5,[r2,#1]
;;;257        pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
000044  f44f65a0          MOV      r5,#0x500
000048  80d5              STRH     r5,[r2,#6]
                  |L31.74|
;;;258        
;;;259    #ifdef USB_OTG_ULPI_PHY_ENABLED
;;;260        pdev->cfg.phy_itface       = USB_OTG_ULPI_PHY;
;;;261    #else    
;;;262    #ifdef USB_OTG_EMBEDDED_PHY_ENABLED
;;;263        pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;
;;;264    #endif  
;;;265    #endif      
;;;266        
;;;267    #ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED    
;;;268        pdev->cfg.dma_enable       = 1;    
;;;269    #endif
;;;270        
;;;271    #ifdef USB_OTG_HS_SOF_OUTPUT_ENABLED    
;;;272        pdev->cfg.Sof_output       = 1;    
;;;273    #endif 
;;;274        
;;;275    #ifdef USB_OTG_HS_LOW_PWR_MGMT_SUPPORT    
;;;276        pdev->cfg.low_power        = 1;    
;;;277    #endif 
;;;278        
;;;279      }
;;;280      
;;;281      pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
00004a  60d3              STR      r3,[r2,#0xc]
;;;282        USB_OTG_CORE_GLOBAL_REGS_OFFSET);
;;;283      pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
00004c  f5036500          ADD      r5,r3,#0x800
000050  6115              STR      r5,[r2,#0x10]
;;;284        USB_OTG_DEV_GLOBAL_REG_OFFSET);
;;;285      
;;;286      for (i = 0; i < pdev->cfg.dev_endpoints; i++)
000052  2100              MOVS     r1,#0
000054  e010              B        |L31.120|
                  |L31.86|
;;;287      {
;;;288        pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
000056  f5036510          ADD      r5,r3,#0x900
00005a  eb051641          ADD      r6,r5,r1,LSL #5
00005e  f1020518          ADD      r5,r2,#0x18
000062  f8456021          STR      r6,[r5,r1,LSL #2]
;;;289          (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
;;;290            (i * USB_OTG_EP_REG_OFFSET));
;;;291        pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
000066  f5036530          ADD      r5,r3,#0xb00
00006a  eb051641          ADD      r6,r5,r1,LSL #5
00006e  f1020554          ADD      r5,r2,#0x54
000072  f8456021          STR      r6,[r5,r1,LSL #2]
000076  1c49              ADDS     r1,r1,#1              ;286
                  |L31.120|
000078  7855              LDRB     r5,[r2,#1]            ;286
00007a  428d              CMP      r5,r1                 ;286
00007c  d8eb              BHI      |L31.86|
;;;292          (baseAddress + USB_OTG_DEV_OUT_EP_REG_OFFSET + \
;;;293            (i * USB_OTG_EP_REG_OFFSET));
;;;294      }
;;;295      pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
00007e  f5036580          ADD      r5,r3,#0x400
000082  6155              STR      r5,[r2,#0x14]
;;;296        USB_OTG_HOST_GLOBAL_REG_OFFSET);
;;;297      pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
000084  3540              ADDS     r5,r5,#0x40
000086  f8c250cc          STR      r5,[r2,#0xcc]
;;;298      
;;;299      for (i = 0; i < pdev->cfg.host_channels; i++)
00008a  2100              MOVS     r1,#0
00008c  e008              B        |L31.160|
                  |L31.142|
;;;300      {
;;;301        pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
00008e  f50365a0          ADD      r5,r3,#0x500
000092  eb051641          ADD      r6,r5,r1,LSL #5
000096  f1020590          ADD      r5,r2,#0x90
00009a  f8456021          STR      r6,[r5,r1,LSL #2]
00009e  1c49              ADDS     r1,r1,#1              ;299
                  |L31.160|
0000a0  7815              LDRB     r5,[r2,#0]            ;299
0000a2  428d              CMP      r5,r1                 ;299
0000a4  d8f3              BHI      |L31.142|
;;;302          USB_OTG_HOST_CHAN_REGS_OFFSET + \
;;;303            (i * USB_OTG_CHAN_REGS_OFFSET));
;;;304      }
;;;305      for (i = 0; i < pdev->cfg.host_channels; i++)
0000a6  2100              MOVS     r1,#0
0000a8  e008              B        |L31.188|
                  |L31.170|
;;;306      {
;;;307        pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
0000aa  f5035580          ADD      r5,r3,#0x1000
0000ae  eb053601          ADD      r6,r5,r1,LSL #12
0000b2  f10205d0          ADD      r5,r2,#0xd0
0000b6  f8456021          STR      r6,[r5,r1,LSL #2]
0000ba  1c49              ADDS     r1,r1,#1              ;305
                  |L31.188|
0000bc  7815              LDRB     r5,[r2,#0]            ;305
0000be  428d              CMP      r5,r1                 ;305
0000c0  d8f3              BHI      |L31.170|
;;;308          (i * USB_OTG_DATA_FIFO_SIZE));
;;;309      }
;;;310      pdev->regs.PCGCCTL = (uint32_t *)(baseAddress + USB_OTG_PCGCCTL_OFFSET);
0000c2  f5036560          ADD      r5,r3,#0xe00
0000c6  f8c2510c          STR      r5,[r2,#0x10c]
;;;311      
;;;312      return status;
;;;313    }
0000ca  bd70              POP      {r4-r6,pc}
;;;314    
                          ENDP

                  |L31.204|
                          DCD      0x40040000

                          AREA ||i.USB_OTG_SetCurrentMode||, CODE, READONLY, ALIGN=1

                  USB_OTG_SetCurrentMode PROC
;;;523    */
;;;524    USB_OTG_STS USB_OTG_SetCurrentMode(USB_OTG_CORE_HANDLE *pdev , uint8_t mode)
000000  b5f8              PUSH     {r3-r7,lr}
;;;525    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;526      USB_OTG_STS status = USB_OTG_OK;
000006  2600              MOVS     r6,#0
;;;527      USB_OTG_GUSBCFG_TypeDef  usbcfg;
;;;528      
;;;529      usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
000008  68e0              LDR      r0,[r4,#0xc]
00000a  68c0              LDR      r0,[r0,#0xc]
00000c  9000              STR      r0,[sp,#0]
;;;530      
;;;531      usbcfg.b.force_host = 0;
00000e  9800              LDR      r0,[sp,#0]
000010  f0205000          BIC      r0,r0,#0x20000000
000014  9000              STR      r0,[sp,#0]
;;;532      usbcfg.b.force_dev = 0;
000016  9800              LDR      r0,[sp,#0]
000018  f0204080          BIC      r0,r0,#0x40000000
00001c  9000              STR      r0,[sp,#0]
;;;533      
;;;534      if ( mode == HOST_MODE)
00001e  2d01              CMP      r5,#1
000020  d106              BNE      |L32.48|
;;;535      {
;;;536        usbcfg.b.force_host = 1;
000022  9800              LDR      r0,[sp,#0]
000024  f0205000          BIC      r0,r0,#0x20000000
000028  f1005000          ADD      r0,r0,#0x20000000
00002c  9000              STR      r0,[sp,#0]
00002e  e006              B        |L32.62|
                  |L32.48|
;;;537      }
;;;538      else if ( mode == DEVICE_MODE)
000030  b92d              CBNZ     r5,|L32.62|
;;;539      {
;;;540        usbcfg.b.force_dev = 1;
000032  9800              LDR      r0,[sp,#0]
000034  f0204080          BIC      r0,r0,#0x40000000
000038  f1004080          ADD      r0,r0,#0x40000000
00003c  9000              STR      r0,[sp,#0]
                  |L32.62|
;;;541      }
;;;542      
;;;543      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
00003e  9800              LDR      r0,[sp,#0]
000040  68e1              LDR      r1,[r4,#0xc]
000042  60c8              STR      r0,[r1,#0xc]
;;;544      USB_OTG_BSP_mDelay(50);
000044  2032              MOVS     r0,#0x32
000046  f7fffffe          BL       USB_OTG_BSP_mDelay
;;;545      return status;
00004a  4630              MOV      r0,r6
;;;546    }
00004c  bdf8              POP      {r3-r7,pc}
;;;547    
                          ENDP


                          AREA ||i.USB_OTG_SetEPStatus||, CODE, READONLY, ALIGN=1

                  USB_OTG_SetEPStatus PROC
;;;2083   */
;;;2084   void USB_OTG_SetEPStatus (USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep , uint32_t Status)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2085   {
000002  4607              MOV      r7,r0
000004  460d              MOV      r5,r1
000006  4614              MOV      r4,r2
;;;2086     USB_OTG_DEPCTL_TypeDef  depctl;
;;;2087     __IO uint32_t *depctl_addr;
;;;2088     
;;;2089     depctl.d32 = 0;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;2090     
;;;2091     /* Process for IN endpoint */
;;;2092     if (ep->is_in == 1)
00000c  7868              LDRB     r0,[r5,#1]
00000e  2801              CMP      r0,#1
000010  d13c              BNE      |L33.140|
;;;2093     {
;;;2094       depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
000012  7829              LDRB     r1,[r5,#0]
000014  f1070018          ADD      r0,r7,#0x18
000018  f8506021          LDR      r6,[r0,r1,LSL #2]
;;;2095       depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
00001c  6830              LDR      r0,[r6,#0]
00001e  9000              STR      r0,[sp,#0]
;;;2096       
;;;2097       if (Status == USB_OTG_EP_TX_STALL)  
000020  2c10              CMP      r4,#0x10
000022  d104              BNE      |L33.46|
;;;2098       {
;;;2099         USB_OTG_EPSetStall(pdev, ep); return;
000024  4629              MOV      r1,r5
000026  4638              MOV      r0,r7
000028  f7fffffe          BL       USB_OTG_EPSetStall
                  |L33.44|
;;;2100       }
;;;2101       else if (Status == USB_OTG_EP_TX_NAK)
;;;2102         depctl.b.snak = 1;
;;;2103       else if (Status == USB_OTG_EP_TX_VALID)
;;;2104       {
;;;2105         if (depctl.b.stall == 1)
;;;2106         {  
;;;2107           ep->even_odd_frame = 0;
;;;2108           USB_OTG_EPClearStall(pdev, ep);
;;;2109           return;
;;;2110         }      
;;;2111         depctl.b.cnak = 1;
;;;2112         depctl.b.usbactep = 1; 
;;;2113         depctl.b.epena = 1;
;;;2114       }
;;;2115       else if (Status == USB_OTG_EP_TX_DIS)
;;;2116         depctl.b.usbactep = 0;
;;;2117     } 
;;;2118     else /* Process for OUT endpoint */
;;;2119     {
;;;2120       depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
;;;2121       depctl.d32 = USB_OTG_READ_REG32(depctl_addr);    
;;;2122       
;;;2123       if (Status == USB_OTG_EP_RX_STALL)  {
;;;2124         depctl.b.stall = 1;
;;;2125       }
;;;2126       else if (Status == USB_OTG_EP_RX_NAK)
;;;2127         depctl.b.snak = 1;
;;;2128       else if (Status == USB_OTG_EP_RX_VALID)
;;;2129       {
;;;2130         if (depctl.b.stall == 1)
;;;2131         {  
;;;2132           ep->even_odd_frame = 0;
;;;2133           USB_OTG_EPClearStall(pdev, ep);
;;;2134           return;
;;;2135         }  
;;;2136         depctl.b.cnak = 1;
;;;2137         depctl.b.usbactep = 1;    
;;;2138         depctl.b.epena = 1;
;;;2139       }
;;;2140       else if (Status == USB_OTG_EP_RX_DIS)
;;;2141       {
;;;2142         depctl.b.usbactep = 0;    
;;;2143       }
;;;2144     }
;;;2145     
;;;2146     USB_OTG_WRITE_REG32(depctl_addr, depctl.d32); 
;;;2147   }
00002c  bdf8              POP      {r3-r7,pc}
                  |L33.46|
00002e  2c20              CMP      r4,#0x20              ;2101
000030  d106              BNE      |L33.64|
000032  9800              LDR      r0,[sp,#0]            ;2102
000034  f0206000          BIC      r0,r0,#0x8000000      ;2102
000038  f1006000          ADD      r0,r0,#0x8000000      ;2102
00003c  9000              STR      r0,[sp,#0]            ;2102
00003e  e068              B        |L33.274|
                  |L33.64|
000040  2c30              CMP      r4,#0x30              ;2103
000042  d11d              BNE      |L33.128|
000044  9800              LDR      r0,[sp,#0]            ;2105
000046  f3c05040          UBFX     r0,r0,#21,#1          ;2105
00004a  b130              CBZ      r0,|L33.90|
00004c  2000              MOVS     r0,#0                 ;2107
00004e  7168              STRB     r0,[r5,#5]            ;2107
000050  4629              MOV      r1,r5                 ;2108
000052  4638              MOV      r0,r7                 ;2108
000054  f7fffffe          BL       USB_OTG_EPClearStall
000058  e7e8              B        |L33.44|
                  |L33.90|
00005a  9800              LDR      r0,[sp,#0]            ;2111
00005c  f0206080          BIC      r0,r0,#0x4000000      ;2111
000060  f1006080          ADD      r0,r0,#0x4000000      ;2111
000064  9000              STR      r0,[sp,#0]            ;2111
000066  9800              LDR      r0,[sp,#0]            ;2112
000068  f4204000          BIC      r0,r0,#0x8000         ;2112
00006c  f5004000          ADD      r0,r0,#0x8000         ;2112
000070  9000              STR      r0,[sp,#0]            ;2112
000072  9800              LDR      r0,[sp,#0]            ;2113
000074  f0204000          BIC      r0,r0,#0x80000000     ;2113
000078  f1004000          ADD      r0,r0,#0x80000000     ;2113
00007c  9000              STR      r0,[sp,#0]            ;2113
00007e  e048              B        |L33.274|
                  |L33.128|
000080  bbec              CBNZ     r4,|L33.254|
000082  9800              LDR      r0,[sp,#0]            ;2116
000084  f4204000          BIC      r0,r0,#0x8000         ;2116
000088  9000              STR      r0,[sp,#0]            ;2116
00008a  e042              B        |L33.274|
                  |L33.140|
00008c  7829              LDRB     r1,[r5,#0]            ;2120
00008e  f1070054          ADD      r0,r7,#0x54           ;2120
000092  f8506021          LDR      r6,[r0,r1,LSL #2]     ;2120
000096  6830              LDR      r0,[r6,#0]            ;2121
000098  9000              STR      r0,[sp,#0]            ;2121
00009a  f5b45f80          CMP      r4,#0x1000            ;2123
00009e  d106              BNE      |L33.174|
0000a0  9800              LDR      r0,[sp,#0]            ;2124
0000a2  f4201000          BIC      r0,r0,#0x200000       ;2124
0000a6  f5001000          ADD      r0,r0,#0x200000       ;2124
0000aa  9000              STR      r0,[sp,#0]            ;2124
0000ac  e031              B        |L33.274|
                  |L33.174|
0000ae  f5b45f00          CMP      r4,#0x2000            ;2126
0000b2  d106              BNE      |L33.194|
0000b4  9800              LDR      r0,[sp,#0]            ;2127
0000b6  f0206000          BIC      r0,r0,#0x8000000      ;2127
0000ba  f1006000          ADD      r0,r0,#0x8000000      ;2127
0000be  9000              STR      r0,[sp,#0]            ;2127
0000c0  e027              B        |L33.274|
                  |L33.194|
0000c2  f5b45f40          CMP      r4,#0x3000            ;2128
0000c6  d11f              BNE      |L33.264|
0000c8  9800              LDR      r0,[sp,#0]            ;2130
0000ca  f3c05040          UBFX     r0,r0,#21,#1          ;2130
0000ce  b130              CBZ      r0,|L33.222|
0000d0  2000              MOVS     r0,#0                 ;2132
0000d2  7168              STRB     r0,[r5,#5]            ;2132
0000d4  4629              MOV      r1,r5                 ;2133
0000d6  4638              MOV      r0,r7                 ;2133
0000d8  f7fffffe          BL       USB_OTG_EPClearStall
0000dc  e7a6              B        |L33.44|
                  |L33.222|
0000de  9800              LDR      r0,[sp,#0]            ;2136
0000e0  f0206080          BIC      r0,r0,#0x4000000      ;2136
0000e4  f1006080          ADD      r0,r0,#0x4000000      ;2136
0000e8  9000              STR      r0,[sp,#0]            ;2136
0000ea  9800              LDR      r0,[sp,#0]            ;2137
0000ec  f4204000          BIC      r0,r0,#0x8000         ;2137
0000f0  f5004000          ADD      r0,r0,#0x8000         ;2137
0000f4  9000              STR      r0,[sp,#0]            ;2137
0000f6  9800              LDR      r0,[sp,#0]            ;2138
0000f8  f0204000          BIC      r0,r0,#0x80000000     ;2138
0000fc  e000              B        |L33.256|
                  |L33.254|
0000fe  e008              B        |L33.274|
                  |L33.256|
000100  f1004000          ADD      r0,r0,#0x80000000     ;2138
000104  9000              STR      r0,[sp,#0]            ;2138
000106  e004              B        |L33.274|
                  |L33.264|
000108  b91c              CBNZ     r4,|L33.274|
00010a  9800              LDR      r0,[sp,#0]            ;2142
00010c  f4204000          BIC      r0,r0,#0x8000         ;2142
000110  9000              STR      r0,[sp,#0]            ;2142
                  |L33.274|
000112  9800              LDR      r0,[sp,#0]            ;2146
000114  6030              STR      r0,[r6,#0]            ;2146
000116  bf00              NOP      
000118  e788              B        |L33.44|
;;;2148   
                          ENDP


                          AREA ||i.USB_OTG_StopDevice||, CODE, READONLY, ALIGN=1

                  USB_OTG_StopDevice PROC
;;;2011   */
;;;2012   void USB_OTG_StopDevice(USB_OTG_CORE_HANDLE *pdev)
000000  b570              PUSH     {r4-r6,lr}
;;;2013   {
000002  4604              MOV      r4,r0
;;;2014     uint32_t i;
;;;2015     
;;;2016     pdev->dev.device_status = 1;
000004  2101              MOVS     r1,#1
000006  f44f7089          MOV      r0,#0x112
00000a  5501              STRB     r1,[r0,r4]
;;;2017     
;;;2018     for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
00000c  2500              MOVS     r5,#0
00000e  e00b              B        |L34.40|
                  |L34.16|
;;;2019     {
;;;2020       USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
000010  21ff              MOVS     r1,#0xff
000012  f1040018          ADD      r0,r4,#0x18
000016  f8500025          LDR      r0,[r0,r5,LSL #2]
00001a  6081              STR      r1,[r0,#8]
;;;2021       USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
00001c  f1040054          ADD      r0,r4,#0x54
000020  f8500025          LDR      r0,[r0,r5,LSL #2]
000024  6081              STR      r1,[r0,#8]
000026  1c6d              ADDS     r5,r5,#1              ;2018
                  |L34.40|
000028  7860              LDRB     r0,[r4,#1]            ;2018
00002a  42a8              CMP      r0,r5                 ;2018
00002c  d8f0              BHI      |L34.16|
;;;2022     }
;;;2023     
;;;2024     USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
00002e  2100              MOVS     r1,#0
000030  6920              LDR      r0,[r4,#0x10]
000032  6101              STR      r1,[r0,#0x10]
;;;2025     USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
000034  6920              LDR      r0,[r4,#0x10]
000036  6141              STR      r1,[r0,#0x14]
;;;2026     USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
000038  6920              LDR      r0,[r4,#0x10]
00003a  61c1              STR      r1,[r0,#0x1c]
;;;2027     USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );  
00003c  1e49              SUBS     r1,r1,#1
00003e  6920              LDR      r0,[r4,#0x10]
000040  6181              STR      r1,[r0,#0x18]
;;;2028     
;;;2029     /* Flush the FIFO */
;;;2030     USB_OTG_FlushRxFifo(pdev);
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       USB_OTG_FlushRxFifo
;;;2031     USB_OTG_FlushTxFifo(pdev ,  0x10 );  
000048  2110              MOVS     r1,#0x10
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       USB_OTG_FlushTxFifo
;;;2032   }
000050  bd70              POP      {r4-r6,pc}
;;;2033   
                          ENDP


                          AREA ||i.USB_OTG_UngateClock||, CODE, READONLY, ALIGN=1

                  USB_OTG_UngateClock PROC
;;;1984   */
;;;1985   void USB_OTG_UngateClock(USB_OTG_CORE_HANDLE *pdev)
000000  b50c              PUSH     {r2,r3,lr}
;;;1986   {
;;;1987     if(pdev->cfg.low_power)
000002  7a81              LDRB     r1,[r0,#0xa]
000004  b1b1              CBZ      r1,|L35.52|
;;;1988     {
;;;1989       
;;;1990       USB_OTG_DSTS_TypeDef     dsts;
;;;1991       USB_OTG_PCGCCTL_TypeDef  power; 
;;;1992       
;;;1993       dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
000006  6901              LDR      r1,[r0,#0x10]
000008  6889              LDR      r1,[r1,#8]
00000a  9101              STR      r1,[sp,#4]
;;;1994       
;;;1995       if(dsts.b.suspsts == 1)
00000c  9901              LDR      r1,[sp,#4]
00000e  f0010101          AND      r1,r1,#1
000012  b171              CBZ      r1,|L35.50|
;;;1996       {
;;;1997         /* un-gate USB Core clock */
;;;1998         power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
000014  f8d0110c          LDR      r1,[r0,#0x10c]
000018  9100              STR      r1,[sp,#0]
;;;1999         power.b.gatehclk = 0;
00001a  9900              LDR      r1,[sp,#0]
00001c  f0210102          BIC      r1,r1,#2
000020  9100              STR      r1,[sp,#0]
;;;2000         power.b.stoppclk = 0;
000022  9900              LDR      r1,[sp,#0]
000024  f0210101          BIC      r1,r1,#1
000028  9100              STR      r1,[sp,#0]
;;;2001         USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
00002a  9a00              LDR      r2,[sp,#0]
00002c  f8d0110c          LDR      r1,[r0,#0x10c]
000030  600a              STR      r2,[r1,#0]
                  |L35.50|
;;;2002         
;;;2003       }
;;;2004     }
000032  bf00              NOP      
                  |L35.52|
;;;2005   }
000034  bd0c              POP      {r2,r3,pc}
;;;2006   
                          ENDP


                          AREA ||i.USB_OTG_WritePacket||, CODE, READONLY, ALIGN=1

                  USB_OTG_WritePacket PROC
;;;167    */
;;;168    USB_OTG_STS USB_OTG_WritePacket(USB_OTG_CORE_HANDLE *pdev, 
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;169                                    uint8_t             *src, 
;;;170                                    uint8_t             ch_ep_num, 
;;;171                                    uint16_t            len)
;;;172    {
000004  4604              MOV      r4,r0
;;;173      USB_OTG_STS status = USB_OTG_OK;
000006  2600              MOVS     r6,#0
;;;174      if (pdev->cfg.dma_enable == 0)
000008  78e0              LDRB     r0,[r4,#3]
00000a  b9b0              CBNZ     r0,|L36.58|
;;;175      {
;;;176        uint32_t count32b= 0 , i= 0;
00000c  2700              MOVS     r7,#0
00000e  2000              MOVS     r0,#0
;;;177        __IO uint32_t *fifo;
;;;178        
;;;179        count32b =  (len + 3) / 4;
000010  1cdd              ADDS     r5,r3,#3
000012  ea4f78e5          ASR      r8,r5,#31
000016  eb057898          ADD      r8,r5,r8,LSR #30
00001a  ea4f07a8          ASR      r7,r8,#2
;;;180        fifo = pdev->regs.DFIFO[ch_ep_num];
00001e  f10405d0          ADD      r5,r4,#0xd0
000022  f855c022          LDR      r12,[r5,r2,LSL #2]
;;;181        for (i = 0; i < count32b; i++, src+=4)
000026  bf00              NOP      
000028  e004              B        |L36.52|
                  |L36.42|
;;;182        {
;;;183          USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
00002a  680d              LDR      r5,[r1,#0]
00002c  f8cc5000          STR      r5,[r12,#0]
000030  1c40              ADDS     r0,r0,#1              ;181
000032  1d09              ADDS     r1,r1,#4              ;181
                  |L36.52|
000034  42b8              CMP      r0,r7                 ;181
000036  d3f8              BCC      |L36.42|
;;;184        }
;;;185      }
000038  bf00              NOP      
                  |L36.58|
;;;186      return status;
00003a  4630              MOV      r0,r6
;;;187    }
00003c  e8bd81f0          POP      {r4-r8,pc}
;;;188    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\Libraries\\STM32_USB_OTG_Driver\\src\\usb_core.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_usb_core_c_0d2ec05c____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_usb_core_c_0d2ec05c____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_usb_core_c_0d2ec05c____REVSH|
#line 144
|__asm___10_usb_core_c_0d2ec05c____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
