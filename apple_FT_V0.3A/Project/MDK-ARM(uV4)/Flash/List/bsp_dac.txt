; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\flash\obj\bsp_dac.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_dac.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\User -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\User\FatFS\src -I..\..\Libraries\STM32_USB_Device_Library\Class\msc\inc -I..\..\Libraries\STM32_USB_Device_Library\Core\inc -I..\..\Libraries\STM32_USB_OTG_Driver\inc -I..\..\User\usbd_mass_storage -I..\..\User\berry_ft -I..\..\User\ft_support -I..\..\User\factory_test -I..\..\User\emenu -I..\..\User\kiwi_ft -I..\..\User\kiwi_ft\spv40 -I..\..\User\kiwi_ft\spv40\peripheral -I..\..\User\lwrb -I..\..\User\easylogger\inc -I..\..\User\easylogger\plugins\file -I..\..\User\LOG -I..\..\User\kiwi_ft -I..\..\User\MultiButton-1.1.0 -I"..\..\User\ugui v0.3" -I.\RTE\_Flash -IC:\Users\qizha\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\qizha\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.16.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F407xx -D_RTE_ -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY --signed_chars --omf_browse=.\flash\obj\bsp_dac.crf ..\..\User\bsp_stm32f4xx\src\bsp_dac.c]
                          THUMB

                          AREA ||i.dac_deinit||, CODE, READONLY, ALIGN=1

                  dac_deinit PROC
;;;27     
;;;28     void dac_deinit(void)
000000  b510              PUSH     {r4,lr}
;;;29     {
;;;30         DAC_DeInit();
000002  f7fffffe          BL       DAC_DeInit
;;;31     }
000006  bd10              POP      {r4,pc}
;;;32     
                          ENDP


                          AREA ||i.dac_init||, CODE, READONLY, ALIGN=2

                  dac_init PROC
;;;3      
;;;4      void  dac_init(void)//PA4_dac_out
000000  b500              PUSH     {lr}
;;;5      {
000002  b087              SUB      sp,sp,#0x1c
;;;6          GPIO_InitTypeDef  GPIO_InitStructure;
;;;7          DAC_InitTypeDef DAC_InitType;
;;;8      
;;;9          RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);//使能GPIOA时钟
000004  2101              MOVS     r1,#1
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;10         RCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC, ENABLE);//使能DAC时钟
00000c  2101              MOVS     r1,#1
00000e  0748              LSLS     r0,r1,#29
000010  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;11     
;;;12         GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;
000014  2010              MOVS     r0,#0x10
000016  9005              STR      r0,[sp,#0x14]
;;;13         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;//模拟
000018  2003              MOVS     r0,#3
00001a  f88d0018          STRB     r0,[sp,#0x18]
;;;14         GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
00001e  2000              MOVS     r0,#0
000020  f88d001b          STRB     r0,[sp,#0x1b]
;;;15         GPIO_Init(GPIOA, &GPIO_InitStructure);//初始化
000024  a905              ADD      r1,sp,#0x14
000026  480b              LDR      r0,|L2.84|
000028  f7fffffe          BL       GPIO_Init
;;;16     
;;;17         DAC_InitType.DAC_Trigger = DAC_Trigger_None;	//不使用触发功能 TEN1=0
00002c  2000              MOVS     r0,#0
00002e  9001              STR      r0,[sp,#4]
;;;18         DAC_InitType.DAC_WaveGeneration = DAC_WaveGeneration_None; //不使用波形发生
000030  9002              STR      r0,[sp,#8]
;;;19         DAC_InitType.DAC_LFSRUnmask_TriangleAmplitude = DAC_LFSRUnmask_Bit0; //屏蔽、幅值设置
000032  9003              STR      r0,[sp,#0xc]
;;;20         DAC_InitType.DAC_OutputBuffer = DAC_OutputBuffer_Disable ;	//DAC1输出缓存关闭 BOFF1=1
000034  2002              MOVS     r0,#2
000036  9004              STR      r0,[sp,#0x10]
;;;21         DAC_Init(DAC_Channel_1, &DAC_InitType);	 //初始化DAC通道1
000038  a901              ADD      r1,sp,#4
00003a  2000              MOVS     r0,#0
00003c  f7fffffe          BL       DAC_Init
;;;22     
;;;23         DAC_Cmd(DAC_Channel_1, ENABLE);  //使能DAC通道1
000040  2101              MOVS     r1,#1
000042  2000              MOVS     r0,#0
000044  f7fffffe          BL       DAC_Cmd
;;;24     
;;;25         DAC_SetChannel1Data(DAC_Align_12b_R, 0);  //12位右对齐数据格式设置DAC值
000048  2100              MOVS     r1,#0
00004a  4608              MOV      r0,r1
00004c  f7fffffe          BL       DAC_SetChannel1Data
;;;26     }
000050  b007              ADD      sp,sp,#0x1c
000052  bd00              POP      {pc}
;;;27     
                          ENDP

                  |L2.84|
                          DCD      0x40020000

                          AREA ||i.dac_volt_2x_set||, CODE, READONLY, ALIGN=2

                  dac_volt_2x_set PROC
;;;34     //vol:0~3300,代表0~3.3V
;;;35     void dac_volt_2x_set(double volt)//29mV增量
000000  b510              PUSH     {r4,lr}
;;;36     {
000002  ed2d8b0e          VPUSH    {d8-d14}
000006  eeb08a40          VMOV.F32 s16,s0
00000a  eef08a60          VMOV.F32 s17,s1
;;;37         
;;;38         float dac_value = (volt/2/ g_st_user.verf)  * 4095 + 0.5;
00000e  481c              LDR      r0,|L3.128|
000010  ed900a01          VLDR     s0,[r0,#4]
000014  ee101a10          VMOV     r1,s0
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       __aeabi_f2d
00001e  ec410b1d          VMOV     d13,r0,r1
000022  ed9f0b18          VLDR     d0,|L3.132|
000026  ec532b10          VMOV     r2,r3,d0
00002a  ec510b18          VMOV     r0,r1,d8
00002e  f7fffffe          BL       __aeabi_ddiv
000032  ec410b1e          VMOV     d14,r0,r1
000036  ec532b1d          VMOV     r2,r3,d13
00003a  f7fffffe          BL       __aeabi_ddiv
00003e  ec410b1c          VMOV     d12,r0,r1
000042  ed9f0b12          VLDR     d0,|L3.140|
000046  ec532b10          VMOV     r2,r3,d0
00004a  f7fffffe          BL       __aeabi_dmul
00004e  ec410b1b          VMOV     d11,r0,r1
000052  ed9f0b10          VLDR     d0,|L3.148|
000056  ec532b10          VMOV     r2,r3,d0
00005a  f7fffffe          BL       __aeabi_dadd
00005e  ec410b1a          VMOV     d10,r0,r1
000062  f7fffffe          BL       __aeabi_d2f
000066  ee090a10          VMOV     s18,r0
;;;39         DAC_SetChannel1Data(DAC_Align_12b_R, dac_value); //12位右对齐数据格式设置DAC值
00006a  eebc0ac9          VCVT.U32.F32 s0,s18
00006e  ee100a10          VMOV     r0,s0
000072  b281              UXTH     r1,r0
000074  2000              MOVS     r0,#0
000076  f7fffffe          BL       DAC_SetChannel1Data
;;;40     }
00007a  ecbd8b0e          VPOP     {d8-d14}
00007e  bd10              POP      {r4,pc}
;;;41     
                          ENDP

                  |L3.128|
                          DCD      g_st_user
                  |L3.132|
000084  00000000          DCFD     0x4000000000000000 ; 2
000088  40000000
                  |L3.140|
00008c  00000000          DCFD     0x40affe0000000000 ; 4095
000090  40affe00
                  |L3.148|
000094  00000000          DCFD     0x3fe0000000000000 ; 0.5
000098  3fe00000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\src\\bsp_dac.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_bsp_dac_c_dac_init____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_bsp_dac_c_dac_init____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_bsp_dac_c_dac_init____REVSH|
#line 144
|__asm___9_bsp_dac_c_dac_init____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
