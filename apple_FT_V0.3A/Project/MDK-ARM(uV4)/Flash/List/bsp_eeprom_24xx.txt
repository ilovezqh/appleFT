; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\flash\obj\bsp_eeprom_24xx.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_eeprom_24xx.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\User -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\User\FatFS\src -I..\..\Libraries\STM32_USB_Device_Library\Class\msc\inc -I..\..\Libraries\STM32_USB_Device_Library\Core\inc -I..\..\Libraries\STM32_USB_OTG_Driver\inc -I..\..\User\usbd_mass_storage -I..\..\User\ft_support -I..\..\User\test -I..\..\User\emenu -I..\..\User\chip_ft -I..\..\User\lwrb -I..\..\User\easylogger\inc -I..\..\User\easylogger\plugins\file -I..\..\User\LOG -I..\..\User\MultiButton-1.1.0 -I..\..\User\cm_backtrace -I..\..\User\MultiTimer -I.\RTE\_Flash -IC:\Users\qizha\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\qizha\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.17.1\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F407xx -D_RTE_ -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY --signed_chars --omf_browse=.\flash\obj\bsp_eeprom_24xx.crf ..\..\User\bsp_stm32f4xx\src\bsp_eeprom_24xx.c]
                          THUMB

                          AREA ||i.ee_CheckOk||, CODE, READONLY, ALIGN=1

                  ee_CheckOk PROC
;;;31     */
;;;32     uint8_t ee_CheckOk(void)
000000  b510              PUSH     {r4,lr}
;;;33     {
;;;34     	if (i2c_CheckDevice(EE_DEV_ADDR) == 0)
000002  20a0              MOVS     r0,#0xa0
000004  f7fffffe          BL       i2c_CheckDevice
000008  b908              CBNZ     r0,|L1.14|
;;;35     	{
;;;36             
;;;37     		return 1;
00000a  2001              MOVS     r0,#1
                  |L1.12|
;;;38     	}
;;;39     	else
;;;40     	{
;;;41     		/* 失败后，切记发送I2C总线停止信号 */
;;;42     		i2c_Stop();
;;;43     		return 0;
;;;44     	}
;;;45     }
00000c  bd10              POP      {r4,pc}
                  |L1.14|
00000e  f7fffffe          BL       i2c_Stop
000012  2000              MOVS     r0,#0                 ;43
000014  e7fa              B        |L1.12|
;;;46     
                          ENDP


                          AREA ||i.ee_ReadBytes||, CODE, READONLY, ALIGN=1

                  ee_ReadBytes PROC
;;;57     */
;;;58     uint8_t ee_ReadBytes(uint8_t *_pReadBuf, uint16_t _usAddress, uint16_t _usSize)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;59     {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;60     	uint16_t i;
;;;61     
;;;62     	/* 采用串行EEPROM随即读取指令序列，连续读取若干字节 */
;;;63     
;;;64     	/* 第1步：发起I2C总线启动信号 */
;;;65     	i2c_Start();
00000a  f7fffffe          BL       i2c_Start
;;;66     
;;;67     	/* 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;68     	i2c_SendByte(EE_DEV_ADDR | I2C_WR);	/* 此处是写指令 */
00000e  20a0              MOVS     r0,#0xa0
000010  f7fffffe          BL       i2c_SendByte
;;;69     
;;;70     	/* 第3步：发送ACK */
;;;71     	if (i2c_WaitAck() != 0)
000014  f7fffffe          BL       i2c_WaitAck
000018  b100              CBZ      r0,|L2.28|
;;;72     	{
;;;73     		goto cmd_fail;	/* EEPROM器件无应答 */
00001a  e025              B        |L2.104|
                  |L2.28|
;;;74     	}
;;;75     
;;;76     	/* 第4步：发送字节地址，24C02只有256字节，因此1个字节就够了，如果是24C04以上，那么此处需要连发多个地址 */
;;;77     	if (EE_ADDR_BYTES == 1)
;;;78     	{
;;;79     		i2c_SendByte((uint8_t)_usAddress);
00001c  b2f8              UXTB     r0,r7
00001e  f7fffffe          BL       i2c_SendByte
;;;80     		if (i2c_WaitAck() != 0)
000022  f7fffffe          BL       i2c_WaitAck
000026  b100              CBZ      r0,|L2.42|
;;;81     		{
;;;82     			goto cmd_fail;	/* EEPROM器件无应答 */
000028  e01e              B        |L2.104|
                  |L2.42|
;;;83     		}
;;;84     	}
;;;85     	else
;;;86     	{
;;;87     		i2c_SendByte(_usAddress >> 8);
;;;88     		if (i2c_WaitAck() != 0)
;;;89     		{
;;;90     			goto cmd_fail;	/* EEPROM器件无应答 */
;;;91     		}
;;;92     
;;;93     		i2c_SendByte(_usAddress);
;;;94     		if (i2c_WaitAck() != 0)
;;;95     		{
;;;96     			goto cmd_fail;	/* EEPROM器件无应答 */
;;;97     		}
;;;98     	}
;;;99     
;;;100    	/* 第6步：重新启动I2C总线。下面开始读取数据 */
;;;101    	i2c_Start();
00002a  f7fffffe          BL       i2c_Start
;;;102    
;;;103    	/* 第7步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;104    	i2c_SendByte(EE_DEV_ADDR | I2C_RD);	/* 此处是读指令 */
00002e  20a1              MOVS     r0,#0xa1
000030  f7fffffe          BL       i2c_SendByte
;;;105    
;;;106    	/* 第8步：发送ACK */
;;;107    	if (i2c_WaitAck() != 0)
000034  f7fffffe          BL       i2c_WaitAck
000038  b100              CBZ      r0,|L2.60|
;;;108    	{
;;;109    		goto cmd_fail;	/* EEPROM器件无应答 */
00003a  e015              B        |L2.104|
                  |L2.60|
;;;110    	}
;;;111    
;;;112    	/* 第9步：循环读取数据 */
;;;113    	for (i = 0; i < _usSize; i++)
00003c  2400              MOVS     r4,#0
00003e  e00c              B        |L2.90|
                  |L2.64|
;;;114    	{
;;;115    		_pReadBuf[i] = i2c_ReadByte();	/* 读1个字节 */
000040  f7fffffe          BL       i2c_ReadByte
000044  5530              STRB     r0,[r6,r4]
;;;116    
;;;117    		/* 每读完1个字节后，需要发送Ack， 最后一个字节不需要Ack，发Nack */
;;;118    		if (i != _usSize - 1)
000046  1e68              SUBS     r0,r5,#1
000048  42a0              CMP      r0,r4
00004a  d002              BEQ      |L2.82|
;;;119    		{
;;;120    			i2c_Ack();	/* 中间字节读完后，CPU产生ACK信号(驱动SDA = 0) */
00004c  f7fffffe          BL       i2c_Ack
000050  e001              B        |L2.86|
                  |L2.82|
;;;121    		}
;;;122    		else
;;;123    		{
;;;124    			i2c_NAck();	/* 最后1个字节读完后，CPU产生NACK信号(驱动SDA = 1) */
000052  f7fffffe          BL       i2c_NAck
                  |L2.86|
000056  1c60              ADDS     r0,r4,#1              ;113
000058  b284              UXTH     r4,r0                 ;113
                  |L2.90|
00005a  42ac              CMP      r4,r5                 ;113
00005c  dbf0              BLT      |L2.64|
;;;125    		}
;;;126    	}
;;;127    	/* 发送I2C总线停止信号 */
;;;128    	i2c_Stop();
00005e  f7fffffe          BL       i2c_Stop
;;;129    	return 1;	/* 执行成功 */
000062  2001              MOVS     r0,#1
                  |L2.100|
;;;130    
;;;131    cmd_fail: /* 命令执行失败后，切记发送停止信号，避免影响I2C总线上其他设备 */
;;;132    	/* 发送I2C总线停止信号 */
;;;133    	i2c_Stop();
;;;134    	return 0;
;;;135    }
000064  e8bd81f0          POP      {r4-r8,pc}
                  |L2.104|
000068  f7fffffe          BL       i2c_Stop
00006c  2000              MOVS     r0,#0                 ;134
00006e  e7f9              B        |L2.100|
;;;136    
                          ENDP


                          AREA ||i.ee_WriteBytes||, CODE, READONLY, ALIGN=1

                  ee_WriteBytes PROC
;;;146    */
;;;147    uint8_t ee_WriteBytes(uint8_t *_pWriteBuf, uint16_t _usAddress, uint16_t _usSize)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;148    {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
;;;149    	uint16_t i,m;
;;;150    	uint16_t usAddr;
;;;151    
;;;152    	/*
;;;153    		写串行EEPROM不像读操作可以连续读取很多字节，每次写操作只能在同一个page。
;;;154    		对于24xx02，page size = 8
;;;155    		简单的处理方法为：按字节写操作模式，每写1个字节，都发送地址
;;;156    		为了提高连续写的效率: 本函数采用page wirte操作。
;;;157    	*/
;;;158    
;;;159    	usAddr = _usAddress;
00000a  4646              MOV      r6,r8
;;;160    	for (i = 0; i < _usSize; i++)
00000c  2400              MOVS     r4,#0
00000e  e02c              B        |L3.106|
                  |L3.16|
;;;161    	{
;;;162    		/* 当发送第1个字节或是页面首地址时，需要重新发起启动信号和地址 */
;;;163    		if ((i == 0) || (usAddr & (EE_PAGE_SIZE - 1)) == 0)
000010  b114              CBZ      r4,|L3.24|
000012  f0060007          AND      r0,r6,#7
000016  b9e8              CBNZ     r0,|L3.84|
                  |L3.24|
;;;164    		{
;;;165    			/*　第０步：发停止信号，启动内部写操作　*/
;;;166    			i2c_Stop();
000018  f7fffffe          BL       i2c_Stop
;;;167    
;;;168    			/* 通过检查器件应答的方式，判断内部写操作是否完成, 一般小于 10ms
;;;169    				CLK频率为200KHz时，查询次数为30次左右
;;;170    			*/
;;;171    			for (m = 0; m < 1000; m++)
00001c  2500              MOVS     r5,#0
00001e  e00a              B        |L3.54|
                  |L3.32|
;;;172    			{
;;;173    				/* 第1步：发起I2C总线启动信号 */
;;;174    				i2c_Start();
000020  f7fffffe          BL       i2c_Start
;;;175    
;;;176    				/* 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;177    				i2c_SendByte(EE_DEV_ADDR | I2C_WR);	/* 此处是写指令 */
000024  20a0              MOVS     r0,#0xa0
000026  f7fffffe          BL       i2c_SendByte
;;;178    
;;;179    				/* 第3步：发送一个时钟，判断器件是否正确应答 */
;;;180    				if (i2c_WaitAck() == 0)
00002a  f7fffffe          BL       i2c_WaitAck
00002e  b900              CBNZ     r0,|L3.50|
;;;181    				{
;;;182    					break;
000030  e004              B        |L3.60|
                  |L3.50|
000032  1c68              ADDS     r0,r5,#1              ;171
000034  b285              UXTH     r5,r0                 ;171
                  |L3.54|
000036  f5b57f7a          CMP      r5,#0x3e8             ;171
00003a  dbf1              BLT      |L3.32|
                  |L3.60|
00003c  bf00              NOP      
;;;183    				}
;;;184    			}
;;;185    			if (m  == 1000)
00003e  f5b57f7a          CMP      r5,#0x3e8
000042  d100              BNE      |L3.70|
;;;186    			{
;;;187    				goto cmd_fail;	/* EEPROM器件写超时 */
000044  e018              B        |L3.120|
                  |L3.70|
;;;188    			}
;;;189    
;;;190    			/* 第4步：发送字节地址，24C02只有256字节，因此1个字节就够了，如果是24C04以上，那么此处需要连发多个地址 */
;;;191    			if (EE_ADDR_BYTES == 1)
;;;192    			{
;;;193    				i2c_SendByte((uint8_t)usAddr);
000046  b2f0              UXTB     r0,r6
000048  f7fffffe          BL       i2c_SendByte
;;;194    				if (i2c_WaitAck() != 0)
00004c  f7fffffe          BL       i2c_WaitAck
000050  b100              CBZ      r0,|L3.84|
;;;195    				{
;;;196    					goto cmd_fail;	/* EEPROM器件无应答 */
000052  e011              B        |L3.120|
                  |L3.84|
;;;197    				}
;;;198    			}
;;;199    			else
;;;200    			{
;;;201    				i2c_SendByte(usAddr >> 8);
;;;202    				if (i2c_WaitAck() != 0)
;;;203    				{
;;;204    					goto cmd_fail;	/* EEPROM器件无应答 */
;;;205    				}
;;;206    
;;;207    				i2c_SendByte(usAddr);
;;;208    				if (i2c_WaitAck() != 0)
;;;209    				{
;;;210    					goto cmd_fail;	/* EEPROM器件无应答 */
;;;211    				}
;;;212    			}
;;;213    		}
;;;214    
;;;215    		/* 第6步：开始写入数据 */
;;;216    		i2c_SendByte(_pWriteBuf[i]);
000054  5d38              LDRB     r0,[r7,r4]
000056  f7fffffe          BL       i2c_SendByte
;;;217    
;;;218    		/* 第7步：发送ACK */
;;;219    		if (i2c_WaitAck() != 0)
00005a  f7fffffe          BL       i2c_WaitAck
00005e  b100              CBZ      r0,|L3.98|
;;;220    		{
;;;221    			goto cmd_fail;	/* EEPROM器件无应答 */
000060  e00a              B        |L3.120|
                  |L3.98|
;;;222    		}
;;;223    
;;;224    		usAddr++;	/* 地址增1 */
000062  1c70              ADDS     r0,r6,#1
000064  b286              UXTH     r6,r0
000066  1c60              ADDS     r0,r4,#1              ;160
000068  b284              UXTH     r4,r0                 ;160
                  |L3.106|
00006a  454c              CMP      r4,r9                 ;160
00006c  dbd0              BLT      |L3.16|
;;;225    	}
;;;226    
;;;227    	/* 命令执行成功，发送I2C总线停止信号 */
;;;228    	i2c_Stop();
00006e  f7fffffe          BL       i2c_Stop
;;;229    	return 1;
000072  2001              MOVS     r0,#1
                  |L3.116|
;;;230    
;;;231    cmd_fail: /* 命令执行失败后，切记发送停止信号，避免影响I2C总线上其他设备 */
;;;232    	/* 发送I2C总线停止信号 */
;;;233    	i2c_Stop();
;;;234    	return 0;
;;;235    }
000074  e8bd87f0          POP      {r4-r10,pc}
                  |L3.120|
000078  f7fffffe          BL       i2c_Stop
00007c  2000              MOVS     r0,#0                 ;234
00007e  e7f9              B        |L3.116|
;;;236    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\src\\bsp_eeprom_24xx.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_bsp_eeprom_24xx_c_4eb00f1b____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___17_bsp_eeprom_24xx_c_4eb00f1b____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_bsp_eeprom_24xx_c_4eb00f1b____REVSH|
#line 144
|__asm___17_bsp_eeprom_24xx_c_4eb00f1b____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
