; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\flash\obj\crc32.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\crc32.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\User -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\User\FatFS\src -I..\..\Libraries\STM32_USB_Device_Library\Class\msc\inc -I..\..\Libraries\STM32_USB_Device_Library\Core\inc -I..\..\Libraries\STM32_USB_OTG_Driver\inc -I..\..\User\usbd_mass_storage -I..\..\User\ft_support -I..\..\User\test -I..\..\User\emenu -I..\..\User\chip_ft -I..\..\User\lwrb -I..\..\User\easylogger\inc -I..\..\User\easylogger\plugins\file -I..\..\User\LOG -I..\..\User\MultiButton-1.1.0 -I..\..\User\cm_backtrace -I..\..\User\MultiTimer -I.\RTE\_Flash -IC:\Users\qizha\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\qizha\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.17.1\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F407xx -D_RTE_ -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY --signed_chars --omf_browse=.\flash\obj\crc32.crf ..\..\User\chip_ft\crc32.c]
                          THUMB

                          AREA ||i.crc32_entire_calcu||, CODE, READONLY, ALIGN=1

                  crc32_entire_calcu PROC
;;;136    */
;;;137    uint32_t crc32_entire_calcu(const uint8_t *pbuff, uint32_t size)
000000  b538              PUSH     {r3-r5,lr}
;;;138    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;139        uint32_t temp;
;;;140        crc32_partial_start(&temp);
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       crc32_partial_start
;;;141        crc32_partial_calcu(&temp ,pbuff,size);
00000c  462a              MOV      r2,r5
00000e  4621              MOV      r1,r4
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       crc32_partial_calcu
;;;142        crc32_partial_stop(&temp);
000016  4668              MOV      r0,sp
000018  f7fffffe          BL       crc32_partial_stop
;;;143        return temp;
00001c  9800              LDR      r0,[sp,#0]
;;;144    }
00001e  bd38              POP      {r3-r5,pc}
                          ENDP


                          AREA ||i.crc32_init||, CODE, READONLY, ALIGN=2

                  crc32_init PROC
;;;27     */
;;;28     void crc32_init(void)
000000  2000              MOVS     r0,#0
;;;29     {
;;;30         #if 0
;;;31         uint32_t poly = 0xEDB88320;     //采用的是从高位往低位计算，多项式的高低位需要反转。
;;;32         for(uint32_t i = 0; i < 256; i++)
;;;33         {
;;;34             uint32_t crc = i;
;;;35             for(uint32_t j = 0; j < 8; j++)
;;;36             {
;;;37                 if(crc & 1UL)
;;;38                 {
;;;39                     crc >>= 1;
;;;40                     crc ^= poly;
;;;41                 }
;;;42                 else
;;;43                 {
;;;44                     crc >>= 1;
;;;45                 }
;;;46             }
;;;47             s_crc32_tab[i] = crc;
;;;48         }
;;;49         
;;;50         #else
;;;51         #define CRC32_POLYNOMIAL    0x04C11DB7
;;;52         #define CRC32_INITIAL_VALUE 0xFFFFFFFF     //采用的是从高位往低位计算，多项式的高低位需要反转。
;;;53         for (uint32_t i = 0; i < 256; i++) {
000002  e011              B        |L2.40|
                  |L2.4|
;;;54             uint32_t crc = i << 24;
000004  0601              LSLS     r1,r0,#24
;;;55             for (uint32_t j = 0; j < 8; j++) {
000006  2200              MOVS     r2,#0
000008  e008              B        |L2.28|
                  |L2.10|
;;;56                 if (crc & 0x80000000) {
00000a  f0014300          AND      r3,r1,#0x80000000
00000e  b11b              CBZ      r3,|L2.24|
;;;57                     crc = (crc << 1) ^ CRC32_POLYNOMIAL;
000010  4b07              LDR      r3,|L2.48|
000012  ea830141          EOR      r1,r3,r1,LSL #1
000016  e000              B        |L2.26|
                  |L2.24|
;;;58                 } else {
;;;59                     crc <<= 1;
000018  0049              LSLS     r1,r1,#1
                  |L2.26|
00001a  1c52              ADDS     r2,r2,#1              ;55
                  |L2.28|
00001c  2a08              CMP      r2,#8                 ;55
00001e  d3f4              BCC      |L2.10|
;;;60                 }
;;;61             }
;;;62             s_crc32_tab[i] = crc;
000020  4a04              LDR      r2,|L2.52|
000022  f8421020          STR      r1,[r2,r0,LSL #2]
000026  1c40              ADDS     r0,r0,#1              ;53
                  |L2.40|
000028  28ff              CMP      r0,#0xff              ;53
00002a  d9eb              BLS      |L2.4|
;;;63         }
;;;64         #endif
;;;65     }
00002c  4770              BX       lr
;;;66     
                          ENDP

00002e  0000              DCW      0x0000
                  |L2.48|
                          DCD      0x04c11db7
                  |L2.52|
                          DCD      s_crc32_tab

                          AREA ||i.crc32_partial_calcu||, CODE, READONLY, ALIGN=2

                  crc32_partial_calcu PROC
;;;106    */
;;;107    void  crc32_partial_calcu(uint32_t* pResult,const uint8_t *pbuff, uint32_t size)
000000  b530              PUSH     {r4,r5,lr}
;;;108    {
000002  460b              MOV      r3,r1
;;;109        for (uint32_t i = 0; i < size; i++)
000004  2100              MOVS     r1,#0
000006  e00b              B        |L3.32|
                  |L3.8|
;;;110        {
;;;111            //*pResult = s_crc32_tab[(*pResult ^ pbuff[i]) & 0xff] ^ (*pResult >> 8);
;;;112            *pResult = (*pResult << 8) ^ s_crc32_tab[(*pResult >> 24) ^ pbuff[i]];
000008  5c5c              LDRB     r4,[r3,r1]
00000a  6805              LDR      r5,[r0,#0]
00000c  ea846415          EOR      r4,r4,r5,LSR #24
000010  4d05              LDR      r5,|L3.40|
000012  f8554024          LDR      r4,[r5,r4,LSL #2]
000016  6805              LDR      r5,[r0,#0]
000018  ea842405          EOR      r4,r4,r5,LSL #8
00001c  6004              STR      r4,[r0,#0]
00001e  1c49              ADDS     r1,r1,#1              ;109
                  |L3.32|
000020  4291              CMP      r1,r2                 ;109
000022  d3f1              BCC      |L3.8|
;;;113        }
;;;114    }
000024  bd30              POP      {r4,r5,pc}
;;;115    
                          ENDP

000026  0000              DCW      0x0000
                  |L3.40|
                          DCD      s_crc32_tab

                          AREA ||i.crc32_partial_start||, CODE, READONLY, ALIGN=1

                  crc32_partial_start PROC
;;;75     */
;;;76     void crc32_partial_start(uint32_t *pResult)
000000  f04f31ff          MOV      r1,#0xffffffff
;;;77     {
;;;78         *pResult = 0xffffffff;
000004  6001              STR      r1,[r0,#0]
;;;79     }
000006  4770              BX       lr
;;;80     
                          ENDP


                          AREA ||i.crc32_partial_stop||, CODE, READONLY, ALIGN=1

                  crc32_partial_stop PROC
;;;123    */
;;;124    void crc32_partial_stop(uint32_t* pResult)
000000  6801              LDR      r1,[r0,#0]
;;;125    {
;;;126        *pResult = *pResult; // ^ 0xFFFFFFFF;
000002  6001              STR      r1,[r0,#0]
;;;127    }
000004  4770              BX       lr
;;;128    
                          ENDP


                          AREA ||i.plxc_programmer_encrypt_calcu||, CODE, READONLY, ALIGN=2

                  plxc_programmer_encrypt_calcu PROC
;;;80     
;;;81     uint32_t plxc_programmer_encrypt_calcu(void)
000000  b500              PUSH     {lr}
;;;82     {
000002  b087              SUB      sp,sp,#0x1c
;;;83         uint32_t start=0x20170328; /* 起始数 */
000004  480c              LDR      r0,|L6.56|
000006  9006              STR      r0,[sp,#0x18]
;;;84         uint8_t key_tab[24];
;;;85         
;;;86         for(uint32_t i=0; i<24; i++)
000008  2000              MOVS     r0,#0
00000a  e007              B        |L6.28|
                  |L6.12|
;;;87         {
;;;88             key_tab[i] = (g_nor_key>>i) + i;
00000c  490b              LDR      r1,|L6.60|
00000e  6809              LDR      r1,[r1,#0]  ; g_nor_key
000010  40c1              LSRS     r1,r1,r0
000012  4401              ADD      r1,r1,r0
000014  b2c9              UXTB     r1,r1
000016  f80d1000          STRB     r1,[sp,r0]
00001a  1c40              ADDS     r0,r0,#1              ;86
                  |L6.28|
00001c  2818              CMP      r0,#0x18              ;86
00001e  d3f5              BCC      |L6.12|
;;;89         }
;;;90         
;;;91         crc32_partial_calcu(&start, key_tab, sizeof(key_tab));
000020  2218              MOVS     r2,#0x18
000022  4669              MOV      r1,sp
000024  a806              ADD      r0,sp,#0x18
000026  f7fffffe          BL       crc32_partial_calcu
;;;92         
;;;93         start ^= 0xfaceb00c;
00002a  4905              LDR      r1,|L6.64|
00002c  9806              LDR      r0,[sp,#0x18]
00002e  4048              EORS     r0,r0,r1
000030  9006              STR      r0,[sp,#0x18]
;;;94         
;;;95         return start;
000032  9806              LDR      r0,[sp,#0x18]
;;;96     }
000034  b007              ADD      sp,sp,#0x1c
000036  bd00              POP      {pc}
;;;97     
                          ENDP

                  |L6.56|
                          DCD      0x20170328
                  |L6.60|
                          DCD      g_nor_key
                  |L6.64|
                          DCD      0xfaceb00c

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  s_crc32_tab
                          %        1024

                          AREA ||.data||, DATA, ALIGN=2

                  g_nor_key
                          DCD      0x00000000
