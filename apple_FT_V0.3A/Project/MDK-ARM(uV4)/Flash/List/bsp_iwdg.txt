; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\flash\obj\bsp_iwdg.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_iwdg.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\User -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\User\FatFS\src -I..\..\Libraries\STM32_USB_Device_Library\Class\msc\inc -I..\..\Libraries\STM32_USB_Device_Library\Core\inc -I..\..\Libraries\STM32_USB_OTG_Driver\inc -I..\..\User\usbd_mass_storage -I..\..\User\ft_support -I..\..\User\test -I..\..\User\emenu -I..\..\User\chip_ft -I..\..\User\lwrb -I..\..\User\easylogger\inc -I..\..\User\easylogger\plugins\file -I..\..\User\LOG -I..\..\User\MultiButton-1.1.0 -I..\..\User\cm_backtrace -I..\..\User\MultiTimer -I.\RTE\_Flash -IC:\Users\qizha\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\qizha\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.17.1\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F407xx -D_RTE_ -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY --signed_chars --omf_browse=.\flash\obj\bsp_iwdg.crf ..\..\User\bsp_stm32f4xx\src\bsp_iwdg.c]
                          THUMB

                          AREA ||i.GetLSIFrequency||, CODE, READONLY, ALIGN=2

                  GetLSIFrequency PROC
;;;111    */
;;;112    uint32_t GetLSIFrequency(void)
000000  b500              PUSH     {lr}
;;;113    {
000002  b089              SUB      sp,sp,#0x24
;;;114    	NVIC_InitTypeDef   NVIC_InitStructure;
;;;115    	TIM_ICInitTypeDef  TIM_ICInitStructure;
;;;116    	RCC_ClocksTypeDef  RCC_ClockFreq;
;;;117    	
;;;118    	/* 使能外部低速晶振 */
;;;119    	RCC_LSICmd(ENABLE);
000004  2001              MOVS     r0,#1
000006  f7fffffe          BL       RCC_LSICmd
;;;120    	
;;;121    	/* 等待直到LSI就绪 */
;;;122    	while (RCC_GetFlagStatus(RCC_FLAG_LSIRDY) == RESET)
00000a  bf00              NOP      
                  |L1.12|
00000c  2061              MOVS     r0,#0x61
00000e  f7fffffe          BL       RCC_GetFlagStatus
000012  2800              CMP      r0,#0
000014  d0fa              BEQ      |L1.12|
;;;123    	{}
;;;124    	
;;;125    	/* TIM5 配置 */ 
;;;126    	/* 使能TIM5时钟 */
;;;127    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM5, ENABLE);
000016  2101              MOVS     r1,#1
000018  2008              MOVS     r0,#8
00001a  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;128    	
;;;129    	/* 将TIM5_CH4输入捕获通道连接到LSI时钟输出 */
;;;130    	TIM_RemapConfig(TIM5, TIM5_LSI);
00001e  2140              MOVS     r1,#0x40
000020  482a              LDR      r0,|L1.204|
000022  f7fffffe          BL       TIM_RemapConfig
;;;131    	
;;;132    	/* 配置TIM5分频 */
;;;133    	TIM_PrescalerConfig(TIM5, 0, TIM_PSCReloadMode_Immediate);
000026  2201              MOVS     r2,#1
000028  2100              MOVS     r1,#0
00002a  4828              LDR      r0,|L1.204|
00002c  f7fffffe          BL       TIM_PrescalerConfig
;;;134    	
;;;135    	/* 
;;;136    	 TIM5 配置: 输入捕获模式 
;;;137    	 1. LSI 振荡器连接到 TIM5 CH4
;;;138    	 2. 上升沿做为激活的边沿
;;;139    	 3. TIM5 CCR4用于计算频率值 
;;;140    	 4. 这里主要分频设置TIM_ICPSC_DIV8，它的意思不是TIM的8分频
;;;141    		它的意思是每8个时间捕获一次，这里就表示8个上升沿以后是
;;;142    		一次捕获进入中断，然后再过8个上升沿捕获一次进入中断，这两
;;;143    		次中断以后得到时间间隔，也就是8个周期，所以最后得到的结果
;;;144    		是放大了8倍。
;;;145        */
;;;146    	TIM_ICInitStructure.TIM_Channel = TIM_Channel_4;
000030  200c              MOVS     r0,#0xc
000032  f8ad0014          STRH     r0,[sp,#0x14]
;;;147    	TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;
000036  2000              MOVS     r0,#0
000038  f8ad0016          STRH     r0,[sp,#0x16]
;;;148    	TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;
00003c  2001              MOVS     r0,#1
00003e  f8ad0018          STRH     r0,[sp,#0x18]
;;;149    	TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV8;
000042  200c              MOVS     r0,#0xc
000044  f8ad001a          STRH     r0,[sp,#0x1a]
;;;150    	TIM_ICInitStructure.TIM_ICFilter = 0;
000048  2000              MOVS     r0,#0
00004a  f8ad001c          STRH     r0,[sp,#0x1c]
;;;151    	TIM_ICInit(TIM5, &TIM_ICInitStructure);
00004e  a905              ADD      r1,sp,#0x14
000050  481e              LDR      r0,|L1.204|
000052  f7fffffe          BL       TIM_ICInit
;;;152    	
;;;153    	/* 使能TIM5中断通道 */
;;;154    	NVIC_InitStructure.NVIC_IRQChannel = TIM5_IRQn;
000056  2032              MOVS     r0,#0x32
000058  f88d0020          STRB     r0,[sp,#0x20]
;;;155    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
00005c  2000              MOVS     r0,#0
00005e  f88d0021          STRB     r0,[sp,#0x21]
;;;156    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000062  f88d0022          STRB     r0,[sp,#0x22]
;;;157    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000066  2001              MOVS     r0,#1
000068  f88d0023          STRB     r0,[sp,#0x23]
;;;158    	NVIC_Init(&NVIC_InitStructure);
00006c  a808              ADD      r0,sp,#0x20
00006e  f7fffffe          BL       NVIC_Init
;;;159    	
;;;160    	/* 使能TIM5计数 */
;;;161    	TIM_Cmd(TIM5, ENABLE);
000072  2101              MOVS     r1,#1
000074  4815              LDR      r0,|L1.204|
000076  f7fffffe          BL       TIM_Cmd
;;;162    	
;;;163    	/* 清除标志 */
;;;164    	TIM5->SR = 0;
00007a  2000              MOVS     r0,#0
00007c  4913              LDR      r1,|L1.204|
00007e  3110              ADDS     r1,r1,#0x10
000080  8008              STRH     r0,[r1,#0]
;;;165    	
;;;166    	/* 使能 CC4 中断请求 */  
;;;167    	TIM_ITConfig(TIM5, TIM_IT_CC4, ENABLE);
000082  2201              MOVS     r2,#1
000084  2110              MOVS     r1,#0x10
000086  4811              LDR      r0,|L1.204|
000088  f7fffffe          BL       TIM_ITConfig
;;;168    	
;;;169    	
;;;170    	/* 等待直到 TIM5 得到 2 个LSI 边沿 */
;;;171    	while(CaptureNumber != 2)
00008c  bf00              NOP      
                  |L1.142|
00008e  4810              LDR      r0,|L1.208|
000090  6800              LDR      r0,[r0,#0]  ; CaptureNumber
000092  2802              CMP      r0,#2
000094  d1fb              BNE      |L1.142|
;;;172    	{
;;;173    		
;;;174    	}
;;;175    	
;;;176    	/* 重定义TIM5到复位值 */
;;;177    	TIM_DeInit(TIM5);
000096  480d              LDR      r0,|L1.204|
000098  f7fffffe          BL       TIM_DeInit
;;;178    		
;;;179    	/* 计算 LSI 频率, 根据TIM5输入时钟频率做计算(PCLK1)*/
;;;180    	/* 得到 SYSCLK, HCLK 和 PCLKx  */
;;;181    	RCC_GetClocksFreq(&RCC_ClockFreq);
00009c  a801              ADD      r0,sp,#4
00009e  f7fffffe          BL       RCC_GetClocksFreq
;;;182    	
;;;183    	/*
;;;184    	  HCLK = SYSCLK / 1     (AHB1Periph)     = 168MHz
;;;185          PCLK2 = HCLK / 2      (APB2Periph)      = 84MHz
;;;186          PCLK1 = HCLK / 4      (APB1Periph)      = 42MHz
;;;187        
;;;188          因为APB1 prescaler != 1, 所以 APB1上的TIMxCLK = PCLK1 x 2 = SystemCoreClock / 2;
;;;189          因为APB2 prescaler != 1, 所以 APB2上的TIMxCLK = PCLK2 x 2 = SystemCoreClock;
;;;190    
;;;191          APB1 定时器有 TIM2, TIM3 ,TIM4, TIM5, TIM6, TIM6, TIM12, TIM13,TIM14
;;;192          APB2 定时器有 TIM1, TIM8 ,TIM9, TIM10, TIM11
;;;193    	*/
;;;194    	if ((RCC->CFGR & RCC_CFGR_PPRE1) == 0)
0000a2  480c              LDR      r0,|L1.212|
0000a4  6800              LDR      r0,[r0,#0]
0000a6  f40050e0          AND      r0,r0,#0x1c00
0000aa  b938              CBNZ     r0,|L1.188|
;;;195    	{   
;;;196    		/* 如果PCLK1 prescaler == 1 那么 TIMCLK = PCLK1 */
;;;197    		return ((RCC_ClockFreq.PCLK1_Frequency / PeriodValue)*8);
0000ac  490a              LDR      r1,|L1.216|
0000ae  9803              LDR      r0,[sp,#0xc]
0000b0  6809              LDR      r1,[r1,#0]  ; PeriodValue
0000b2  fbb0f0f1          UDIV     r0,r0,r1
0000b6  00c0              LSLS     r0,r0,#3
                  |L1.184|
;;;198    		
;;;199    	}
;;;200    	else
;;;201    	{   
;;;202    		/* 
;;;203    		  如果PCLK1 prescaler 不等于 1 那么 TIMCLK = 2 * PCLK1
;;;204    		  这里设置乘以8是因为前面设置每8个事件产生一次捕获。
;;;205    		*/
;;;206    		return (((2 * RCC_ClockFreq.PCLK1_Frequency) / PeriodValue)*8) ;
;;;207    		
;;;208    	}
;;;209    }
0000b8  b009              ADD      sp,sp,#0x24
0000ba  bd00              POP      {pc}
                  |L1.188|
0000bc  9803              LDR      r0,[sp,#0xc]          ;206
0000be  0040              LSLS     r0,r0,#1              ;206
0000c0  4905              LDR      r1,|L1.216|
0000c2  6809              LDR      r1,[r1,#0]            ;206  ; PeriodValue
0000c4  fbb0f0f1          UDIV     r0,r0,r1              ;206
0000c8  00c0              LSLS     r0,r0,#3              ;206
0000ca  e7f5              B        |L1.184|
;;;210    
                          ENDP

                  |L1.204|
                          DCD      0x40000c00
                  |L1.208|
                          DCD      CaptureNumber
                  |L1.212|
                          DCD      0x40023808
                  |L1.216|
                          DCD      PeriodValue

                          AREA ||i.IWDG_Feed||, CODE, READONLY, ALIGN=1

                  IWDG_Feed PROC
;;;98     */
;;;99     void IWDG_Feed(void)
000000  b510              PUSH     {r4,lr}
;;;100    {
;;;101    	IWDG_ReloadCounter();
000002  f7fffffe          BL       IWDG_ReloadCounter
;;;102    }
000006  bd10              POP      {r4,pc}
;;;103    
                          ENDP


                          AREA ||i.bsp_InitIwdg||, CODE, READONLY, ALIGN=2

                  bsp_InitIwdg PROC
;;;34     */
;;;35     void bsp_InitIwdg(uint32_t _ulIWDGTime)
000000  b510              PUSH     {r4,lr}
;;;36     {
000002  4604              MOV      r4,r0
;;;37         extern void sys_halt_process(void);
;;;38         
;;;39     	/* 检测系统是否从独立看门狗复位中恢复 */
;;;40     	if (RCC_GetFlagStatus(RCC_FLAG_IWDGRST) != RESET)
000004  207d              MOVS     r0,#0x7d
000006  f7fffffe          BL       RCC_GetFlagStatus
00000a  b118              CBZ      r0,|L3.20|
;;;41     	{		
;;;42             
;;;43             sys_halt_process();
00000c  f7fffffe          BL       sys_halt_process
;;;44     		/* 清除复位标志 */
;;;45     		RCC_ClearFlag();
000010  f7fffffe          BL       RCC_ClearFlag
                  |L3.20|
;;;46     	}
;;;47     	else
;;;48     	{
;;;49     		/* 标志没有设置 */
;;;50             //no_carsh_process();
;;;51     	}
;;;52     	
;;;53     #if 0
;;;54     	/* 通过TIM5输入捕获得到LSI频率 */
;;;55     	LsiFreq = GetLSIFrequency();
;;;56     #else
;;;57     	/* 使能LSI */
;;;58     	RCC_LSICmd(ENABLE);
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       RCC_LSICmd
;;;59     	
;;;60     	/* 等待直到LSI就绪 */
;;;61     	while (RCC_GetFlagStatus(RCC_FLAG_LSIRDY) == RESET)
00001a  bf00              NOP      
                  |L3.28|
00001c  2061              MOVS     r0,#0x61
00001e  f7fffffe          BL       RCC_GetFlagStatus
000022  2800              CMP      r0,#0
000024  d0fa              BEQ      |L3.28|
;;;62     	{}
;;;63     	
;;;64         /* */		
;;;65     	LsiFreq = 32000;
000026  f44f40fa          MOV      r0,#0x7d00
00002a  4908              LDR      r1,|L3.76|
00002c  6008              STR      r0,[r1,#0]  ; LsiFreq
;;;66     #endif
;;;67     	
;;;68     	/* 写入0x5555表示允许访问IWDG_PR 和IWDG_RLR寄存器 */
;;;69     	IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);
00002e  f2455055          MOV      r0,#0x5555
000032  f7fffffe          BL       IWDG_WriteAccessCmd
;;;70     	
;;;71     	/*  LSI/32 分频*/
;;;72     	IWDG_SetPrescaler(IWDG_Prescaler_32);
000036  2003              MOVS     r0,#3
000038  f7fffffe          BL       IWDG_SetPrescaler
;;;73     	
;;;74     	/*特别注意，由于这里_ulIWDGTime的最小单位是ms, 所以这里重装计数的
;;;75     	  计数时 需要除以1000
;;;76     	 Counter Reload Value = (_ulIWDGTime / 1000) /(1 / IWDG counter clock period)
;;;77     	                      = (_ulIWDGTime / 1000) / (32/LSI)
;;;78     	                      = (_ulIWDGTime / 1000) / (32/LsiFreq)
;;;79     	                      = LsiFreq * _ulIWDGTime / 32000
;;;80     	 实际测试LsiFreq = 34000，所以这里取1的时候 大概就是1ms 
;;;81     	*/
;;;82     	IWDG_SetReload(_ulIWDGTime);
00003c  b2a0              UXTH     r0,r4
00003e  f7fffffe          BL       IWDG_SetReload
;;;83     	
;;;84     	/* 重载IWDG计数 */
;;;85     	IWDG_ReloadCounter();
000042  f7fffffe          BL       IWDG_ReloadCounter
;;;86     	
;;;87     	/* 使能 IWDG (LSI oscillator 由硬件使能) */
;;;88     	IWDG_Enable();		
000046  f7fffffe          BL       IWDG_Enable
;;;89     }
00004a  bd10              POP      {r4,pc}
;;;90     
                          ENDP

                  |L3.76|
                          DCD      LsiFreq

                          AREA ||.data||, DATA, ALIGN=2

                  LsiFreq
                          DCD      0x00000000
                  CaptureNumber
                          DCD      0x00000000
                  PeriodValue
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\src\\bsp_iwdg.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_bsp_iwdg_c_LsiFreq____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_bsp_iwdg_c_LsiFreq____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_bsp_iwdg_c_LsiFreq____REVSH|
#line 144
|__asm___10_bsp_iwdg_c_LsiFreq____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
