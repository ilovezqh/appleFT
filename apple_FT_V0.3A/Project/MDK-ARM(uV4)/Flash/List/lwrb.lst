L 1 "..\..\User\lwrb\lwrb.c"
N/**
N * \file            lwrb.c
N * \brief           Lightweight ring buffer
N */
N
N/*
N * Copyright (c) 2020 Tilen MAJERLE
N *
N * Permission is hereby granted, free of charge, to any person
N * obtaining a copy of this software and associated documentation
N * files (the "Software"), to deal in the Software without restriction,
N * including without limitation the rights to use, copy, modify, merge,
N * publish, distribute, sublicense, and/or sell copies of the Software,
N * and to permit persons to whom the Software is furnished to do so,
N * subject to the following conditions:
N *
N * The above copyright notice and this permission notice shall be
N * included in all copies or substantial portions of the Software.
N *
N * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
N * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
N * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
N * AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
N * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
N * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
N * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
N * OTHER DEALINGS IN THE SOFTWARE.
N *
N * This file is part of LwRB - Lightweight ring buffer library.
N *
N * Author:          Tilen MAJERLE <tilen@majerle.eu>
N * Version:         v2.0.3
N */
N#include "lwrb/lwrb.h"
L 1 "..\..\User\lwrb/lwrb.h" 1
N/**
N * \file            lwrb.h
N * \brief           LwRB - Lightweight ring buffer
N */
N
N/*
N * Copyright (c) 2020 Tilen MAJERLE
N *
N * Permission is hereby granted, free of charge, to any person
N * obtaining a copy of this software and associated documentation
N * files (the "Software"), to deal in the Software without restriction,
N * including without limitation the rights to use, copy, modify, merge,
N * publish, distribute, sublicense, and/or sell copies of the Software,
N * and to permit persons to whom the Software is furnished to do so,
N * subject to the following conditions:
N *
N * The above copyright notice and this permission notice shall be
N * included in all copies or substantial portions of the Software.
N *
N * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
N * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
N * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
N * AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
N * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
N * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
N * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
N * OTHER DEALINGS IN THE SOFTWARE.
N *
N * This file is part of LwRB - Lightweight ring buffer library.
N *
N * Author:          Tilen MAJERLE <tilen@majerle.eu>
N * Version:         v2.0.3
N */
N#ifndef LWRB_HDR_H
N#define LWRB_HDR_H
N
N#include <string.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060044
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
X#elif !0L
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 38 "..\..\User\lwrb/lwrb.h" 2
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060044
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 39 "..\..\User\lwrb/lwrb.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif /* __cplusplus */
N
N/**
N * \defgroup        LWRB Lightweight ring buffer manager
N * \brief           Lightweight ring buffer manager
N * \{
N */
N
N/**
N * \brief           Enable buffer structure pointer parameters as volatile
N * To use this feature, uncomment keyword below, or define in global compiler settings
N */
N#ifndef LWRB_VOLATILE
N#define LWRB_VOLATILE                            volatile 
N#endif
N
N/**
N * \brief           Adds 2 magic words to make sure if memory is corrupted
N *                  application can detect wrong data pointer and maximum size
N */
N#ifndef LWRB_USE_MAGIC
N#define LWRB_USE_MAGIC                          1
N#endif
N
N/**
N * \brief           Event type for buffer operations
N */
Ntypedef enum {
N    LWRB_EVT_READ,                              /*!< Read event */
N    LWRB_EVT_WRITE,                             /*!< Write event */
N    LWRB_EVT_RESET,                             /*!< Reset event */
N} lwrb_evt_type_t;
N
N/**
N * \brief           Buffer structure forward declaration
N */
Nstruct lwrb;
N
N/**
N * \brief           Event callback function type
N * \param[in]       buff: Buffer handle for event
N * \param[in]       evt: Event type
N * \param[in]       bp: Number of bytes written or read (when used), depends on event type
N */
Ntypedef void (*lwrb_evt_fn)(struct lwrb* buff, lwrb_evt_type_t evt, size_t bp);
N
N/**
N * \brief           Buffer structure
N */
Ntypedef struct lwrb {
N#if LWRB_USE_MAGIC
X#if 1
N    uint32_t magic1;                            /*!< Magic 1 word */
N#endif /* LWRB_USE_MAGIC */
N    uint8_t* buff;                              /*!< Pointer to buffer data.
N                                                    Buffer is considered initialized when `buff != NULL` and `size > 0` */
N    LWRB_VOLATILE size_t size;                  /*!< Size of buffer data. Size of actual buffer is `1` byte less than value holds */
X    volatile size_t size;                   
N    LWRB_VOLATILE size_t r;                     /*!< Next read pointer. Buffer is considered empty when `r == w` and full when `w == r - 1` */
X    volatile size_t r;                      
N    LWRB_VOLATILE size_t w;                     /*!< Next write pointer. Buffer is considered empty when `r == w` and full when `w == r - 1` */
X    volatile size_t w;                      
N    lwrb_evt_fn evt_fn;                         /*!< Pointer to event callback function */
N#if LWRB_USE_MAGIC
X#if 1
N    uint32_t magic2;                            /*!< Magic 2 word */
N#endif /* LWRB_USE_MAGIC */
N} lwrb_t;
N
Nuint8_t     lwrb_init(lwrb_t* buff, void* buffdata, size_t size);
Nuint8_t     lwrb_is_ready(lwrb_t* buff);
Nvoid        lwrb_free(lwrb_t* buff);
Nvoid        lwrb_reset(lwrb_t* buff);
Nvoid        lwrb_set_evt_fn(lwrb_t* buff, lwrb_evt_fn fn);
N
N/* Read/Write functions */
Nsize_t      lwrb_write(lwrb_t* buff, const void* data, size_t btw);
Nsize_t      lwrb_read(lwrb_t* buff, void* data, size_t btr);
Nsize_t      lwrb_peek(lwrb_t* buff, size_t skip_count, void* data, size_t btp);
N
N/* Buffer size information */
Nsize_t      lwrb_get_free(lwrb_t* buff);
Nsize_t      lwrb_get_full(lwrb_t* buff);
N
N/* Read data block management */
Nvoid*       lwrb_get_linear_block_read_address(lwrb_t* buff);
Nsize_t      lwrb_get_linear_block_read_length(lwrb_t* buff);
Nsize_t      lwrb_skip(lwrb_t* buff, size_t len);
N
N/* Write data block management */
Nvoid*       lwrb_get_linear_block_write_address(lwrb_t* buff);
Nsize_t      lwrb_get_linear_block_write_length(lwrb_t* buff);
Nsize_t      lwrb_advance(lwrb_t* buff, size_t len);
N
N/**
N * \}
N */
N
N#ifdef __cplusplus
S}
N#endif /* __cplusplus */
N
N#endif /* LWRB_HDR_H */
L 35 "..\..\User\lwrb\lwrb.c" 2
N
N/* Memory set and copy functions */
N#define BUF_MEMSET                      memset
N#define BUF_MEMCPY                      memcpy
N
N#define BUF_MAGIC1                      (0xDEADBEEF)
N#define BUF_MAGIC2                      (~0xDEADBEEF)
N
N#if LWRB_USE_MAGIC
X#if 1
N#define BUF_IS_VALID(b)                 ((b) != NULL && (b)->magic1 == BUF_MAGIC1 && (b)->magic2 == BUF_MAGIC2 && (b)->buff != NULL && (b)->size > 0)
N#else
S#define BUF_IS_VALID(b)                 ((b) != NULL && (b)->buff != NULL && (b)->size > 0)
N#endif /* LWRB_USE_MAGIC */
N#define BUF_MIN(x, y)                   ((x) < (y) ? (x) : (y))
N#define BUF_MAX(x, y)                   ((x) > (y) ? (x) : (y))
N#define BUF_SEND_EVT(b, type, bp)       do { if ((b)->evt_fn != NULL) { (b)->evt_fn((b), (type), (bp)); } } while (0)
N
N/**
N * \brief           Initialize buffer handle to default values with size and buffer data array
N * \param[in]       buff: Buffer handle
N * \param[in]       buffdata: Pointer to memory to use as buffer data
N * \param[in]       size: Size of `buffdata` in units of bytes
N *                      Maximum number of bytes buffer can hold is `size - 1`
N * \return          `1` on success, `0` otherwise
N */
Nuint8_t
Nlwrb_init(lwrb_t* buff, void* buffdata, size_t size) {
N    if (buff == NULL || buffdata == NULL || size == 0) {
X    if (buff == 0 || buffdata == 0 || size == 0) {
N        return 0;
N    }
N
N    BUF_MEMSET((void*)buff, 0x00, sizeof(*buff));
X    memset((void*)buff, 0x00, sizeof(*buff));
N
N    buff->size = size;
N    buff->buff = buffdata;
N
N#if LWRB_USE_MAGIC
X#if 1
N    buff->magic1 = BUF_MAGIC1;
X    buff->magic1 = (0xDEADBEEF);
N    buff->magic2 = BUF_MAGIC2;
X    buff->magic2 = (~0xDEADBEEF);
N#endif /* LWRB_USE_MAGIC */
N
N    return 1;
N}
N
N/**
N * \brief           Check if buff is initialized and ready to use
N * \param[in]       buff: Buffer handle
N * \return          `1` if ready, `0` otherwise
N */
Nuint8_t
Nlwrb_is_ready(lwrb_t* buff) {
N    return BUF_IS_VALID(buff);
X    return ((buff) != 0 && (buff)->magic1 == (0xDEADBEEF) && (buff)->magic2 == (~0xDEADBEEF) && (buff)->buff != 0 && (buff)->size > 0);
N}
N
N/**
N * \brief           Free buffer memory
N * \note            Since implementation does not use dynamic allocation,
N *                  it just sets buffer handle to `NULL`
N * \param[in]       buff: Buffer handle
N */
Nvoid
Nlwrb_free(lwrb_t* buff) {
N    if (BUF_IS_VALID(buff)) {
X    if (((buff) != 0 && (buff)->magic1 == (0xDEADBEEF) && (buff)->magic2 == (~0xDEADBEEF) && (buff)->buff != 0 && (buff)->size > 0)) {
N        buff->buff = NULL;
X        buff->buff = 0;
N    }
N}
N
N/**
N * \brief           Set event function callback for different buffer operations
N * \param[in]       buff: Buffer handle
N * \param[in]       evt_fn: Callback function
N */
Nvoid
Nlwrb_set_evt_fn(lwrb_t* buff, lwrb_evt_fn evt_fn) {
N    if (BUF_IS_VALID(buff)) {
X    if (((buff) != 0 && (buff)->magic1 == (0xDEADBEEF) && (buff)->magic2 == (~0xDEADBEEF) && (buff)->buff != 0 && (buff)->size > 0)) {
N        buff->evt_fn = evt_fn;
N    }
N}
N
N/**
N * \brief           Write data to buffer.
N * Copies data from `data` array to buffer and marks buffer as full for maximum `btw` number of bytes
N *
N * \param[in]       buff: Buffer handle
N * \param[in]       data: Pointer to data to write into buffer
N * \param[in]       btw: Number of bytes to write
N * \return          Number of bytes written to buffer.
N *                      When returned value is less than `btw`, there was no enough memory available
N *                      to copy full data array
N */
Nsize_t
Nlwrb_write(lwrb_t* buff, const void* data, size_t btw) {
N    size_t tocopy, free;
N    volatile size_t buff_w_ptr;
N    const uint8_t* d = data;
N
N    if (!BUF_IS_VALID(buff) || data == NULL || btw == 0) {
X    if (!((buff) != 0 && (buff)->magic1 == (0xDEADBEEF) && (buff)->magic2 == (~0xDEADBEEF) && (buff)->buff != 0 && (buff)->size > 0) || data == 0 || btw == 0) {
N        return 0;
N    }
N
N    /* Calculate maximum number of bytes available to write */
N    free = lwrb_get_free(buff);
N    btw = BUF_MIN(free, btw);
X    btw = ((free) < (btw) ? (free) : (btw));
N    if (btw == 0) {
N        return 0;
N    }
N
N    /* Step 1: Write data to linear part of buffer */
N    buff_w_ptr = buff->w;
N    tocopy = BUF_MIN(buff->size - buff_w_ptr, btw);
X    tocopy = ((buff->size - buff_w_ptr) < (btw) ? (buff->size - buff_w_ptr) : (btw));
N    BUF_MEMCPY(&buff->buff[buff_w_ptr], d, tocopy);
X    memcpy(&buff->buff[buff_w_ptr], d, tocopy);
N    buff_w_ptr += tocopy;
N    btw -= tocopy;
N
N    /* Step 2: Write data to beginning of buffer (overflow part) */
N    if (btw > 0) {
N        BUF_MEMCPY(buff->buff, &d[tocopy], btw);
X        memcpy(buff->buff, &d[tocopy], btw);
N        buff_w_ptr = btw;
N    }
N
N    /* Step 3: Check end of buffer */
N    if (buff_w_ptr >= buff->size) {
N        buff_w_ptr = 0;
N    }
N
N    /*
N     * Write final value to the actual running variable.
N     * This is to ensure no read operation can access intermediate data
N     */
N    buff->w = buff_w_ptr;
N    
N    BUF_SEND_EVT(buff, LWRB_EVT_WRITE, tocopy + btw);
X    do { if ((buff)->evt_fn != 0) { (buff)->evt_fn((buff), (LWRB_EVT_WRITE), (tocopy + btw)); } } while (0);
N    return tocopy + btw;
N}
N
N/**
N * \brief           Read data from buffer.
N * Copies data from buffer to `data` array and marks buffer as free for maximum `btr` number of bytes
N *
N * \param[in]       buff: Buffer handle
N * \param[out]      data: Pointer to output memory to copy buffer data to
N * \param[in]       btr: Number of bytes to read
N * \return          Number of bytes read and copied to data array
N */
Nsize_t
Nlwrb_read(lwrb_t* buff, void* data, size_t btr) {
N    size_t tocopy, full;
N    volatile size_t buff_r_ptr;
N    uint8_t* d = data;
N
N    if (!BUF_IS_VALID(buff) || data == NULL || btr == 0) {
X    if (!((buff) != 0 && (buff)->magic1 == (0xDEADBEEF) && (buff)->magic2 == (~0xDEADBEEF) && (buff)->buff != 0 && (buff)->size > 0) || data == 0 || btr == 0) {
N        return 0;
N    }
N
N    /* Calculate maximum number of bytes available to read */
N    full = lwrb_get_full(buff);
N    btr = BUF_MIN(full, btr);
X    btr = ((full) < (btr) ? (full) : (btr));
N    if (btr == 0) {
N        return 0;
N    }
N
N    /* Step 1: Read data from linear part of buffer */
N    buff_r_ptr = buff->r;
N    tocopy = BUF_MIN(buff->size - buff_r_ptr, btr);
X    tocopy = ((buff->size - buff_r_ptr) < (btr) ? (buff->size - buff_r_ptr) : (btr));
N    BUF_MEMCPY(d, &buff->buff[buff_r_ptr], tocopy);
X    memcpy(d, &buff->buff[buff_r_ptr], tocopy);
N    buff_r_ptr += tocopy;
N    btr -= tocopy;
N
N    /* Step 2: Read data from beginning of buffer (overflow part) */
N    if (btr > 0) {
N        BUF_MEMCPY(&d[tocopy], buff->buff, btr);
X        memcpy(&d[tocopy], buff->buff, btr);
N        buff_r_ptr = btr;
N    }
N
N    /* Step 3: Check end of buffer */
N    if (buff_r_ptr >= buff->size) {
N        buff_r_ptr = 0;
N    }
N
N    /*
N     * Write final value to the actual running variable.
N     * This is to ensure no write operation can access intermediate data
N     */
N    buff->r = buff_r_ptr;
N
N    BUF_SEND_EVT(buff, LWRB_EVT_READ, tocopy + btr);
X    do { if ((buff)->evt_fn != 0) { (buff)->evt_fn((buff), (LWRB_EVT_READ), (tocopy + btr)); } } while (0);
N    return tocopy + btr;
N}
N
N/**
N * \brief           Read from buffer without changing read pointer (peek only)
N * \param[in]       buff: Buffer handle
N * \param[in]       skip_count: Number of bytes to skip before reading data
N * \param[out]      data: Pointer to output memory to copy buffer data to
N * \param[in]       btp: Number of bytes to peek
N * \return          Number of bytes peeked and written to output array
N */
Nsize_t
Nlwrb_peek(lwrb_t* buff, size_t skip_count, void* data, size_t btp) {
N    size_t full, tocopy;
N    volatile size_t r;
N    uint8_t* d = data;
N
N    if (!BUF_IS_VALID(buff) || data == NULL || btp == 0) {
X    if (!((buff) != 0 && (buff)->magic1 == (0xDEADBEEF) && (buff)->magic2 == (~0xDEADBEEF) && (buff)->buff != 0 && (buff)->size > 0) || data == 0 || btp == 0) {
N        return 0;
N    }
N
N    r = buff->r;
N
N    /* Calculate maximum number of bytes available to read */
N    full = lwrb_get_full(buff);
N
N    /* Skip beginning of buffer */
N    if (skip_count >= full) {
N        return 0;
N    }
N    r += skip_count;
N    full -= skip_count;
N    if (r >= buff->size) {
N        r -= buff->size;
N    }
N
N    /* Check maximum number of bytes available to read after skip */
N    btp = BUF_MIN(full, btp);
X    btp = ((full) < (btp) ? (full) : (btp));
N    if (btp == 0) {
N        return 0;
N    }
N
N    /* Step 1: Read data from linear part of buffer */
N    tocopy = BUF_MIN(buff->size - r, btp);
X    tocopy = ((buff->size - r) < (btp) ? (buff->size - r) : (btp));
N    BUF_MEMCPY(d, &buff->buff[r], tocopy);
X    memcpy(d, &buff->buff[r], tocopy);
N    btp -= tocopy;
N
N    /* Step 2: Read data from beginning of buffer (overflow part) */
N    if (btp > 0) {
N        BUF_MEMCPY(&d[tocopy], buff->buff, btp);
X        memcpy(&d[tocopy], buff->buff, btp);
N    }
N    return tocopy + btp;
N}
N
N/**
N * \brief           Get available size in buffer for write operation
N * \param[in]       buff: Buffer handle
N * \return          Number of free bytes in memory
N */
Nsize_t
Nlwrb_get_free(lwrb_t* buff) {
N    size_t size;
N    volatile size_t w, r;
N
N    if (!BUF_IS_VALID(buff)) {
X    if (!((buff) != 0 && (buff)->magic1 == (0xDEADBEEF) && (buff)->magic2 == (~0xDEADBEEF) && (buff)->buff != 0 && (buff)->size > 0)) {
N        return 0;
N    }
N
N    /* Use temporary values in case they are changed during operations */
N    w = buff->w;
N    r = buff->r;
N    if (w == r) {
N        size = buff->size;
N    } else if (r > w) {
N        size = r - w;
N    } else {
N        size = buff->size - (w - r);
N    }
N
N    /* Buffer free size is always 1 less than actual size */
N    return size - 1;
N}
N
N/**
N * \brief           Get number of bytes currently available in buffer
N * \param[in]       buff: Buffer handle
N * \return          Number of bytes ready to be read
N */
Nsize_t
Nlwrb_get_full(lwrb_t* buff) {
N    size_t size;
N    volatile size_t w, r;
N
N    if (!BUF_IS_VALID(buff)) {
X    if (!((buff) != 0 && (buff)->magic1 == (0xDEADBEEF) && (buff)->magic2 == (~0xDEADBEEF) && (buff)->buff != 0 && (buff)->size > 0)) {
N        return 0;
N    }
N
N    /* Use temporary values in case they are changed during operations */
N    w = buff->w;
N    r = buff->r;
N    if (w == r) {
N        size = 0;
N    } else if (w > r) {
N        size = w - r;
N    } else {
N        size = buff->size - (r - w);
N    }
N    return size;
N}
N
N/**
N * \brief           Resets buffer to default values. Buffer size is not modified
N * \note            This function is not thread safe.
N *                      When used, application must ensure there is no active read/write operation
N * \param[in]       buff: Buffer handle
N */
Nvoid
Nlwrb_reset(lwrb_t* buff) {
N    if (BUF_IS_VALID(buff)) {
X    if (((buff) != 0 && (buff)->magic1 == (0xDEADBEEF) && (buff)->magic2 == (~0xDEADBEEF) && (buff)->buff != 0 && (buff)->size > 0)) {
N        buff->w = 0;
N        buff->r = 0;
N        BUF_SEND_EVT(buff, LWRB_EVT_RESET, 0);
X        do { if ((buff)->evt_fn != 0) { (buff)->evt_fn((buff), (LWRB_EVT_RESET), (0)); } } while (0);
N    }
N}
N
N/**
N * \brief           Get linear address for buffer for fast read
N * \param[in]       buff: Buffer handle
N * \return          Linear buffer start address
N */
Nvoid*
Nlwrb_get_linear_block_read_address(lwrb_t* buff) {
N    if (!BUF_IS_VALID(buff)) {
X    if (!((buff) != 0 && (buff)->magic1 == (0xDEADBEEF) && (buff)->magic2 == (~0xDEADBEEF) && (buff)->buff != 0 && (buff)->size > 0)) {
N        return NULL;
X        return 0;
N    }
N    return &buff->buff[buff->r];
N}
N
N/**
N * \brief           Get length of linear block address before it overflows for read operation
N * \param[in]       buff: Buffer handle
N * \return          Linear buffer size in units of bytes for read operation
N */
Nsize_t
Nlwrb_get_linear_block_read_length(lwrb_t* buff) {
N    size_t len;
N    volatile size_t w, r;
N
N    if (!BUF_IS_VALID(buff)) {
X    if (!((buff) != 0 && (buff)->magic1 == (0xDEADBEEF) && (buff)->magic2 == (~0xDEADBEEF) && (buff)->buff != 0 && (buff)->size > 0)) {
N        return 0;
N    }
N
N    /* Use temporary values in case they are changed during operations */
N    w = buff->w;
N    r = buff->r;
N    if (w > r) {
N        len = w - r;
N    } else if (r > w) {
N        len = buff->size - r;
N    } else {
N        len = 0;
N    }
N    return len;
N}
N
N/**
N * \brief           Skip (ignore; advance read pointer) buffer data
N * Marks data as read in the buffer and increases free memory for up to `len` bytes
N *
N * \note            Useful at the end of streaming transfer such as DMA
N * \param[in]       buff: Buffer handle
N * \param[in]       len: Number of bytes to skip and mark as read
N * \return          Number of bytes skipped
N */
Nsize_t
Nlwrb_skip(lwrb_t* buff, size_t len) {
N    size_t full;
N    volatile size_t r;
N
N    if (!BUF_IS_VALID(buff) || len == 0) {
X    if (!((buff) != 0 && (buff)->magic1 == (0xDEADBEEF) && (buff)->magic2 == (~0xDEADBEEF) && (buff)->buff != 0 && (buff)->size > 0) || len == 0) {
N        return 0;
N    }
N
N    full = lwrb_get_full(buff);
N    len = BUF_MIN(len, full);
X    len = ((len) < (full) ? (len) : (full));
N    r = buff->r + len;
N    if (r >= buff->size) {
N        r -= buff->size;
N    }
N    buff->r = r;
N    BUF_SEND_EVT(buff, LWRB_EVT_READ, len);
X    do { if ((buff)->evt_fn != 0) { (buff)->evt_fn((buff), (LWRB_EVT_READ), (len)); } } while (0);
N    return len;
N}
N
N/**
N * \brief           Get linear address for buffer for fast read
N * \param[in]       buff: Buffer handle
N * \return          Linear buffer start address
N */
Nvoid*
Nlwrb_get_linear_block_write_address(lwrb_t* buff) {
N    if (!BUF_IS_VALID(buff)) {
X    if (!((buff) != 0 && (buff)->magic1 == (0xDEADBEEF) && (buff)->magic2 == (~0xDEADBEEF) && (buff)->buff != 0 && (buff)->size > 0)) {
N        return NULL;
X        return 0;
N    }
N    return &buff->buff[buff->w];
N}
N
N/**
N * \brief           Get length of linear block address before it overflows for write operation
N * \param[in]       buff: Buffer handle
N * \return          Linear buffer size in units of bytes for write operation
N */
Nsize_t
Nlwrb_get_linear_block_write_length(lwrb_t* buff) {
N    size_t len;
N    volatile size_t w, r;
N
N    if (!BUF_IS_VALID(buff)) {
X    if (!((buff) != 0 && (buff)->magic1 == (0xDEADBEEF) && (buff)->magic2 == (~0xDEADBEEF) && (buff)->buff != 0 && (buff)->size > 0)) {
N        return 0;
N    }
N
N    /* Use temporary values in case they are changed during operations */
N    w = buff->w;
N    r = buff->r;
N    if (w >= r) {
N        len = buff->size - w;
N        /*
N         * When read pointer is 0,
N         * maximal length is one less as if too many bytes
N         * are written, buffer would be considered empty again (r == w)
N         */
N        if (r == 0) {
N            /*
N             * Cannot overflow:
N             * - If r is not 0, statement does not get called
N             * - buff->size cannot be 0 and if r is 0, len is greater 0
N             */
N            --len;
N        }
N    } else {
N        len = r - w - 1;
N    }
N    return len;
N}
N
N/**
N * \brief           Advance write pointer in the buffer.
N * Similar to skip function but modifies write pointer instead of read
N *
N * \note            Useful when hardware is writing to buffer and application needs to increase number
N *                      of bytes written to buffer by hardware
N * \param[in]       buff: Buffer handle
N * \param[in]       len: Number of bytes to advance
N * \return          Number of bytes advanced for write operation
N */
Nsize_t
Nlwrb_advance(lwrb_t* buff, size_t len) {
N    size_t free;
N    volatile size_t w;
N
N    if (!BUF_IS_VALID(buff) || len == 0) {
X    if (!((buff) != 0 && (buff)->magic1 == (0xDEADBEEF) && (buff)->magic2 == (~0xDEADBEEF) && (buff)->buff != 0 && (buff)->size > 0) || len == 0) {
N        return 0;
N    }
N
N    /* Use local variables before writing back to main structure */
N    free = lwrb_get_free(buff);
N    len = BUF_MIN(len, free);
X    len = ((len) < (free) ? (len) : (free));
N    w = buff->w + len;
N    if (w >= buff->size) {
N        w -= buff->size;
N    }
N    buff->w = w;
N    BUF_SEND_EVT(buff, LWRB_EVT_WRITE, len);
X    do { if ((buff)->evt_fn != 0) { (buff)->evt_fn((buff), (LWRB_EVT_WRITE), (len)); } } while (0);
N    return len;
N}
