; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\flash\obj\bsp_adc.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_adc.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\User -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\User\FatFS\src -I..\..\Libraries\STM32_USB_Device_Library\Class\msc\inc -I..\..\Libraries\STM32_USB_Device_Library\Core\inc -I..\..\Libraries\STM32_USB_OTG_Driver\inc -I..\..\User\usbd_mass_storage -I..\..\User\BERRY_TWI -I..\..\User\berry_ft -I..\..\User\ft_support -I..\..\User\berry_test -I..\..\User\factory_test -I..\..\User\emenu -I..\..\User\kiwi_ft -I..\..\User\kiwi_ft\spv40 -I..\..\User\kiwi_ft\spv40\peripheral -I..\..\User\lwrb -I..\..\User\easylogger\inc -I..\..\User\easylogger\plugins\file -I..\..\User\LOG -I..\..\User\kiwi_ft -I..\..\User\MultiButton-1.1.0 -I"..\..\User\ugui v0.3" -I.\RTE\_Flash -IC:\Users\qizha\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\qizha\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.16.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F407xx -D_RTE_ -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY --signed_chars --omf_browse=.\flash\obj\bsp_adc.crf ..\..\User\bsp_stm32f4xx\src\bsp_adc.c]
                          THUMB

                          AREA ||i.Get_Adc||, CODE, READONLY, ALIGN=2

                  Get_Adc PROC
;;;303    //返回值:转换结果
;;;304    u16 Get_Adc(void)
000000  b510              PUSH     {r4,lr}
;;;305    {
;;;306       // 
;;;307        while(ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC ) != SET);//等待转换结束
000002  bf00              NOP      
                  |L1.4|
000004  2102              MOVS     r1,#2
000006  4809              LDR      r0,|L1.44|
000008  f7fffffe          BL       ADC_GetFlagStatus
00000c  2801              CMP      r0,#1
00000e  d1f9              BNE      |L1.4|
;;;308        ADC_SoftwareStartConv(ADC1);
000010  4806              LDR      r0,|L1.44|
000012  f7fffffe          BL       ADC_SoftwareStartConv
;;;309        uint16_t _adc_value = ADC_GetConversionValue(ADC1);
000016  4805              LDR      r0,|L1.44|
000018  f7fffffe          BL       ADC_GetConversionValue
00001c  4604              MOV      r4,r0
;;;310        ADC_ClearFlag(ADC1, ADC_FLAG_EOC);
00001e  2102              MOVS     r1,#2
000020  4802              LDR      r0,|L1.44|
000022  f7fffffe          BL       ADC_ClearFlag
;;;311        return _adc_value;	//返回最近一次ADC1规则组的转换结果
000026  4620              MOV      r0,r4
;;;312    }
000028  bd10              POP      {r4,pc}
;;;313    //获取通道ch的转换值，取times次,然后平均
                          ENDP

00002a  0000              DCW      0x0000
                  |L1.44|
                          DCD      0x40012000

                          AREA ||i.Get_Adc_Average||, CODE, READONLY, ALIGN=1

                  Get_Adc_Average PROC
;;;316    //返回值:通道ch的times次转换结果平均值
;;;317    u16 Get_Adc_Average(u8 ch, u8 times)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;318    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
;;;319        u32 temp_val = 0;
000008  2500              MOVS     r5,#0
;;;320        u8 t;
;;;321    
;;;322        for(t = 0; t < times; t++)
00000a  2600              MOVS     r6,#0
00000c  e007              B        |L2.30|
                  |L2.14|
;;;323        {
;;;324            temp_val += Get_Adc();
00000e  f7fffffe          BL       Get_Adc
000012  4405              ADD      r5,r5,r0
;;;325            //delay_ms(5);
;;;326            bsp_DelayMS(5);
000014  2005              MOVS     r0,#5
000016  f7fffffe          BL       bsp_DelayMS
00001a  1c70              ADDS     r0,r6,#1              ;322
00001c  b2c6              UXTB     r6,r0                 ;322
                  |L2.30|
00001e  42a6              CMP      r6,r4                 ;322
000020  dbf5              BLT      |L2.14|
;;;327        }
;;;328    
;;;329        return temp_val / times;
000022  fbb5f0f4          UDIV     r0,r5,r4
000026  b280              UXTH     r0,r0
;;;330    }
000028  e8bd81f0          POP      {r4-r8,pc}
;;;331    
                          ENDP


                          AREA ||i.VREF_PIN_Adc_Init||, CODE, READONLY, ALIGN=2

                  VREF_PIN_Adc_Init PROC
;;;157    
;;;158    void  VREF_PIN_Adc_Init(void)
000000  b500              PUSH     {lr}
;;;159    {
000002  b08d              SUB      sp,sp,#0x34
;;;160        GPIO_InitTypeDef  GPIO_InitStructure;
;;;161        ADC_CommonInitTypeDef ADC_CommonInitStructure;
;;;162        ADC_InitTypeDef       ADC_InitStructure;
;;;163    
;;;164    
;;;165        VREF_ADC_GPIO_APBxClock_FUN(VREF_ADC_GPIO_CLK, ENABLE);//使能GPIOC时钟
000004  2101              MOVS     r1,#1
000006  2004              MOVS     r0,#4
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;166        ADC_APBxClock_FUN(ADC_CLK, ENABLE); //使能ADC1时钟
00000c  2101              MOVS     r1,#1
00000e  0208              LSLS     r0,r1,#8
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;167    
;;;168    
;;;169        //先初始化ADC1通道0 IO口
;;;170        GPIO_InitStructure.GPIO_Pin = VREF_ADC_PIN;//PA0 通道0
000014  2001              MOVS     r0,#1
000016  900b              STR      r0,[sp,#0x2c]
;;;171        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;//模拟输入
000018  2003              MOVS     r0,#3
00001a  f88d0030          STRB     r0,[sp,#0x30]
;;;172        GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN ;//不带上下拉
00001e  2002              MOVS     r0,#2
000020  f88d0033          STRB     r0,[sp,#0x33]
;;;173        GPIO_Init(VREF_ADC_PORT, &GPIO_InitStructure);//初始化
000024  a90b              ADD      r1,sp,#0x2c
000026  4812              LDR      r0,|L3.112|
000028  f7fffffe          BL       GPIO_Init
;;;174    
;;;175    //    RCC_APB2PeriphResetCmd(ADC_CLK, ENABLE);	 //ADC1复位
;;;176    //    RCC_APB2PeriphResetCmd(ADC_CLK, DISABLE);	//复位结束
;;;177       ADC_StructInit(&ADC_InitStructure);
00002c  a801              ADD      r0,sp,#4
00002e  f7fffffe          BL       ADC_StructInit
;;;178        ADC_CommonInitStructure.ADC_Mode = ADC_Mode_Independent;//独立模式
000032  2000              MOVS     r0,#0
000034  9007              STR      r0,[sp,#0x1c]
;;;179        ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;//两个采样阶段之间的延迟5个时钟
000036  900a              STR      r0,[sp,#0x28]
;;;180        ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled; //DMA失能
000038  9009              STR      r0,[sp,#0x24]
;;;181        ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div4;//预分频4分频。ADCCLK=PCLK2/4=84/4=21Mhz,ADC时钟最好不要超过36Mhz
00003a  f44f3080          MOV      r0,#0x10000
00003e  9008              STR      r0,[sp,#0x20]
;;;182        ADC_CommonInit(&ADC_CommonInitStructure);//初始化
000040  a807              ADD      r0,sp,#0x1c
000042  f7fffffe          BL       ADC_CommonInit
;;;183    
;;;184        ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;//12位模式
000046  2000              MOVS     r0,#0
000048  9001              STR      r0,[sp,#4]
;;;185        ADC_InitStructure.ADC_ScanConvMode = DISABLE;//非扫描模式
00004a  f88d0008          STRB     r0,[sp,#8]
;;;186        ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;//关闭连续转换
00004e  f88d0009          STRB     r0,[sp,#9]
;;;187        ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;//禁止触发检测，使用软件触发
000052  9003              STR      r0,[sp,#0xc]
;;;188        ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;//右对齐
000054  9005              STR      r0,[sp,#0x14]
;;;189        ADC_InitStructure.ADC_NbrOfConversion = 1;//1个转换在规则序列中 也就是只转换规则序列1
000056  2001              MOVS     r0,#1
000058  f88d0018          STRB     r0,[sp,#0x18]
;;;190        ADC_Init(ADC_x, &ADC_InitStructure);//ADC初始化
00005c  a901              ADD      r1,sp,#4
00005e  4805              LDR      r0,|L3.116|
000060  f7fffffe          BL       ADC_Init
;;;191    
;;;192    
;;;193        ADC_Cmd(ADC_x, ENABLE);//开启AD转换器
000064  2101              MOVS     r1,#1
000066  4803              LDR      r0,|L3.116|
000068  f7fffffe          BL       ADC_Cmd
;;;194    
;;;195    }
00006c  b00d              ADD      sp,sp,#0x34
00006e  bd00              POP      {pc}
;;;196    
                          ENDP

                  |L3.112|
                          DCD      0x40020800
                  |L3.116|
                          DCD      0x40012000

                          AREA ||i.VREF_X_Adc_Init||, CODE, READONLY, ALIGN=2

                  VREF_X_Adc_Init PROC
;;;115    
;;;116    void  VREF_X_Adc_Init(void)
000000  b500              PUSH     {lr}
;;;117    {
000002  b08b              SUB      sp,sp,#0x2c
;;;118        ADC_CommonInitTypeDef ADC_CommonInitStructure;
;;;119        ADC_InitTypeDef       ADC_InitStructure;
;;;120    
;;;121        ADC_APBxClock_FUN(ADC_CLK, ENABLE); //使能ADC1时钟
000004  2101              MOVS     r1,#1
000006  0208              LSLS     r0,r1,#8
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;122    
;;;123    //    RCC_APB2PeriphResetCmd(ADC_CLK, ENABLE);	 //ADC1复位
;;;124    //    RCC_APB2PeriphResetCmd(ADC_CLK, DISABLE);	//复位结束
;;;125    
;;;126        ADC_CommonInitStructure.ADC_Mode = ADC_Mode_Independent;//独立模式
00000c  2000              MOVS     r0,#0
00000e  9007              STR      r0,[sp,#0x1c]
;;;127        ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;//两个采样阶段之间的延迟5个时钟
000010  900a              STR      r0,[sp,#0x28]
;;;128        ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled; //DMA失能
000012  9009              STR      r0,[sp,#0x24]
;;;129        ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div8;//预分频4分频。ADCCLK=PCLK2/4=84/4=21Mhz,ADC时钟最好不要超过36Mhz
000014  f44f3040          MOV      r0,#0x30000
000018  9008              STR      r0,[sp,#0x20]
;;;130        ADC_CommonInit(&ADC_CommonInitStructure);//初始化
00001a  a807              ADD      r0,sp,#0x1c
00001c  f7fffffe          BL       ADC_CommonInit
;;;131    
;;;132        ADC_StructInit(&ADC_InitStructure);
000020  a801              ADD      r0,sp,#4
000022  f7fffffe          BL       ADC_StructInit
;;;133        
;;;134        ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;//12位模式
000026  2000              MOVS     r0,#0
000028  9001              STR      r0,[sp,#4]
;;;135        ADC_InitStructure.ADC_ScanConvMode = DISABLE;//非扫描模式
00002a  f88d0008          STRB     r0,[sp,#8]
;;;136        ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;//连续转换
00002e  2001              MOVS     r0,#1
000030  f88d0009          STRB     r0,[sp,#9]
;;;137        ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;//禁止触发检测，使用软件触发
000034  2000              MOVS     r0,#0
000036  9003              STR      r0,[sp,#0xc]
;;;138        ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;//右对齐
000038  9005              STR      r0,[sp,#0x14]
;;;139        ADC_InitStructure.ADC_NbrOfConversion = 1;//1个转换在规则序列中 也就是只转换规则序列1
00003a  2001              MOVS     r0,#1
00003c  f88d0018          STRB     r0,[sp,#0x18]
;;;140        ADC_Init(ADC_x, &ADC_InitStructure);//ADC初始化
000040  a901              ADD      r1,sp,#4
000042  4809              LDR      r0,|L4.104|
000044  f7fffffe          BL       ADC_Init
;;;141    
;;;142        
;;;143        //设置指定ADC的规则组通道，一个序列，采样时间
;;;144        ADC_RegularChannelConfig(ADC1, 17, 1, ADC_SampleTime_56Cycles );	//ADC1,ADC通道,480个周期,提高采样时间可以提高精确度
000048  2303              MOVS     r3,#3
00004a  2201              MOVS     r2,#1
00004c  2111              MOVS     r1,#0x11
00004e  4806              LDR      r0,|L4.104|
000050  f7fffffe          BL       ADC_RegularChannelConfig
;;;145    
;;;146        ADC_Cmd(ADC_x, ENABLE);//开启AD转换器
000054  2101              MOVS     r1,#1
000056  4804              LDR      r0,|L4.104|
000058  f7fffffe          BL       ADC_Cmd
;;;147        ADC_SoftwareStartConv(ADC_x);
00005c  4802              LDR      r0,|L4.104|
00005e  f7fffffe          BL       ADC_SoftwareStartConv
;;;148    
;;;149    }
000062  b00b              ADD      sp,sp,#0x2c
000064  bd00              POP      {pc}
;;;150    
                          ENDP

000066  0000              DCW      0x0000
                  |L4.104|
                          DCD      0x40012000

                          AREA ||i.adc_at_deinit||, CODE, READONLY, ALIGN=2

                  adc_at_deinit PROC
;;;238    //吸烟的时候需要用到 AT作为bsp_key 的引脚检测
;;;239    void  adc_at_deinit(void)
000000  b500              PUSH     {lr}
;;;240    {
000002  b08d              SUB      sp,sp,#0x34
;;;241        GPIO_InitTypeDef  GPIO_InitStructure;
;;;242        ADC_CommonInitTypeDef ADC_CommonInitStructure;
;;;243        ADC_InitTypeDef       ADC_InitStructure;
;;;244    
;;;245    
;;;246        AT_ADC_GPIO_APBxClock_FUN(AT_ADC_GPIO_CLK, ENABLE);//使能GPIOA时钟
000004  2101              MOVS     r1,#1
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;247        ADC_APBxClock_FUN(ADC_CLK, ENABLE); //使能ADC1时钟
00000c  2101              MOVS     r1,#1
00000e  0208              LSLS     r0,r1,#8
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;248    
;;;249    
;;;250        //先初始化ADC1通道0 IO口
;;;251        GPIO_InitStructure.GPIO_Pin     = AT_ADC_PIN;//PA2 通道2
000014  2004              MOVS     r0,#4
000016  900b              STR      r0,[sp,#0x2c]
;;;252        GPIO_InitStructure.GPIO_Mode    = GPIO_Mode_IN;// 输入
000018  2000              MOVS     r0,#0
00001a  f88d0030          STRB     r0,[sp,#0x30]
;;;253        GPIO_InitStructure.GPIO_OType   = GPIO_OType_PP;
00001e  f88d0032          STRB     r0,[sp,#0x32]
;;;254        GPIO_InitStructure.GPIO_PuPd    = GPIO_PuPd_DOWN ;//内部下拉 电阻40KΩ
000022  2002              MOVS     r0,#2
000024  f88d0033          STRB     r0,[sp,#0x33]
;;;255        GPIO_Init(AT_ADC_PORT, &GPIO_InitStructure);//初始化
000028  a90b              ADD      r1,sp,#0x2c
00002a  4818              LDR      r0,|L5.140|
00002c  f7fffffe          BL       GPIO_Init
;;;256    
;;;257    //    RCC_APB2PeriphResetCmd(ADC_CLK, ENABLE);	 //ADC1复位
;;;258    //    RCC_APB2PeriphResetCmd(ADC_CLK, DISABLE);	//复位结束
;;;259        ADC_StructInit(&ADC_InitStructure);
000030  a801              ADD      r0,sp,#4
000032  f7fffffe          BL       ADC_StructInit
;;;260        ADC_CommonInitStructure.ADC_Mode = ADC_Mode_Independent;//独立模式
000036  2000              MOVS     r0,#0
000038  9007              STR      r0,[sp,#0x1c]
;;;261        ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;//两个采样阶段之间的延迟5个时钟
00003a  900a              STR      r0,[sp,#0x28]
;;;262        ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled; //DMA失能
00003c  9009              STR      r0,[sp,#0x24]
;;;263        ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div4;//预分频4分频。ADCCLK=PCLK2/4=84/4=21Mhz,ADC时钟最好不要超过36Mhz
00003e  f44f3080          MOV      r0,#0x10000
000042  9008              STR      r0,[sp,#0x20]
;;;264        ADC_CommonInit(&ADC_CommonInitStructure);//初始化
000044  a807              ADD      r0,sp,#0x1c
000046  f7fffffe          BL       ADC_CommonInit
;;;265    
;;;266        ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;//12位模式
00004a  2000              MOVS     r0,#0
00004c  9001              STR      r0,[sp,#4]
;;;267        ADC_InitStructure.ADC_ScanConvMode = DISABLE;//非扫描模式
00004e  f88d0008          STRB     r0,[sp,#8]
;;;268        ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;//连续转换
000052  2001              MOVS     r0,#1
000054  f88d0009          STRB     r0,[sp,#9]
;;;269        ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;//禁止触发检测，使用软件触发
000058  2000              MOVS     r0,#0
00005a  9003              STR      r0,[sp,#0xc]
;;;270        ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;//右对齐
00005c  9005              STR      r0,[sp,#0x14]
;;;271        ADC_InitStructure.ADC_NbrOfConversion = 1;//1个转换在规则序列中 也就是只转换规则序列1
00005e  2001              MOVS     r0,#1
000060  f88d0018          STRB     r0,[sp,#0x18]
;;;272        ADC_Init(ADC_x, &ADC_InitStructure);//ADC初始化
000064  a901              ADD      r1,sp,#4
000066  480a              LDR      r0,|L5.144|
000068  f7fffffe          BL       ADC_Init
;;;273        
;;;274        ADC_RegularChannelConfig(ADC1, 2, 1, ADC_SampleTime_56Cycles );	//ADC1,ADC通道,480个周期,提高采样时间可以提高精确度
00006c  2303              MOVS     r3,#3
00006e  2201              MOVS     r2,#1
000070  2102              MOVS     r1,#2
000072  4807              LDR      r0,|L5.144|
000074  f7fffffe          BL       ADC_RegularChannelConfig
;;;275        
;;;276        ADC_Cmd(ADC_x, ENABLE);//开启AD转换器
000078  2101              MOVS     r1,#1
00007a  4805              LDR      r0,|L5.144|
00007c  f7fffffe          BL       ADC_Cmd
;;;277        ADC_SoftwareStartConv(ADC_x);
000080  4803              LDR      r0,|L5.144|
000082  f7fffffe          BL       ADC_SoftwareStartConv
;;;278    }
000086  b00d              ADD      sp,sp,#0x34
000088  bd00              POP      {pc}
;;;279    
                          ENDP

00008a  0000              DCW      0x0000
                  |L5.140|
                          DCD      0x40020000
                  |L5.144|
                          DCD      0x40012000

                          AREA ||i.adc_at_init||, CODE, READONLY, ALIGN=2

                  adc_at_init PROC
;;;197    //scp测试
;;;198    void  adc_at_init(void)
000000  b500              PUSH     {lr}
;;;199    {
000002  b08d              SUB      sp,sp,#0x34
;;;200        GPIO_InitTypeDef  GPIO_InitStructure;
;;;201        ADC_CommonInitTypeDef ADC_CommonInitStructure;
;;;202        ADC_InitTypeDef       ADC_InitStructure;
;;;203    
;;;204    
;;;205        AT_ADC_GPIO_APBxClock_FUN(AT_ADC_GPIO_CLK, ENABLE);//使能GPIOA时钟
000004  2101              MOVS     r1,#1
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;206        ADC_APBxClock_FUN(ADC_CLK, ENABLE); //使能ADC1时钟
00000c  2101              MOVS     r1,#1
00000e  0208              LSLS     r0,r1,#8
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;207    
;;;208    
;;;209        //先初始化ADC1通道0 IO口
;;;210        GPIO_InitStructure.GPIO_Pin = AT_ADC_PIN;//PA2 通道2
000014  2004              MOVS     r0,#4
000016  900b              STR      r0,[sp,#0x2c]
;;;211        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;//模拟输入
000018  2003              MOVS     r0,#3
00001a  f88d0030          STRB     r0,[sp,#0x30]
;;;212        GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;//不带上下拉
00001e  2000              MOVS     r0,#0
000020  f88d0033          STRB     r0,[sp,#0x33]
;;;213        GPIO_Init(AT_ADC_PORT, &GPIO_InitStructure);//初始化
000024  a90b              ADD      r1,sp,#0x2c
000026  4818              LDR      r0,|L6.136|
000028  f7fffffe          BL       GPIO_Init
;;;214    
;;;215    //    RCC_APB2PeriphResetCmd(ADC_CLK, ENABLE);	 //ADC1复位
;;;216    //    RCC_APB2PeriphResetCmd(ADC_CLK, DISABLE);	//复位结束
;;;217        ADC_StructInit(&ADC_InitStructure);
00002c  a801              ADD      r0,sp,#4
00002e  f7fffffe          BL       ADC_StructInit
;;;218        ADC_CommonInitStructure.ADC_Mode = ADC_Mode_Independent;//独立模式
000032  2000              MOVS     r0,#0
000034  9007              STR      r0,[sp,#0x1c]
;;;219        ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;//两个采样阶段之间的延迟5个时钟
000036  900a              STR      r0,[sp,#0x28]
;;;220        ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled; //DMA失能
000038  9009              STR      r0,[sp,#0x24]
;;;221        ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div4;//预分频4分频。ADCCLK=PCLK2/4=84/4=21Mhz,ADC时钟最好不要超过36Mhz
00003a  f44f3080          MOV      r0,#0x10000
00003e  9008              STR      r0,[sp,#0x20]
;;;222        ADC_CommonInit(&ADC_CommonInitStructure);//初始化
000040  a807              ADD      r0,sp,#0x1c
000042  f7fffffe          BL       ADC_CommonInit
;;;223    
;;;224        ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;//12位模式
000046  2000              MOVS     r0,#0
000048  9001              STR      r0,[sp,#4]
;;;225        ADC_InitStructure.ADC_ScanConvMode = DISABLE;//非扫描模式
00004a  f88d0008          STRB     r0,[sp,#8]
;;;226        ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;//连续转换
00004e  2001              MOVS     r0,#1
000050  f88d0009          STRB     r0,[sp,#9]
;;;227        ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;//禁止触发检测，使用软件触发
000054  2000              MOVS     r0,#0
000056  9003              STR      r0,[sp,#0xc]
;;;228        ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;//右对齐
000058  9005              STR      r0,[sp,#0x14]
;;;229        ADC_InitStructure.ADC_NbrOfConversion = 1;//1个转换在规则序列中 也就是只转换规则序列1
00005a  2001              MOVS     r0,#1
00005c  f88d0018          STRB     r0,[sp,#0x18]
;;;230        ADC_Init(ADC_x, &ADC_InitStructure);//ADC初始化
000060  a901              ADD      r1,sp,#4
000062  480a              LDR      r0,|L6.140|
000064  f7fffffe          BL       ADC_Init
;;;231        
;;;232        ADC_RegularChannelConfig(ADC1, 2, 1, ADC_SampleTime_56Cycles );	//ADC1,ADC通道,480个周期,提高采样时间可以提高精确度
000068  2303              MOVS     r3,#3
00006a  2201              MOVS     r2,#1
00006c  2102              MOVS     r1,#2
00006e  4807              LDR      r0,|L6.140|
000070  f7fffffe          BL       ADC_RegularChannelConfig
;;;233        
;;;234        ADC_Cmd(ADC_x, ENABLE);//开启AD转换器
000074  2101              MOVS     r1,#1
000076  4805              LDR      r0,|L6.140|
000078  f7fffffe          BL       ADC_Cmd
;;;235        ADC_SoftwareStartConv(ADC_x);
00007c  4803              LDR      r0,|L6.140|
00007e  f7fffffe          BL       ADC_SoftwareStartConv
;;;236    }
000082  b00d              ADD      sp,sp,#0x34
000084  bd00              POP      {pc}
;;;237    
                          ENDP

000086  0000              DCW      0x0000
                  |L6.136|
                          DCD      0x40020000
                  |L6.140|
                          DCD      0x40012000

                          AREA ||i.adc_current_init||, CODE, READONLY, ALIGN=2

                  adc_current_init PROC
;;;8      //初始化ADC
;;;9      void  adc_current_init(void)
000000  b500              PUSH     {lr}
;;;10     {
000002  b08d              SUB      sp,sp,#0x34
;;;11         GPIO_InitTypeDef  GPIO_InitStructure;
;;;12         ADC_CommonInitTypeDef ADC_CommonInitStructure;
;;;13         ADC_InitTypeDef       ADC_InitStructure;
;;;14     
;;;15     
;;;16         RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);//使能GPIOc时钟
000004  2101              MOVS     r1,#1
000006  2004              MOVS     r0,#4
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;17         RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE); //使能ADC1时钟
00000c  2101              MOVS     r1,#1
00000e  0208              LSLS     r0,r1,#8
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;18     
;;;19     
;;;20         //先初始化ADC1通道0 IO口
;;;21         GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;//Pc1 通道11
000014  2002              MOVS     r0,#2
000016  900b              STR      r0,[sp,#0x2c]
;;;22         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;//模拟输入
000018  2003              MOVS     r0,#3
00001a  f88d0030          STRB     r0,[sp,#0x30]
;;;23         GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN ;//不带上下拉
00001e  2002              MOVS     r0,#2
000020  f88d0033          STRB     r0,[sp,#0x33]
;;;24         GPIO_Init(GPIOC, &GPIO_InitStructure);//初始化
000024  a90b              ADD      r1,sp,#0x2c
000026  4819              LDR      r0,|L7.140|
000028  f7fffffe          BL       GPIO_Init
;;;25     
;;;26     //    RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);	 //ADC1复位
;;;27     //    RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);	//复位结束
;;;28     
;;;29         ADC_StructInit(&ADC_InitStructure);
00002c  a801              ADD      r0,sp,#4
00002e  f7fffffe          BL       ADC_StructInit
;;;30         ADC_CommonInitStructure.ADC_Mode = ADC_Mode_Independent;//独立模式
000032  2000              MOVS     r0,#0
000034  9007              STR      r0,[sp,#0x1c]
;;;31         ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_20Cycles;//两个采样阶段之间的延迟5个时钟
000036  f44f6070          MOV      r0,#0xf00
00003a  900a              STR      r0,[sp,#0x28]
;;;32         ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled; //DMA失能
00003c  2000              MOVS     r0,#0
00003e  9009              STR      r0,[sp,#0x24]
;;;33         ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div4;//预分频4分频。ADCCLK=PCLK2/4=84/4=21Mhz,ADC时钟最好不要超过36Mhz
000040  f44f3080          MOV      r0,#0x10000
000044  9008              STR      r0,[sp,#0x20]
;;;34         ADC_CommonInit(&ADC_CommonInitStructure);//初始化
000046  a807              ADD      r0,sp,#0x1c
000048  f7fffffe          BL       ADC_CommonInit
;;;35     
;;;36         ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;//12位模式
00004c  2000              MOVS     r0,#0
00004e  9001              STR      r0,[sp,#4]
;;;37         ADC_InitStructure.ADC_ScanConvMode = DISABLE;//非扫描模式
000050  f88d0008          STRB     r0,[sp,#8]
;;;38         ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;//连续转换
000054  2001              MOVS     r0,#1
000056  f88d0009          STRB     r0,[sp,#9]
;;;39         ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;//禁止触发检测，使用软件触发
00005a  2000              MOVS     r0,#0
00005c  9003              STR      r0,[sp,#0xc]
;;;40         ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;//右对齐
00005e  9005              STR      r0,[sp,#0x14]
;;;41         ADC_InitStructure.ADC_NbrOfConversion = 1;//1个转换在规则序列中 也就是只转换规则序列1
000060  2001              MOVS     r0,#1
000062  f88d0018          STRB     r0,[sp,#0x18]
;;;42         ADC_Init(ADC1, &ADC_InitStructure);//ADC初始化
000066  a901              ADD      r1,sp,#4
000068  4809              LDR      r0,|L7.144|
00006a  f7fffffe          BL       ADC_Init
;;;43     
;;;44     
;;;45         //设置指定ADC的规则组通道，一个序列，采样时间
;;;46         ADC_RegularChannelConfig(ADC1, 11, 1, ADC_SampleTime_56Cycles );	//ADC1,ADC通道,480个周期,提高采样时间可以提高精确度
00006e  2303              MOVS     r3,#3
000070  2201              MOVS     r2,#1
000072  210b              MOVS     r1,#0xb
000074  4806              LDR      r0,|L7.144|
000076  f7fffffe          BL       ADC_RegularChannelConfig
;;;47     
;;;48         ADC_Cmd(ADC_x, ENABLE);//开启AD转换器
00007a  2101              MOVS     r1,#1
00007c  4804              LDR      r0,|L7.144|
00007e  f7fffffe          BL       ADC_Cmd
;;;49         ADC_SoftwareStartConv(ADC_x);
000082  4803              LDR      r0,|L7.144|
000084  f7fffffe          BL       ADC_SoftwareStartConv
;;;50     
;;;51     }
000088  b00d              ADD      sp,sp,#0x34
00008a  bd00              POP      {pc}
;;;52     
                          ENDP

                  |L7.140|
                          DCD      0x40020800
                  |L7.144|
                          DCD      0x40012000

                          AREA ||i.adc_scl_pu_init||, CODE, READONLY, ALIGN=2

                  adc_scl_pu_init PROC
;;;54     //初始化ADC
;;;55     void  adc_scl_pu_init(void)
000000  b500              PUSH     {lr}
;;;56     {
000002  b08d              SUB      sp,sp,#0x34
;;;57         GPIO_InitTypeDef  GPIO_InitStructure;
;;;58         ADC_CommonInitTypeDef ADC_CommonInitStructure;
;;;59         ADC_InitTypeDef       ADC_InitStructure;
;;;60     
;;;61         ADC_GPIO_APBxClock_FUN(ADC_GPIO_CLK, ENABLE);//使能GPIOA时钟
000004  2101              MOVS     r1,#1
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;62         ADC_APBxClock_FUN(ADC_CLK, ENABLE); //使能ADC1时钟
00000c  2101              MOVS     r1,#1
00000e  0208              LSLS     r0,r1,#8
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;63     
;;;64         //先初始化ADC1通道0 IO口
;;;65         GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;//PA0 通道0
000014  2001              MOVS     r0,#1
000016  900b              STR      r0,[sp,#0x2c]
;;;66         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;//模拟输入
000018  2003              MOVS     r0,#3
00001a  f88d0030          STRB     r0,[sp,#0x30]
;;;67         GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;//不带上下拉
00001e  2000              MOVS     r0,#0
000020  f88d0033          STRB     r0,[sp,#0x33]
;;;68         GPIO_Init(ADC_PORT, &GPIO_InitStructure);//初始化
000024  a90b              ADD      r1,sp,#0x2c
000026  481b              LDR      r0,|L8.148|
000028  f7fffffe          BL       GPIO_Init
;;;69     
;;;70     
;;;71     //    GPIO_InitStructure.GPIO_Pin     = GPIO_Pin_6;//PA0 通道0
;;;72     //    GPIO_InitStructure.GPIO_OType   = GPIO_OType_OD;
;;;73     //    GPIO_InitStructure.GPIO_Mode    = GPIO_Mode_OUT ;//模拟输入
;;;74     //    GPIO_InitStructure.GPIO_PuPd    = GPIO_PuPd_NOPULL ;//不带上下拉
;;;75     //    GPIO_Init(GPIOB, &GPIO_InitStructure);//初始化
;;;76     
;;;77     //    RCC_APB2PeriphResetCmd(ADC_CLK, ENABLE);	 //ADC1复位
;;;78     //    RCC_APB2PeriphResetCmd(ADC_CLK, DISABLE);	//复位结束
;;;79         
;;;80         ADC_CommonInitStructure.ADC_Mode = ADC_Mode_Independent;//独立模式
00002c  2000              MOVS     r0,#0
00002e  9007              STR      r0,[sp,#0x1c]
;;;81         ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_20Cycles;//两个采样阶段之间的延迟5个时钟
000030  f44f6070          MOV      r0,#0xf00
000034  900a              STR      r0,[sp,#0x28]
;;;82         ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled; //DMA失能
000036  2000              MOVS     r0,#0
000038  9009              STR      r0,[sp,#0x24]
;;;83         ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div4;//预分频4分频。ADCCLK=PCLK2/4=84/4=21Mhz,ADC时钟最好不要超过36Mhz
00003a  f44f3080          MOV      r0,#0x10000
00003e  9008              STR      r0,[sp,#0x20]
;;;84         ADC_CommonInit(&ADC_CommonInitStructure);//初始化
000040  a807              ADD      r0,sp,#0x1c
000042  f7fffffe          BL       ADC_CommonInit
;;;85         ADC_StructInit(&ADC_InitStructure);
000046  a801              ADD      r0,sp,#4
000048  f7fffffe          BL       ADC_StructInit
;;;86         ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;//12位模式
00004c  2000              MOVS     r0,#0
00004e  9001              STR      r0,[sp,#4]
;;;87         ADC_InitStructure.ADC_ScanConvMode = DISABLE;//非扫描模式
000050  f88d0008          STRB     r0,[sp,#8]
;;;88         ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;//连续转换
000054  2001              MOVS     r0,#1
000056  f88d0009          STRB     r0,[sp,#9]
;;;89         ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;//禁止触发检测，使用软件触发
00005a  2000              MOVS     r0,#0
00005c  9003              STR      r0,[sp,#0xc]
;;;90         ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;//右对齐
00005e  9005              STR      r0,[sp,#0x14]
;;;91         ADC_InitStructure.ADC_NbrOfConversion = 1;//1个转换在规则序列中 也就是只转换规则序列1
000060  2001              MOVS     r0,#1
000062  f88d0018          STRB     r0,[sp,#0x18]
;;;92         ADC_Init(ADC_x, &ADC_InitStructure);//ADC初始化
000066  a901              ADD      r1,sp,#4
000068  480b              LDR      r0,|L8.152|
00006a  f7fffffe          BL       ADC_Init
;;;93         //设置指定ADC的规则组通道，一个序列，采样时间
;;;94         ADC_RegularChannelConfig(ADC1, 0, 1, ADC_SampleTime_480Cycles );	//ADC1,ADC通道,480个周期,提高采样时间可以提高精确度
00006e  2307              MOVS     r3,#7
000070  2201              MOVS     r2,#1
000072  2100              MOVS     r1,#0
000074  4808              LDR      r0,|L8.152|
000076  f7fffffe          BL       ADC_RegularChannelConfig
;;;95     
;;;96         ADC_Cmd(ADC_x, ENABLE);//开启AD转换器
00007a  2101              MOVS     r1,#1
00007c  4806              LDR      r0,|L8.152|
00007e  f7fffffe          BL       ADC_Cmd
;;;97         ADC_SoftwareStartConv(ADC_x);
000082  4805              LDR      r0,|L8.152|
000084  f7fffffe          BL       ADC_SoftwareStartConv
;;;98         ADC_ClearFlag(ADC1, ADC_FLAG_EOC);
000088  2102              MOVS     r1,#2
00008a  4803              LDR      r0,|L8.152|
00008c  f7fffffe          BL       ADC_ClearFlag
;;;99     
;;;100        
;;;101    }
000090  b00d              ADD      sp,sp,#0x34
000092  bd00              POP      {pc}
;;;102    
                          ENDP

                  |L8.148|
                          DCD      0x40020000
                  |L8.152|
                          DCD      0x40012000

                          AREA ||i.scl_pu_adc||, CODE, READONLY, ALIGN=2

                  scl_pu_adc PROC
;;;102    
;;;103    void  scl_pu_adc(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;104    {
;;;105        GPIO_InitTypeDef  GPIO_InitStructure;
;;;106        
;;;107        //先初始化ADC1通道0 IO口
;;;108        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;//PA0 通道0
000002  2001              MOVS     r0,#1
000004  9000              STR      r0,[sp,#0]
;;;109        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;//模拟输入
000006  2003              MOVS     r0,#3
000008  f88d0004          STRB     r0,[sp,#4]
;;;110        //GPIO_InitStructure.GPIO_OType =  GPIO_OType_OD;
;;;111        GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;//不带上下拉
00000c  2000              MOVS     r0,#0
00000e  f88d0007          STRB     r0,[sp,#7]
;;;112        GPIO_Init(ADC_PORT, &GPIO_InitStructure);//初始化
000012  4669              MOV      r1,sp
000014  4801              LDR      r0,|L9.28|
000016  f7fffffe          BL       GPIO_Init
;;;113    }
00001a  bd1c              POP      {r2-r4,pc}
;;;114    
                          ENDP

                  |L9.28|
                          DCD      0x40020000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\src\\bsp_adc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_bsp_adc_c_1f847408____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_bsp_adc_c_1f847408____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_bsp_adc_c_1f847408____REVSH|
#line 144
|__asm___9_bsp_adc_c_1f847408____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
