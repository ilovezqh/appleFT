; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\flash\obj\cmb_app.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\cmb_app.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\User -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\User\FatFS\src -I..\..\Libraries\STM32_USB_Device_Library\Class\msc\inc -I..\..\Libraries\STM32_USB_Device_Library\Core\inc -I..\..\Libraries\STM32_USB_OTG_Driver\inc -I..\..\User\usbd_mass_storage -I..\..\User\ft_support -I..\..\User\test -I..\..\User\emenu -I..\..\User\chip_ft -I..\..\User\lwrb -I..\..\User\easylogger\inc -I..\..\User\easylogger\plugins\file -I..\..\User\LOG -I..\..\User\MultiButton-1.1.0 -I..\..\User\cm_backtrace -I..\..\User\MultiTimer -I.\RTE\_Flash -IC:\Users\qizha\AppData\Local\Arm\Packs\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Users\qizha\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.17.1\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=538 -D_RTE_ -DSTM32F407xx -D_RTE_ -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY --signed_chars --omf_browse=.\flash\obj\cmb_app.crf ..\..\User\cm_backtrace\cmb_app.c]
                          THUMB

                          AREA ||i.cmb_init||, CODE, READONLY, ALIGN=2

                  cmb_init PROC
;;;17     
;;;18     void cmb_init(void)
000000  b510              PUSH     {r4,lr}
;;;19     {
;;;20         /* USER CODE BEGIN 2 */
;;;21         printf("CmBacktrace Test...\r\n");
000002  a004              ADR      r0,|L1.20|
000004  f7fffffe          BL       __2printf
;;;22         //cmb_println("Test:abcdef\r\n");
;;;23         cm_backtrace_init(APPNAME, HARDWARE_VERSION, SOFTWARE_VERSION);
000008  a208              ADR      r2,|L1.44|
00000a  a10a              ADR      r1,|L1.52|
00000c  a00b              ADR      r0,|L1.60|
00000e  f7fffffe          BL       cm_backtrace_init
;;;24         //fault_test_by_div0();
;;;25     }
000012  bd10              POP      {r4,pc}
;;;26     
                          ENDP

                  |L1.20|
000014  436d4261          DCB      "CmBacktrace Test...\r\n",0
000018  636b7472
00001c  61636520
000020  54657374
000024  2e2e2e0d
000028  0a00    
00002a  00                DCB      0
00002b  00                DCB      0
                  |L1.44|
00002c  56302e30          DCB      "V0.0.1",0
000030  2e3100  
000033  00                DCB      0
                  |L1.52|
000034  56312e30          DCB      "V1.0.0",0
000038  2e3000  
00003b  00                DCB      0
                  |L1.60|
00003c  436d4261          DCB      "CmBacktrace",0
000040  636b7472
000044  61636500

                          AREA ||i.fault_test_by_div0||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  fault_test_by_div0 PROC
;;;28     /* USER CODE BEGIN PV */
;;;29     void fault_test_by_div0(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;30     {
;;;31         volatile int * SCB_CCR = (volatile int *) 0xE000ED14; // SCB->CCR
000004  4c07              LDR      r4,|L2.36|
;;;32         int x, y, z;
;;;33     
;;;34         *SCB_CCR |= (1 << 4); /* bit4: DIV_0_TRP. */
000006  6820              LDR      r0,[r4,#0]
000008  f0400010          ORR      r0,r0,#0x10
00000c  6020              STR      r0,[r4,#0]
;;;35     
;;;36         x = 10;
00000e  270a              MOVS     r7,#0xa
;;;37         y = 0;
000010  2500              MOVS     r5,#0
;;;38         z = x / y;
000012  fb97f6f5          SDIV     r6,r7,r5
;;;39         printf("z:%d\n", z);
000016  4631              MOV      r1,r6
000018  a003              ADR      r0,|L2.40|
00001a  f7fffffe          BL       __2printf
;;;40     }
00001e  e8bd81f0          POP      {r4-r8,pc}
;;;41     /* USER CODE END PV */
                          ENDP

000022  0000              DCW      0x0000
                  |L2.36|
                          DCD      0xe000ed14
                  |L2.40|
000028  7a3a2564          DCB      "z:%d\n",0
00002c  0a00    
00002e  00                DCB      0
00002f  00                DCB      0

                          AREA ||i.log_error||, CODE, READONLY, ALIGN=2

                  log_error PROC
;;;62     
;;;63     void log_error(uint32_t fault_handler_lr, uint32_t fault_handler_sp)
000000  b570              PUSH     {r4-r6,lr}
;;;64     {
000002  f5ad5d82          SUB      sp,sp,#0x1040
000006  4604              MOV      r4,r0
000008  460d              MOV      r5,r1
;;;65         // Init the error log
;;;66         memset(err_log, 0, sizeof(err_log)); 
00000a  f44f6180          MOV      r1,#0x400
00000e  4812              LDR      r0,|L3.88|
000010  f7fffffe          BL       __aeabi_memclr
;;;67         log_write_index = 0;
000014  2000              MOVS     r0,#0
000016  4911              LDR      r1,|L3.92|
000018  6008              STR      r0,[r1,#0]  ; log_write_index
;;;68         GPIOD->BSRRL = GPIO_Pin_11;			/* beep  */
00001a  f44f6000          MOV      r0,#0x800
00001e  4910              LDR      r1,|L3.96|
000020  8008              STRH     r0,[r1,#0]
;;;69         // Trigger cmbacktrace to output the error log
;;;70         cm_backtrace_fault(fault_handler_lr, fault_handler_sp); 
000022  4629              MOV      r1,r5
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       cm_backtrace_fault
;;;71     
;;;72         // Create a FATFS file object
;;;73         FIL log_file;
;;;74         FRESULT fr;
;;;75     
;;;76         // Try to open the error log file
;;;77         fr = f_open(&log_file, "0:/cm_error_log.txt", FA_WRITE | FA_OPEN_ALWAYS);
00002a  2212              MOVS     r2,#0x12
00002c  a10d              ADR      r1,|L3.100|
00002e  a806              ADD      r0,sp,#0x18
000030  f7fffffe          BL       f_open
000034  4606              MOV      r6,r0
;;;78         if (fr == FR_OK)
000036  b95e              CBNZ     r6,|L3.80|
;;;79         {
;;;80             // If the file is opened successfully, write the error log
;;;81             unsigned int written;
;;;82             fr = f_write(&log_file, err_log, log_write_index, &written);
000038  ab05              ADD      r3,sp,#0x14
00003a  4808              LDR      r0,|L3.92|
00003c  4906              LDR      r1,|L3.88|
00003e  6802              LDR      r2,[r0,#0]  ; log_write_index
000040  a806              ADD      r0,sp,#0x18
000042  f7fffffe          BL       f_write
000046  4606              MOV      r6,r0
;;;83             // Always make sure to close the file
;;;84             f_close(&log_file);
000048  a806              ADD      r0,sp,#0x18
00004a  f7fffffe          BL       f_close
;;;85         }
00004e  bf00              NOP      
                  |L3.80|
;;;86         // else: handle the error of opening the file
;;;87     }
000050  f50d5d82          ADD      sp,sp,#0x1040
000054  bd70              POP      {r4-r6,pc}
;;;88     
                          ENDP

000056  0000              DCW      0x0000
                  |L3.88|
                          DCD      err_log
                  |L3.92|
                          DCD      log_write_index
                  |L3.96|
                          DCD      0x40020c18
                  |L3.100|
000064  303a2f63          DCB      "0:/cm_error_log.txt",0
000068  6d5f6572
00006c  726f725f
000070  6c6f672e
000074  74787400

                          AREA ||i.print_UART1||, CODE, READONLY, ALIGN=2

                  print_UART1 PROC
;;;44     
;;;45     void print_UART1(const char *fmt, ...)
000000  b40f              PUSH     {r0-r3}
;;;46     {
000002  b510              PUSH     {r4,lr}
000004  f5ad7d02          SUB      sp,sp,#0x208
;;;47         char buf[PRINTF_BUF];
;;;48         va_list args;
;;;49         va_start(args, fmt);
000008  a885              ADD      r0,sp,#0x214
00000a  9001              STR      r0,[sp,#4]
;;;50         vsnprintf(buf, sizeof(buf), fmt, args);
00000c  f44f7100          MOV      r1,#0x200
000010  a802              ADD      r0,sp,#8
000012  9b01              LDR      r3,[sp,#4]
000014  9a84              LDR      r2,[sp,#0x210]
000016  f7fffffe          BL       vsnprintf
;;;51         va_end(args);
00001a  2000              MOVS     r0,#0
00001c  9001              STR      r0,[sp,#4]
;;;52     
;;;53         for (int i = 0; buf[i] != '\0'; i++)
00001e  2400              MOVS     r4,#0
000020  e018              B        |L4.84|
                  |L4.34|
;;;54         {
;;;55             err_log[log_write_index] = buf[i];
000022  a802              ADD      r0,sp,#8
000024  5d00              LDRB     r0,[r0,r4]
000026  4910              LDR      r1,|L4.104|
000028  4a10              LDR      r2,|L4.108|
00002a  6812              LDR      r2,[r2,#0]  ; log_write_index
00002c  5488              STRB     r0,[r1,r2]
;;;56             log_write_index++;
00002e  480f              LDR      r0,|L4.108|
000030  6800              LDR      r0,[r0,#0]  ; log_write_index
000032  1c40              ADDS     r0,r0,#1
000034  490d              LDR      r1,|L4.108|
000036  6008              STR      r0,[r1,#0]  ; log_write_index
;;;57             while (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET); // Wait for Empty
000038  bf00              NOP      
                  |L4.58|
00003a  2180              MOVS     r1,#0x80
00003c  480c              LDR      r0,|L4.112|
00003e  f7fffffe          BL       USART_GetFlagStatus
000042  2800              CMP      r0,#0
000044  d0f9              BEQ      |L4.58|
;;;58             USART_SendData(USART1, buf[i]); // Send char
000046  a802              ADD      r0,sp,#8
000048  5700              LDRSB    r0,[r0,r4]
00004a  b281              UXTH     r1,r0
00004c  4808              LDR      r0,|L4.112|
00004e  f7fffffe          BL       USART_SendData
000052  1c64              ADDS     r4,r4,#1              ;53
                  |L4.84|
000054  a802              ADD      r0,sp,#8              ;53
000056  5d00              LDRB     r0,[r0,r4]            ;53
000058  2800              CMP      r0,#0                 ;53
00005a  d1e2              BNE      |L4.34|
;;;59         }
;;;60     }
00005c  f50d7d02          ADD      sp,sp,#0x208
000060  bc10              POP      {r4}
000062  f85dfb14          LDR      pc,[sp],#0x14
;;;61     
                          ENDP

000066  0000              DCW      0x0000
                  |L4.104|
                          DCD      err_log
                  |L4.108|
                          DCD      log_write_index
                  |L4.112|
                          DCD      0x40011000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  err_log
                          %        1024

                          AREA ||.data||, DATA, ALIGN=2

                  log_write_index
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\cm_backtrace\\cmb_app.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_cmb_app_c_cmb_init____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_cmb_app_c_cmb_init____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_cmb_app_c_cmb_init____REVSH|
#line 144
|__asm___9_cmb_app_c_cmb_init____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___9_cmb_app_c_cmb_init__cmb_get_msp|
#line 346 "..\\..\\User\\cm_backtrace\\cmb_def.h"
|__asm___9_cmb_app_c_cmb_init__cmb_get_msp| PROC
#line 346

 mrs r0, msp
 bx lr
  
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___9_cmb_app_c_cmb_init__cmb_get_psp|
#line 350
|__asm___9_cmb_app_c_cmb_init__cmb_get_psp| PROC
#line 350

 mrs r0, psp
 bx lr
  
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___9_cmb_app_c_cmb_init__cmb_get_sp|
#line 354
|__asm___9_cmb_app_c_cmb_init__cmb_get_sp| PROC
#line 354

 mov r0, sp
 bx lr
  
	ENDP

;*** End   embedded assembler ***
